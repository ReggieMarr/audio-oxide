chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/etc/xdg/xdg-i3/nvim)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
could not source "/etc/xdg/xdg-i3/nvim/sysinit.vim"
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/etc/xdg/nvim)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
could not source "/etc/xdg/nvim/sysinit.vim"
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/usr/share/nvim)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
could not source "$VIM/sysinit.vim"
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/home/reggiemarr/.config/nvim)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
sourcing "/home/reggiemarr/.config/nvim/init.vim"
line 1: """"""""""""

line 2: " VIM PLUG "

line 3: """"""""""""

line 4: if empty(glob('~/.vim/autoload/plug.vim'))

line 6:       silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim

line 7:       autocmd VimEnter * PlugInstall --sync | source $MYVIMRC

line 8: endif

line 9: 

line 10: call plug#begin('~/.vim/plugged')

Searching for "autoload/plug.vim" in "/home/reggiemarr/.config/nvim,/etc/xdg/xdg-i3/nvim,/etc/xdg/nvim,/home/reggiemarr/.local/share/nvim/site,/usr/share/i3/nvim/site,/usr/local/share/nvim/site,/usr/share/nvim/site,/var/lib/snapd/desktop/nvim/site,/usr/share/nvim/runtime,/var/lib/snapd/desktop/nvim/site/after,/usr/share/nvim/site/after,/usr/local/share/nvim/site/after,/usr/share/i3/nvim/site/after,/home/reggiemarr/.local/share/nvim/site/after,/etc/xdg/nvim/after,/etc/xdg/xdg-i3/nvim/after,/home/reggiemarr/.config/nvim/after"
Searching for "/home/reggiemarr/.config/nvim/autoload/plug.vim"
Searching for "/etc/xdg/xdg-i3/nvim/autoload/plug.vim"
Searching for "/etc/xdg/nvim/autoload/plug.vim"
Searching for "/home/reggiemarr/.local/share/nvim/site/autoload/plug.vim"
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/home/reggiemarr/.local/share/nvim/site/autoload)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
line 10: sourcing "/home/reggiemarr/.local/share/nvim/site/autoload/plug.vim"
line 1: " vim-plug: Vim plugin manager

line 2: " ============================

line 3: "

line 4: " Download plug.vim and put it in ~/.vim/autoload

line 5: "

line 6: "   curl -fLo ~/.vim/autoload/plug.vim --create-dirs \

line 7: "     https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim

line 8: "

line 9: " Edit your .vimrc

line 10: "

line 11: "   call plug#begin('~/.vim/plugged')

line 12: "

line 13: "   " Make sure you use single quotes

line 14: "

line 15: "   " Shorthand notation; fetches https://github.com/junegunn/vim-easy-align

line 16: "   Plug 'junegunn/vim-easy-align'

line 17: "

line 18: "   " Any valid git URL is allowed

line 19: "   Plug 'https://github.com/junegunn/vim-github-dashboard.git'

line 20: "

line 21: "   " Multiple Plug commands can be written in a single line using | separators

line 22: "   Plug 'SirVer/ultisnips' | Plug 'honza/vim-snippets'

line 23: "

line 24: "   " On-demand loading

line 25: "   Plug 'scrooloose/nerdtree', { 'on':  'NERDTreeToggle' }

line 26: "   Plug 'tpope/vim-fireplace', { 'for': 'clojure' }

line 27: "

line 28: "   " Using a non-master branch

line 29: "   Plug 'rdnetto/YCM-Generator', { 'branch': 'stable' }

line 30: "

line 31: "   " Using a tagged release; wildcard allowed (requires git 1.9.2 or above)

line 32: "   Plug 'fatih/vim-go', { 'tag': '*' }

line 33: "

line 34: "   " Plugin options

line 35: "   Plug 'nsf/gocode', { 'tag': 'v.20150303', 'rtp': 'vim' }

line 36: "

line 37: "   " Plugin outside ~/.vim/plugged with post-update hook

line 38: "   Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }

line 39: "

line 40: "   " Unmanaged plugin (manually installed and updated)

line 41: "   Plug '~/my-prototype-plugin'

line 42: "

line 43: "   " Initialize plugin system

line 44: "   call plug#end()

line 45: "

line 46: " Then reload .vimrc and :PlugInstall to install plugins.

line 47: "

line 48: " Plug options:

line 49: "

line 50: "| Option                  | Description                                      |

line 51: "| ----------------------- | ------------------------------------------------ |

line 52: "| `branch`/`tag`/`commit` | Branch/tag/commit of the repository to use       |

line 53: "| `rtp`                   | Subdirectory that contains Vim plugin            |

line 54: "| `dir`                   | Custom directory for the plugin                  |

line 55: "| `as`                    | Use different name for the plugin                |

line 56: "| `do`                    | Post-update hook (string or funcref)             |

line 57: "| `on`                    | On-demand loading: Commands or `<Plug>`-mappings |

line 58: "| `for`                   | On-demand loading: File types                    |

line 59: "| `frozen`                | Do not update unless explicitly specified        |

line 60: "

line 61: " More information: https://github.com/junegunn/vim-plug

line 62: "

line 63: "

line 64: " Copyright (c) 2017 Junegunn Choi

line 65: "

line 66: " MIT License

line 67: "

line 68: " Permission is hereby granted, free of charge, to any person obtaining

line 69: " a copy of this software and associated documentation files (the

line 70: " "Software"), to deal in the Software without restriction, including

line 71: " without limitation the rights to use, copy, modify, merge, publish,

line 72: " distribute, sublicense, and/or sell copies of the Software, and to

line 73: " permit persons to whom the Software is furnished to do so, subject to

line 74: " the following conditions:

line 75: "

line 76: " The above copyright notice and this permission notice shall be

line 77: " included in all copies or substantial portions of the Software.

line 78: "

line 79: " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

line 80: " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

line 81: " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

line 82: " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE

line 83: " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION

line 84: " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION

line 85: " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

line 86: 

line 87: if exists('g:loaded_plug')

line 88:   finish

line 89: endif

line 90: let g:loaded_plug = 1

line 91: 

line 92: let s:cpo_save = &cpo

line 93: set cpo&vim

line 94: 

line 95: let s:plug_src = 'https://github.com/junegunn/vim-plug.git'

line 96: let s:plug_tab = get(s:, 'plug_tab', -1)

line 97: let s:plug_buf = get(s:, 'plug_buf', -1)

line 98: let s:mac_gui = has('gui_macvim') && has('gui_running')

line 99: let s:is_win = has('win32')

line 100: let s:nvim = has('nvim-0.2') || (has('nvim') && exists('*jobwait') && !s:is_win)

line 101: let s:vim8 = has('patch-8.0.0039') && exists('*job_start')

line 102: let s:me = resolve(expand('<sfile>:p'))

line 103: let s:base_spec = { 'branch': 'master', 'frozen': 0 }

line 109: let s:TYPE = {   'string':  type(''),   'list':    type([]),   'dict':    type({}),   'funcref': type(function('call')) }

line 110: let s:loaded = get(s:, 'loaded', {})

line 111: let s:triggers = get(s:, 'triggers', {})

line 112: 

line 113: function! plug#begin(...)

line 136: 

line 137: function! s:define_commands()

line 150: 

line 151: function! s:to_a(v)

line 154: 

line 155: function! s:to_s(v)

line 158: 

line 159: function! s:glob(from, pattern)

line 162: 

line 163: function! s:source(from, ...)

line 173: 

line 174: function! s:assoc(dict, key, val)

line 177: 

line 178: function! s:ask(message, ...)

line 187: 

line 188: function! s:ask_no_interrupt(...)

line 195: 

line 196: function! s:lazy(plug, opt)

line 203: 

line 204: function! plug#end()

line 296: 

line 297: function! s:loaded_names()

line 300: 

line 301: function! s:load_plugin(spec)

line 304: 

line 305: function! s:reload_plugins()

line 310: 

line 311: function! s:trim(str)

line 314: 

line 315: function! s:version_requirement(val, min)

line 324: 

line 325: function! s:git_version_requirement(...)

line 331: 

line 332: function! s:progress_opt(base)

line 336: 

line 337: function! s:rtp(spec)

line 340: 

line 341: if s:is_win

line 342:   function! s:path(path)

line 345: 

line 346:   function! s:dirpath(path)

line 349: 

line 350:   function! s:is_local_plug(repo)

line 353: 

line 354:   " Copied from fzf

line 355:   function! s:wrap_cmds(cmds)

line 368: 

line 369:   function! s:batchfile(cmd)

line 378: else

line 379:   function! s:path(path)

line 382: 

line 383:   function! s:dirpath(path)

line 386: 

line 387:   function! s:is_local_plug(repo)

line 390: endif

line 391: 

line 392: function! s:err(msg)

line 397: 

line 398: function! s:warn(cmd, msg)

line 403: 

line 404: function! s:esc(path)

line 407: 

line 408: function! s:escrtp(path)

line 411: 

line 412: function! s:remove_rtp()

line 422: 

line 423: function! s:reorg_rtp()

line 449: 

line 450: function! s:doautocmd(...)

line 455: 

line 456: function! s:dobufread(names)

line 469: 

line 470: function! plug#load(...)

line 493: 

line 494: function! s:remove_triggers(name)

line 507: 

line 508: function! s:lod(names, types, ...)

line 529: 

line 530: function! s:lod_ft(pat, names)

line 537: 

line 538: function! s:lod_cmd(cmd, bang, l1, l2, args, names)

line 543: 

line 544: function! s:lod_map(map, names, with_prefix, prefix)

line 569: 

line 570: function! plug#(repo, ...)

line 589: 

line 590: function! s:parse_options(arg)

line 605: 

line 606: function! s:infer_properties(name, repo)

line 623: 

line 624: function! s:install(force, names)

line 627: 

line 628: function! s:update(force, names)

line 631: 

line 632: function! plug#helptags()

line 644: 

line 645: function! s:syntax()

line 696: 

line 697: function! s:lpad(str, len)

line 700: 

line 701: function! s:lines(msg)

line 704: 

line 705: function! s:lastline(msg)

line 708: 

line 709: function! s:new_window()

line 712: 

line 713: function! s:plug_window_exists()

line 717: 

line 718: function! s:switch_in()

line 736: 

line 737: function! s:switch_out(...)

line 750: 

line 751: function! s:finish_bindings()

line 760: 

line 761: function! s:prepare(...)

line 803: 

line 804: function! s:assign_name()

line 815: 

line 816: function! s:chsh(swap)

line 823: 

line 824: function! s:bang(cmd, ...)

line 844: 

line 845: function! s:regress_bar()

line 849: 

line 850: function! s:is_updated(dir)

line 853: 

line 854: function! s:do(pull, force, todo)

line 907: 

line 908: function! s:hash_match(a, b)

line 911: 

line 912: function! s:checkout(spec)

line 921: 

line 922: function! s:finish(pull)

line 945: 

line 946: function! s:retry()

line 954: 

line 955: function! s:is_managed(name)

line 958: 

line 959: function! s:names(...)

line 962: 

line 963: function! s:check_ruby()

line 973: 

line 974: function! s:update_impl(pull, force, args) abort

line 1091: 

line 1092: function! s:log4(name, msg)

line 1096: 

line 1097: function! s:update_finish()

line 1158: 

line 1159: function! s:job_abort()

line 1176: 

line 1177: function! s:last_non_empty_line(lines)

line 1187: 

line 1188: function! s:job_out_cb(self, data) abort

line 1201: 

line 1202: function! s:job_exit_cb(self, data) abort

line 1208: 

line 1209: function! s:job_cb(fn, job, ch, data)

line 1215: 

line 1216: function! s:nvim_cb(job_id, data, event) dict abort

line 1221: 

line 1222: function! s:spawn(name, cmd, opts)

line 1262: 

line 1263: function! s:reap(name)

line 1279: 

line 1280: function! s:bar()

line 1289: 

line 1290: function! s:logpos(name)

line 1303: 

line 1304: function! s:log(bullet, name, lines)

line 1321: 

line 1322: function! s:update_vim()

line 1328: 

line 1329: function! s:tick()

line 1378: 

line 1379: function! s:update_python()

line 1767: 

line 1768: function! s:update_ruby()

line 1993: 

line 1994: function! s:shellesc_cmd(arg, script)

line 1998: 

line 1999: function! s:shellesc_ps1(arg)

line 2002: 

line 2003: function! plug#shellescape(arg, ...)

line 2014: 

line 2015: function! s:glob_dir(path)

line 2018: 

line 2019: function! s:progress_bar(line, bar, total)

line 2022: 

line 2023: function! s:compare_git_uri(a, b)

line 2034: 

line 2035: function! s:format_message(bullet, name, message)

line 2043: 

line 2044: function! s:with_cd(cmd, dir, ...)

line 2048: 

line 2049: function! s:system(cmd, ...)

line 2064: 

line 2065: function! s:system_chomp(...)

line 2069: 

line 2070: function! s:git_validate(spec, check_branch)

line 2129: 

line 2130: function! s:rm_rf(dir)

line 2135: 

line 2136: function! s:clean(force)

line 2206: 

line 2207: function! s:delete_op(type, ...)

line 2210: 

line 2211: function! s:delete(range, force)

line 2233: 

line 2234: function! s:upgrade()

line 2260: 

line 2261: function! s:upgrade_specs()

line 2266: 

line 2267: function! s:status()

line 2312: 

line 2313: function! s:extract_name(str, prefix, suffix)

line 2316: 

line 2317: function! s:status_load(lnum)

line 2327: 

line 2328: function! s:status_update() range

line 2336: 

line 2337: function! s:is_preview_window_open()

line 2344: 

line 2345: function! s:find_name(lnum)

line 2358: 

line 2359: function! s:preview_commit()

line 2399: 

line 2400: function! s:section(flags)

line 2403: 

line 2404: function! s:format_git_log(line)

line 2415: 

line 2416: function! s:append_ul(lnum, text)

line 2419: 

line 2420: function! s:diff()

line 2473: 

line 2474: function! s:revert()

line 2491: 

line 2492: function! s:snapshot(force, ...) abort

line 2523: 

line 2524: function! s:split_rtp()

line 2527: 

line 2528: let s:first_rtp = s:escrtp(get(s:split_rtp(), 0, ''))

calling function <SNR>2_split_rtp()

line 1:   return split(&rtp, '\\\@<!,')

function <SNR>2_split_rtp returning ['/home/reggiemarr/.config/nvim', '/et... '/home/reggiemarr/.config/nvim/after']

continuing in /home/reggiemarr/.local/share/nvim/site/autoload/plug.vim

calling function <SNR>2_escrtp('/home/reggiemarr/.config/nvim')

line 1:   return escape(a:path, ' ,')

function <SNR>2_escrtp returning '/home/reggiemarr/.config/nvim'

continuing in /home/reggiemarr/.local/share/nvim/site/autoload/plug.vim

line 2529: let s:last_rtp  = s:escrtp(get(s:split_rtp(), -1, ''))

calling function <SNR>2_split_rtp()

line 1:   return split(&rtp, '\\\@<!,')

function <SNR>2_split_rtp returning ['/home/reggiemarr/.config/nvim', '/et... '/home/reggiemarr/.config/nvim/after']

continuing in /home/reggiemarr/.local/share/nvim/site/autoload/plug.vim

calling function <SNR>2_escrtp('/home/reggiemarr/.config/nvim/after')

line 1:   return escape(a:path, ' ,')

function <SNR>2_escrtp returning '/home/reggiemarr/.config/nvim/after'

continuing in /home/reggiemarr/.local/share/nvim/site/autoload/plug.vim

line 2530: 

line 2531: if exists('g:plugs')

line 2532:   let g:plugs_order = get(g:, 'plugs_order', keys(g:plugs))

line 2533:   call s:upgrade_specs()

line 2534:   call s:define_commands()

line 2535: endif

line 2536: 

line 2537: let &cpo = s:cpo_save

line 2538: unlet s:cpo_save

finished sourcing /home/reggiemarr/.local/share/nvim/site/autoload/plug.vim
continuing in /home/reggiemarr/.config/nvim/init.vim
calling function plug#begin('~/.vim/plugged')

line 1:   if a:0 > 0

line 2:     let s:plug_home_org = a:1

line 3:     let home = s:path(fnamemodify(expand(a:1), ':p'))

calling function plug#begin[3]..<SNR>2_path('/home/reggiemarr/.vim/plugged/')

line 1:     return s:trim(a:path)

calling function plug#begin[3]..<SNR>2_path[1]..<SNR>2_trim('/home/reggiemarr/.vim/plugged/')

line 1:   return substitute(a:str, '[\/]\+$', '', '')

function plug#begin[3]..<SNR>2_path[1]..<SNR>2_trim returning '/home/reggiemarr/.vim/plugged'

continuing in function plug#begin[3]..<SNR>2_path

function plug#begin[3]..<SNR>2_path returning '/home/reggiemarr/.vim/plugged'

continuing in function plug#begin

line 4:   elseif exists('g:plug_home')

line 5:     let home = s:path(g:plug_home)

line 6:   elseif !empty(&rtp)

line 7:     let home = s:path(split(&rtp, ',')[0]) . '/plugged'

line 8:   else

line 9:     return s:err('Unable to determine plug home. Try calling plug#begin() with a path argument.')

line 10:   endif

line 11:   if fnamemodify(home, ':t') ==# 'plugin' && fnamemodify(home, ':h') ==# s:first_rtp

line 12:     return s:err('Invalid plug home. '.home.' is a standard Vim runtime path and is not allowed.')

line 13:   endif

line 14: 

line 15:   let g:plug_home = home

line 16:   let g:plugs = {}

line 17:   let g:plugs_order = []

line 18:   let s:triggers = {}

line 19: 

line 20:   call s:define_commands()

calling function plug#begin[20]..<SNR>2_define_commands()

line 1:   command! -nargs=+ -bar Plug call plug#(<args>)

line 2:   if !executable('git')

line 3:     return s:err('`git` executable not found. Most commands will not be available. To suppress this message, prepend `silent!` to `call plug#begin(...)`.')

line 4:   endif

line 5:   command! -nargs=* -bar -bang -complete=customlist,s:names PlugInstall call s:install(<bang>0, [<f-args>])

line 6:   command! -nargs=* -bar -bang -complete=customlist,s:names PlugUpdate  call s:update(<bang>0, [<f-args>])

line 7:   command! -nargs=0 -bar -bang PlugClean call s:clean(<bang>0)

line 8:   command! -nargs=0 -bar PlugUpgrade if s:upgrade() | execute 'source' s:esc(s:me) | endif

line 9:   command! -nargs=0 -bar PlugStatus  call s:status()

line 10:   command! -nargs=0 -bar PlugDiff    call s:diff()

line 11:   command! -nargs=? -bar -bang -complete=file PlugSnapshot call s:snapshot(<bang>0, <f-args>)

function plug#begin[20]..<SNR>2_define_commands returning #0

continuing in function plug#begin

line 21:   return 1

function plug#begin returning #1

continuing in /home/reggiemarr/.config/nvim/init.vim

line 14:     Plug 'autozimu/LanguageClient-neovim', { 'branch': 'next', 'do': 'bash install.sh', }

line 14: call plug#('autozimu/LanguageClient-neovim', { 'branch': 'next', 'do': 'bash install.sh', })

calling function plug#('autozimu/LanguageClient-neovim', {'do': 'bash install.sh', 'branch': 'next'})

line 1:   if a:0 > 1

line 2:     return s:err('Invalid number of arguments (1..2)')

line 3:   endif

line 4: 

line 5:   try

line 6:     let repo = s:trim(a:repo)

calling function plug#[6]..<SNR>2_trim('autozimu/LanguageClient-neovim')

line 1:   return substitute(a:str, '[\/]\+$', '', '')

function plug#[6]..<SNR>2_trim returning 'autozimu/LanguageClient-neovim'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec

calling function plug#[7]..<SNR>2_parse_options({'do': 'bash install.sh', 'branch': 'next'})

line 1:   let opts = copy(s:base_spec)

line 2:   let type = type(a:arg)

line 3:   if type == s:TYPE.string

line 4:     let opts.tag = a:arg

line 5:   elseif type == s:TYPE.dict

line 6:     call extend(opts, a:arg)

line 7:     if has_key(opts, 'dir')

line 8:       let opts.dir = s:dirpath(expand(opts.dir))

line 9:     endif

line 10:   else

line 11:     throw 'Invalid argument type (expected: string or dictionary)'

line 12:   endif

line 13:   return opts

function plug#[7]..<SNR>2_parse_options returning {'do': 'bash install.sh', 'frozen': 0, 'branch': 'next'}

continuing in function plug#

line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))

line 9:     let spec = extend(s:infer_properties(name, repo), opts)

calling function plug#[9]..<SNR>2_infer_properties('LanguageClient-neovim', 'autozimu/LanguageClient-neovim')

line 1:   let repo = a:repo

line 2:   if s:is_local_plug(repo)

calling function plug#[9]..<SNR>2_infer_properties[2]..<SNR>2_is_local_plug('autozimu/LanguageClient-neovim')

line 1:     return a:repo[0] =~ '[/$~]'

function plug#[9]..<SNR>2_infer_properties[2]..<SNR>2_is_local_plug returning #0

continuing in function plug#[9]..<SNR>2_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }

line 4:   else

line 5:     if repo =~ ':'

line 6:       let uri = repo

line 7:     else

line 8:       if repo !~ '/'

line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)

line 10:       endif

line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')

line 12:       let uri = printf(fmt, repo)

line 13:     endif

line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }

calling function plug#[9]..<SNR>2_infer_properties[14]..<SNR>2_dirpath('/home/reggiemarr/.vim/plugged/LanguageClient-neovim')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')

function plug#[9]..<SNR>2_infer_properties[14]..<SNR>2_dirpath returning '/home/reggiemarr/.vim/plugged/LanguageClient-neovim/'

continuing in function plug#[9]..<SNR>2_infer_properties

function plug#[9]..<SNR>2_infer_properties returning {'uri': 'https://git::@github.com/auto...r/.vim/plugged/LanguageClient-neovim/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)

line 11:       call add(g:plugs_order, name)

line 12:     endif

line 13:     let g:plugs[name] = spec

line 14:     let s:loaded[name] = get(s:loaded, name, 0)

line 15:   catch

line 16:     return s:err(v:exception)

line 17:   endtry

function plug# returning #0

continuing in /home/reggiemarr/.config/nvim/init.vim

line 15: 

line 16:     "

line 17:     "Assuming you're using vim-plug: https://github.com/junegunn/vim-plug

line 18:     Plug 'ncm2/ncm2'

line 18: call plug#('ncm2/ncm2')

calling function plug#('ncm2/ncm2')

line 1:   if a:0 > 1

line 2:     return s:err('Invalid number of arguments (1..2)')

line 3:   endif

line 4: 

line 5:   try

line 6:     let repo = s:trim(a:repo)

calling function plug#[6]..<SNR>2_trim('ncm2/ncm2')

line 1:   return substitute(a:str, '[\/]\+$', '', '')

function plug#[6]..<SNR>2_trim returning 'ncm2/ncm2'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec

line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))

line 9:     let spec = extend(s:infer_properties(name, repo), opts)

calling function plug#[9]..<SNR>2_infer_properties('ncm2', 'ncm2/ncm2')

line 1:   let repo = a:repo

line 2:   if s:is_local_plug(repo)

calling function plug#[9]..<SNR>2_infer_properties[2]..<SNR>2_is_local_plug('ncm2/ncm2')

line 1:     return a:repo[0] =~ '[/$~]'

function plug#[9]..<SNR>2_infer_properties[2]..<SNR>2_is_local_plug returning #0

continuing in function plug#[9]..<SNR>2_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }

line 4:   else

line 5:     if repo =~ ':'

line 6:       let uri = repo

line 7:     else

line 8:       if repo !~ '/'

line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)

line 10:       endif

line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')

line 12:       let uri = printf(fmt, repo)

line 13:     endif

line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }

calling function plug#[9]..<SNR>2_infer_properties[14]..<SNR>2_dirpath('/home/reggiemarr/.vim/plugged/ncm2')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')

function plug#[9]..<SNR>2_infer_properties[14]..<SNR>2_dirpath returning '/home/reggiemarr/.vim/plugged/ncm2/'

continuing in function plug#[9]..<SNR>2_infer_properties

function plug#[9]..<SNR>2_infer_properties returning {'uri': 'https://git::@github.com/ncm2... '/home/reggiemarr/.vim/plugged/ncm2/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)

line 11:       call add(g:plugs_order, name)

line 12:     endif

line 13:     let g:plugs[name] = spec

line 14:     let s:loaded[name] = get(s:loaded, name, 0)

line 15:   catch

line 16:     return s:err(v:exception)

line 17:   endtry

function plug# returning #0

continuing in /home/reggiemarr/.config/nvim/init.vim

line 19:     Plug 'roxma/nvim-yarp'

line 19: call plug#('roxma/nvim-yarp')

calling function plug#('roxma/nvim-yarp')

line 1:   if a:0 > 1

line 2:     return s:err('Invalid number of arguments (1..2)')

line 3:   endif

line 4: 

line 5:   try

line 6:     let repo = s:trim(a:repo)

calling function plug#[6]..<SNR>2_trim('roxma/nvim-yarp')

line 1:   return substitute(a:str, '[\/]\+$', '', '')

function plug#[6]..<SNR>2_trim returning 'roxma/nvim-yarp'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec

line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))

line 9:     let spec = extend(s:infer_properties(name, repo), opts)

calling function plug#[9]..<SNR>2_infer_properties('nvim-yarp', 'roxma/nvim-yarp')

line 1:   let repo = a:repo

line 2:   if s:is_local_plug(repo)

calling function plug#[9]..<SNR>2_infer_properties[2]..<SNR>2_is_local_plug('roxma/nvim-yarp')

line 1:     return a:repo[0] =~ '[/$~]'

function plug#[9]..<SNR>2_infer_properties[2]..<SNR>2_is_local_plug returning #0

continuing in function plug#[9]..<SNR>2_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }

line 4:   else

line 5:     if repo =~ ':'

line 6:       let uri = repo

line 7:     else

line 8:       if repo !~ '/'

line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)

line 10:       endif

line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')

line 12:       let uri = printf(fmt, repo)

line 13:     endif

line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }

calling function plug#[9]..<SNR>2_infer_properties[14]..<SNR>2_dirpath('/home/reggiemarr/.vim/plugged/nvim-yarp')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')

function plug#[9]..<SNR>2_infer_properties[14]..<SNR>2_dirpath returning '/home/reggiemarr/.vim/plugged/nvim-yarp/'

continuing in function plug#[9]..<SNR>2_infer_properties

function plug#[9]..<SNR>2_infer_properties returning {'uri': 'https://git::@github.com/roxm...me/reggiemarr/.vim/plugged/nvim-yarp/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)

line 11:       call add(g:plugs_order, name)

line 12:     endif

line 13:     let g:plugs[name] = spec

line 14:     let s:loaded[name] = get(s:loaded, name, 0)

line 15:   catch

line 16:     return s:err(v:exception)

line 17:   endtry

function plug# returning #0

continuing in /home/reggiemarr/.config/nvim/init.vim

line 20: 

line 21:     " enable ncm2 for all buffers

line 22:     autocmd BufEnter * call ncm2#enable_for_buffer()

line 23: 

line 24:     " IMPORTANT: :help Ncm2PopupOpen for more information

line 25:     set completeopt=noinsert,menuone,noselect

line 26: 

line 27:     " NOTE: you need to install completion sources to get completions. Check

line 28:     " our wiki page for a list of sources: https://github.com/ncm2/ncm2/wiki

line 29:     Plug 'ncm2/ncm2-bufword'

line 29: call plug#('ncm2/ncm2-bufword')

calling function plug#('ncm2/ncm2-bufword')

line 1:   if a:0 > 1

line 2:     return s:err('Invalid number of arguments (1..2)')

line 3:   endif

line 4: 

line 5:   try

line 6:     let repo = s:trim(a:repo)

calling function plug#[6]..<SNR>2_trim('ncm2/ncm2-bufword')

line 1:   return substitute(a:str, '[\/]\+$', '', '')

function plug#[6]..<SNR>2_trim returning 'ncm2/ncm2-bufword'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec

line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))

line 9:     let spec = extend(s:infer_properties(name, repo), opts)

calling function plug#[9]..<SNR>2_infer_properties('ncm2-bufword', 'ncm2/ncm2-bufword')

line 1:   let repo = a:repo

line 2:   if s:is_local_plug(repo)

calling function plug#[9]..<SNR>2_infer_properties[2]..<SNR>2_is_local_plug('ncm2/ncm2-bufword')

line 1:     return a:repo[0] =~ '[/$~]'

function plug#[9]..<SNR>2_infer_properties[2]..<SNR>2_is_local_plug returning #0

continuing in function plug#[9]..<SNR>2_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }

line 4:   else

line 5:     if repo =~ ':'

line 6:       let uri = repo

line 7:     else

line 8:       if repo !~ '/'

line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)

line 10:       endif

line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')

line 12:       let uri = printf(fmt, repo)

line 13:     endif

line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }

calling function plug#[9]..<SNR>2_infer_properties[14]..<SNR>2_dirpath('/home/reggiemarr/.vim/plugged/ncm2-bufword')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')

function plug#[9]..<SNR>2_infer_properties[14]..<SNR>2_dirpath returning '/home/reggiemarr/.vim/plugged/ncm2-bufword/'

continuing in function plug#[9]..<SNR>2_infer_properties

function plug#[9]..<SNR>2_infer_properties returning {'uri': 'https://git::@github.com/ncm2...reggiemarr/.vim/plugged/ncm2-bufword/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)

line 11:       call add(g:plugs_order, name)

line 12:     endif

line 13:     let g:plugs[name] = spec

line 14:     let s:loaded[name] = get(s:loaded, name, 0)

line 15:   catch

line 16:     return s:err(v:exception)

line 17:   endtry

function plug# returning #0

continuing in /home/reggiemarr/.config/nvim/init.vim

line 30:     Plug 'ncm2/ncm2-path'" (Optional) Multi-entry selection UI.

line 30: call plug#('ncm2/ncm2-path')

calling function plug#('ncm2/ncm2-path')

line 1:   if a:0 > 1

line 2:     return s:err('Invalid number of arguments (1..2)')

line 3:   endif

line 4: 

line 5:   try

line 6:     let repo = s:trim(a:repo)

calling function plug#[6]..<SNR>2_trim('ncm2/ncm2-path')

line 1:   return substitute(a:str, '[\/]\+$', '', '')

function plug#[6]..<SNR>2_trim returning 'ncm2/ncm2-path'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec

line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))

line 9:     let spec = extend(s:infer_properties(name, repo), opts)

calling function plug#[9]..<SNR>2_infer_properties('ncm2-path', 'ncm2/ncm2-path')

line 1:   let repo = a:repo

line 2:   if s:is_local_plug(repo)

calling function plug#[9]..<SNR>2_infer_properties[2]..<SNR>2_is_local_plug('ncm2/ncm2-path')

line 1:     return a:repo[0] =~ '[/$~]'

function plug#[9]..<SNR>2_infer_properties[2]..<SNR>2_is_local_plug returning #0

continuing in function plug#[9]..<SNR>2_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }

line 4:   else

line 5:     if repo =~ ':'

line 6:       let uri = repo

line 7:     else

line 8:       if repo !~ '/'

line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)

line 10:       endif

line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')

line 12:       let uri = printf(fmt, repo)

line 13:     endif

line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }

calling function plug#[9]..<SNR>2_infer_properties[14]..<SNR>2_dirpath('/home/reggiemarr/.vim/plugged/ncm2-path')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')

function plug#[9]..<SNR>2_infer_properties[14]..<SNR>2_dirpath returning '/home/reggiemarr/.vim/plugged/ncm2-path/'

continuing in function plug#[9]..<SNR>2_infer_properties

function plug#[9]..<SNR>2_infer_properties returning {'uri': 'https://git::@github.com/ncm2...me/reggiemarr/.vim/plugged/ncm2-path/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)

line 11:       call add(g:plugs_order, name)

line 12:     endif

line 13:     let g:plugs[name] = spec

line 14:     let s:loaded[name] = get(s:loaded, name, 0)

line 15:   catch

line 16:     return s:err(v:exception)

line 17:   endtry

function plug# returning #0

continuing in /home/reggiemarr/.config/nvim/init.vim

line 31:     Plug 'junegunn/fzf'

line 31: call plug#('junegunn/fzf')

calling function plug#('junegunn/fzf')

line 1:   if a:0 > 1

line 2:     return s:err('Invalid number of arguments (1..2)')

line 3:   endif

line 4: 

line 5:   try

line 6:     let repo = s:trim(a:repo)

calling function plug#[6]..<SNR>2_trim('junegunn/fzf')

line 1:   return substitute(a:str, '[\/]\+$', '', '')

function plug#[6]..<SNR>2_trim returning 'junegunn/fzf'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec

line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))

line 9:     let spec = extend(s:infer_properties(name, repo), opts)

calling function plug#[9]..<SNR>2_infer_properties('fzf', 'junegunn/fzf')

line 1:   let repo = a:repo

line 2:   if s:is_local_plug(repo)

calling function plug#[9]..<SNR>2_infer_properties[2]..<SNR>2_is_local_plug('junegunn/fzf')

line 1:     return a:repo[0] =~ '[/$~]'

function plug#[9]..<SNR>2_infer_properties[2]..<SNR>2_is_local_plug returning #0

continuing in function plug#[9]..<SNR>2_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }

line 4:   else

line 5:     if repo =~ ':'

line 6:       let uri = repo

line 7:     else

line 8:       if repo !~ '/'

line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)

line 10:       endif

line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')

line 12:       let uri = printf(fmt, repo)

line 13:     endif

line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }

calling function plug#[9]..<SNR>2_infer_properties[14]..<SNR>2_dirpath('/home/reggiemarr/.vim/plugged/fzf')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')

function plug#[9]..<SNR>2_infer_properties[14]..<SNR>2_dirpath returning '/home/reggiemarr/.vim/plugged/fzf/'

continuing in function plug#[9]..<SNR>2_infer_properties

function plug#[9]..<SNR>2_infer_properties returning {'uri': 'https://git::@github.com/june...: '/home/reggiemarr/.vim/plugged/fzf/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)

line 11:       call add(g:plugs_order, name)

line 12:     endif

line 13:     let g:plugs[name] = spec

line 14:     let s:loaded[name] = get(s:loaded, name, 0)

line 15:   catch

line 16:     return s:err(v:exception)

line 17:   endtry

function plug# returning #0

continuing in /home/reggiemarr/.config/nvim/init.vim

line 32:     "Plug 'SirVer/ultisnips'

line 33:     "Plug 'honza/vim-snippets'

line 34:     "Plug 'Shougo/deoplete.nvim', { 'do': ':UpdateRemotePlugins' }

line 35:     Plug 'scrooloose/nerdcommenter'

line 35: call plug#('scrooloose/nerdcommenter')

calling function plug#('scrooloose/nerdcommenter')

line 1:   if a:0 > 1

line 2:     return s:err('Invalid number of arguments (1..2)')

line 3:   endif

line 4: 

line 5:   try

line 6:     let repo = s:trim(a:repo)

calling function plug#[6]..<SNR>2_trim('scrooloose/nerdcommenter')

line 1:   return substitute(a:str, '[\/]\+$', '', '')

function plug#[6]..<SNR>2_trim returning 'scrooloose/nerdcommenter'

continuing in function plug#

line 7:     let opts = a:0 == 1 ? s:parse_options(a:1) : s:base_spec

line 8:     let name = get(opts, 'as', fnamemodify(repo, ':t:s?\.git$??'))

line 9:     let spec = extend(s:infer_properties(name, repo), opts)

calling function plug#[9]..<SNR>2_infer_properties('nerdcommenter', 'scrooloose/nerdcommenter')

line 1:   let repo = a:repo

line 2:   if s:is_local_plug(repo)

calling function plug#[9]..<SNR>2_infer_properties[2]..<SNR>2_is_local_plug('scrooloose/nerdcommenter')

line 1:     return a:repo[0] =~ '[/$~]'

function plug#[9]..<SNR>2_infer_properties[2]..<SNR>2_is_local_plug returning #0

continuing in function plug#[9]..<SNR>2_infer_properties

line 3:     return { 'dir': s:dirpath(expand(repo)) }

line 4:   else

line 5:     if repo =~ ':'

line 6:       let uri = repo

line 7:     else

line 8:       if repo !~ '/'

line 9:         throw printf('Invalid argument: %s (implicit `vim-scripts'' expansion is deprecated)', repo)

line 10:       endif

line 11:       let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git')

line 12:       let uri = printf(fmt, repo)

line 13:     endif

line 14:     return { 'dir': s:dirpath(g:plug_home.'/'.a:name), 'uri': uri }

calling function plug#[9]..<SNR>2_infer_properties[14]..<SNR>2_dirpath('/home/reggiemarr/.vim/plugged/nerdcommenter')

line 1:     return substitute(a:path, '[/\\]*$', '/', '')

function plug#[9]..<SNR>2_infer_properties[14]..<SNR>2_dirpath returning '/home/reggiemarr/.vim/plugged/nerdcommenter/'

continuing in function plug#[9]..<SNR>2_infer_properties

function plug#[9]..<SNR>2_infer_properties returning {'uri': 'https://git::@github.com/scro...eggiemarr/.vim/plugged/nerdcommenter/'}

continuing in function plug#

line 10:     if !has_key(g:plugs, name)

line 11:       call add(g:plugs_order, name)

line 12:     endif

line 13:     let g:plugs[name] = spec

line 14:     let s:loaded[name] = get(s:loaded, name, 0)

line 15:   catch

line 16:     return s:err(v:exception)

line 17:   endtry

function plug# returning #0

continuing in /home/reggiemarr/.config/nvim/init.vim

line 36: call plug#end()

calling function plug#end()

line 1:   if !exists('g:plugs')

line 2:     return s:err('Call plug#begin() first')

line 3:   endif

line 4: 

line 5:   if exists('#PlugLOD')

line 6:     augroup PlugLOD

line 7:       autocmd!

line 8:     augroup END

line 9:     augroup! PlugLOD

line 10:   endif

line 11:   let lod = { 'ft': {}, 'map': {}, 'cmd': {} }

line 12: 

line 13:   if exists('g:did_load_filetypes')

line 14:     filetype off

line 15:   endif

line 16:   for name in g:plugs_order

line 17:     if !has_key(g:plugs, name)

line 18:       continue

line 19:     endif

line 20:     let plug = g:plugs[name]

line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')

calling function plug#end[21]..<SNR>2_lazy({'uri': 'https://git::@github.com/auto...anch': 'next', 'do': 'bash install.sh'}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))

function plug#end[21]..<SNR>2_lazy returning #0

continuing in function plug#end

calling function plug#end[21]..<SNR>2_lazy({'uri': 'https://git::@github.com/auto...anch': 'next', 'do': 'bash install.sh'}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))

function plug#end[21]..<SNR>2_lazy returning #0

continuing in function plug#end

line 22:       let s:loaded[name] = 1

line 23:       continue

line 16:   for name in g:plugs_order

line 17:     if !has_key(g:plugs, name)

line 18:       continue

line 19:     endif

line 20:     let plug = g:plugs[name]

line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')

calling function plug#end[21]..<SNR>2_lazy({'uri': 'https://git::@github.com/ncm2...cm2/', 'frozen': 0, 'branch': 'master'}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))

function plug#end[21]..<SNR>2_lazy returning #0

continuing in function plug#end

calling function plug#end[21]..<SNR>2_lazy({'uri': 'https://git::@github.com/ncm2...cm2/', 'frozen': 0, 'branch': 'master'}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))

function plug#end[21]..<SNR>2_lazy returning #0

continuing in function plug#end

line 22:       let s:loaded[name] = 1

line 23:       continue

line 16:   for name in g:plugs_order

line 17:     if !has_key(g:plugs, name)

line 18:       continue

line 19:     endif

line 20:     let plug = g:plugs[name]

line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')

calling function plug#end[21]..<SNR>2_lazy({'uri': 'https://git::@github.com/roxm...arp/', 'frozen': 0, 'branch': 'master'}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))

function plug#end[21]..<SNR>2_lazy returning #0

continuing in function plug#end

calling function plug#end[21]..<SNR>2_lazy({'uri': 'https://git::@github.com/roxm...arp/', 'frozen': 0, 'branch': 'master'}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))

function plug#end[21]..<SNR>2_lazy returning #0

continuing in function plug#end

line 22:       let s:loaded[name] = 1

line 23:       continue

line 16:   for name in g:plugs_order

line 17:     if !has_key(g:plugs, name)

line 18:       continue

line 19:     endif

line 20:     let plug = g:plugs[name]

line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')

calling function plug#end[21]..<SNR>2_lazy({'uri': 'https://git::@github.com/ncm2...ord/', 'frozen': 0, 'branch': 'master'}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))

function plug#end[21]..<SNR>2_lazy returning #0

continuing in function plug#end

calling function plug#end[21]..<SNR>2_lazy({'uri': 'https://git::@github.com/ncm2...ord/', 'frozen': 0, 'branch': 'master'}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))

function plug#end[21]..<SNR>2_lazy returning #0

continuing in function plug#end

line 22:       let s:loaded[name] = 1

line 23:       continue

line 16:   for name in g:plugs_order

line 17:     if !has_key(g:plugs, name)

line 18:       continue

line 19:     endif

line 20:     let plug = g:plugs[name]

line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')

calling function plug#end[21]..<SNR>2_lazy({'uri': 'https://git::@github.com/ncm2...ath/', 'frozen': 0, 'branch': 'master'}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))

function plug#end[21]..<SNR>2_lazy returning #0

continuing in function plug#end

calling function plug#end[21]..<SNR>2_lazy({'uri': 'https://git::@github.com/ncm2...ath/', 'frozen': 0, 'branch': 'master'}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))

function plug#end[21]..<SNR>2_lazy returning #0

continuing in function plug#end

line 22:       let s:loaded[name] = 1

line 23:       continue

line 16:   for name in g:plugs_order

line 17:     if !has_key(g:plugs, name)

line 18:       continue

line 19:     endif

line 20:     let plug = g:plugs[name]

line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')

calling function plug#end[21]..<SNR>2_lazy({'uri': 'https://git::@github.com/june...fzf/', 'frozen': 0, 'branch': 'master'}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))

function plug#end[21]..<SNR>2_lazy returning #0

continuing in function plug#end

calling function plug#end[21]..<SNR>2_lazy({'uri': 'https://git::@github.com/june...fzf/', 'frozen': 0, 'branch': 'master'}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))

function plug#end[21]..<SNR>2_lazy returning #0

continuing in function plug#end

line 22:       let s:loaded[name] = 1

line 23:       continue

line 16:   for name in g:plugs_order

line 17:     if !has_key(g:plugs, name)

line 18:       continue

line 19:     endif

line 20:     let plug = g:plugs[name]

line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')

calling function plug#end[21]..<SNR>2_lazy({'uri': 'https://git::@github.com/scro...ter/', 'frozen': 0, 'branch': 'master'}, 'on')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))

function plug#end[21]..<SNR>2_lazy returning #0

continuing in function plug#end

calling function plug#end[21]..<SNR>2_lazy({'uri': 'https://git::@github.com/scro...ter/', 'frozen': 0, 'branch': 'master'}, 'for')

line 1:   return has_key(a:plug, a:opt) && (empty(s:to_a(a:plug[a:opt]))         ||  !isdirectory(a:plug.dir)             ||  len(s:glob(s:rtp(a:plug), 'plugin')) ||  len(s:glob(s:rtp(a:plug), 'after/plugin')))

function plug#end[21]..<SNR>2_lazy returning #0

continuing in function plug#end

line 22:       let s:loaded[name] = 1

line 23:       continue

line 16:   for name in g:plugs_order

line 17:     if !has_key(g:plugs, name)

line 18:       continue

line 19:     endif

line 20:     let plug = g:plugs[name]

line 21:     if get(s:loaded, name, 0) || !s:lazy(plug, 'on') && !s:lazy(plug, 'for')

line 22:       let s:loaded[name] = 1

line 23:       continue

line 24:     endif

line 25: 

line 26:     if has_key(plug, 'on')

line 27:       let s:triggers[name] = { 'map': [], 'cmd': [] }

line 28:       for cmd in s:to_a(plug.on)

line 29:         if cmd =~? '^<Plug>.\+'

line 30:           if empty(mapcheck(cmd)) && empty(mapcheck(cmd, 'i'))

line 31:             call s:assoc(lod.map, cmd, name)

line 32:           endif

line 33:           call add(s:triggers[name].map, cmd)

line 34:         elseif cmd =~# '^[A-Z]'

line 35:           let cmd = substitute(cmd, '!*$', '', '')

line 36:           if exists(':'.cmd) != 2

line 37:             call s:assoc(lod.cmd, cmd, name)

line 38:           endif

line 39:           call add(s:triggers[name].cmd, cmd)

line 40:         else

line 41:           call s:err('Invalid `on` option: '.cmd. '. Should start with an uppercase letter or `<Plug>`.')

line 43:         endif

line 44:       endfor

line 45:     endif

line 46: 

line 47:     if has_key(plug, 'for')

line 48:       let types = s:to_a(plug.for)

line 49:       if !empty(types)

line 50:         augroup filetypedetect

line 51:         call s:source(s:rtp(plug), 'ftdetect/**/*.vim', 'after/ftdetect/**/*.vim')

line 52:         augroup END

line 53:       endif

line 54:       for type in types

line 55:         call s:assoc(lod.ft, type, name)

line 56:       endfor

line 57:     endif

line 58:   endfor

line 59: 

line 60:   for [cmd, names] in items(lod.cmd)

line 61:     execute printf( 'command! -nargs=* -range -bang -complete=file %s call s:lod_cmd(%s, "<bang>", <line1>, <line2>, <q-args>, %s)', cmd, string(cmd), string(names))

line 64:   endfor

line 65: 

line 66:   for [map, names] in items(lod.map)

line 67:     for [mode, map_prefix, key_prefix] in [['i', '<C-O>', ''], ['n', '', ''], ['v', '', 'gv'], ['o', '', '']]

line 69:       execute printf( '%snoremap <silent> %s %s:<C-U>call <SID>lod_map(%s, %s, %s, "%s")<CR>', mode, map, map_prefix, string(map), string(names), mode != 'i', key_prefix)

line 72:     endfor

line 73:   endfor

line 74: 

line 75:   for [ft, names] in items(lod.ft)

line 76:     augroup PlugLOD

line 77:       execute printf('autocmd FileType %s call <SID>lod_ft(%s, %s)', ft, string(ft), string(names))

line 79:     augroup END

line 80:   endfor

line 81: 

line 82:   call s:reorg_rtp()

calling function plug#end[82]..<SNR>2_reorg_rtp()

line 1:   if !empty(s:first_rtp)

line 2:     execute 'set rtp-='.s:first_rtp

line 2: set rtp-=/home/reggiemarr/.config/nvim

line 3:     execute 'set rtp-='.s:last_rtp

line 3: set rtp-=/home/reggiemarr/.config/nvim/after

line 4:   endif

line 5: 

line 6:   " &rtp is modified from outside

line 7:   if exists('s:prtp') && s:prtp !=# &rtp

line 8:     call s:remove_rtp()

line 9:     unlet! s:middle

line 10:   endif

line 11: 

line 12:   let s:middle = get(s:, 'middle', &rtp)

line 13:   let rtps     = map(s:loaded_names(), 's:rtp(g:plugs[v:val])')

calling function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_loaded_names()

line 1:   return filter(copy(g:plugs_order), 'get(s:loaded, v:val, 0)')

function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_loaded_names returning ['LanguageClient-neovim', 'ncm2', 'nvi...', 'ncm2-path', 'fzf', 'nerdcommenter']

continuing in function plug#end[82]..<SNR>2_reorg_rtp

calling function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp({'uri': 'https://git::@github.com/auto...anch': 'next', 'do': 'bash install.sh'})

line 1:   return s:path(a:spec.dir . get(a:spec, 'rtp', ''))

calling function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path('/home/reggiemarr/.vim/plugged/LanguageClient-neovim/')

line 1:     return s:trim(a:path)

calling function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path[1]..<SNR>2_trim('/home/reggiemarr/.vim/plugged/LanguageClient-neovim/')

line 1:   return substitute(a:str, '[\/]\+$', '', '')

function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path[1]..<SNR>2_trim returning '/home/reggiemarr/.vim/plugged/LanguageClient-neovim'

continuing in function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path

function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path returning '/home/reggiemarr/.vim/plugged/LanguageClient-neovim'

continuing in function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp

function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp returning '/home/reggiemarr/.vim/plugged/LanguageClient-neovim'

continuing in function plug#end[82]..<SNR>2_reorg_rtp

calling function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp({'uri': 'https://git::@github.com/ncm2...cm2/', 'frozen': 0, 'branch': 'master'})

line 1:   return s:path(a:spec.dir . get(a:spec, 'rtp', ''))

calling function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path('/home/reggiemarr/.vim/plugged/ncm2/')

line 1:     return s:trim(a:path)

calling function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path[1]..<SNR>2_trim('/home/reggiemarr/.vim/plugged/ncm2/')

line 1:   return substitute(a:str, '[\/]\+$', '', '')

function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path[1]..<SNR>2_trim returning '/home/reggiemarr/.vim/plugged/ncm2'

continuing in function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path

function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path returning '/home/reggiemarr/.vim/plugged/ncm2'

continuing in function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp

function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp returning '/home/reggiemarr/.vim/plugged/ncm2'

continuing in function plug#end[82]..<SNR>2_reorg_rtp

calling function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp({'uri': 'https://git::@github.com/roxm...arp/', 'frozen': 0, 'branch': 'master'})

line 1:   return s:path(a:spec.dir . get(a:spec, 'rtp', ''))

calling function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path('/home/reggiemarr/.vim/plugged/nvim-yarp/')

line 1:     return s:trim(a:path)

calling function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path[1]..<SNR>2_trim('/home/reggiemarr/.vim/plugged/nvim-yarp/')

line 1:   return substitute(a:str, '[\/]\+$', '', '')

function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path[1]..<SNR>2_trim returning '/home/reggiemarr/.vim/plugged/nvim-yarp'

continuing in function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path

function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path returning '/home/reggiemarr/.vim/plugged/nvim-yarp'

continuing in function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp

function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp returning '/home/reggiemarr/.vim/plugged/nvim-yarp'

continuing in function plug#end[82]..<SNR>2_reorg_rtp

calling function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp({'uri': 'https://git::@github.com/ncm2...ord/', 'frozen': 0, 'branch': 'master'})

line 1:   return s:path(a:spec.dir . get(a:spec, 'rtp', ''))

calling function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path('/home/reggiemarr/.vim/plugged/ncm2-bufword/')

line 1:     return s:trim(a:path)

calling function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path[1]..<SNR>2_trim('/home/reggiemarr/.vim/plugged/ncm2-bufword/')

line 1:   return substitute(a:str, '[\/]\+$', '', '')

function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path[1]..<SNR>2_trim returning '/home/reggiemarr/.vim/plugged/ncm2-bufword'

continuing in function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path

function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path returning '/home/reggiemarr/.vim/plugged/ncm2-bufword'

continuing in function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp

function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp returning '/home/reggiemarr/.vim/plugged/ncm2-bufword'

continuing in function plug#end[82]..<SNR>2_reorg_rtp

calling function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp({'uri': 'https://git::@github.com/ncm2...ath/', 'frozen': 0, 'branch': 'master'})

line 1:   return s:path(a:spec.dir . get(a:spec, 'rtp', ''))

calling function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path('/home/reggiemarr/.vim/plugged/ncm2-path/')

line 1:     return s:trim(a:path)

calling function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path[1]..<SNR>2_trim('/home/reggiemarr/.vim/plugged/ncm2-path/')

line 1:   return substitute(a:str, '[\/]\+$', '', '')

function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path[1]..<SNR>2_trim returning '/home/reggiemarr/.vim/plugged/ncm2-path'

continuing in function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path

function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path returning '/home/reggiemarr/.vim/plugged/ncm2-path'

continuing in function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp

function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp returning '/home/reggiemarr/.vim/plugged/ncm2-path'

continuing in function plug#end[82]..<SNR>2_reorg_rtp

calling function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp({'uri': 'https://git::@github.com/june...fzf/', 'frozen': 0, 'branch': 'master'})

line 1:   return s:path(a:spec.dir . get(a:spec, 'rtp', ''))

calling function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path('/home/reggiemarr/.vim/plugged/fzf/')

line 1:     return s:trim(a:path)

calling function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path[1]..<SNR>2_trim('/home/reggiemarr/.vim/plugged/fzf/')

line 1:   return substitute(a:str, '[\/]\+$', '', '')

function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path[1]..<SNR>2_trim returning '/home/reggiemarr/.vim/plugged/fzf'

continuing in function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path

function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path returning '/home/reggiemarr/.vim/plugged/fzf'

continuing in function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp

function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp returning '/home/reggiemarr/.vim/plugged/fzf'

continuing in function plug#end[82]..<SNR>2_reorg_rtp

calling function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp({'uri': 'https://git::@github.com/scro...ter/', 'frozen': 0, 'branch': 'master'})

line 1:   return s:path(a:spec.dir . get(a:spec, 'rtp', ''))

calling function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path('/home/reggiemarr/.vim/plugged/nerdcommenter/')

line 1:     return s:trim(a:path)

calling function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path[1]..<SNR>2_trim('/home/reggiemarr/.vim/plugged/nerdcommenter/')

line 1:   return substitute(a:str, '[\/]\+$', '', '')

function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path[1]..<SNR>2_trim returning '/home/reggiemarr/.vim/plugged/nerdcommenter'

continuing in function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path

function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp[1]..<SNR>2_path returning '/home/reggiemarr/.vim/plugged/nerdcommenter'

continuing in function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp

function plug#end[82]..<SNR>2_reorg_rtp[13]..<SNR>2_rtp returning '/home/reggiemarr/.vim/plugged/nerdcommenter'

continuing in function plug#end[82]..<SNR>2_reorg_rtp

line 14:   let afters   = filter(map(copy(rtps), 'globpath(v:val, "after")'), '!empty(v:val)')

line 15:   let rtp      = join(map(rtps, 'escape(v:val, ",")'), ',') . ','.s:middle.',' . join(map(afters, 'escape(v:val, ",")'), ',')

line 18:   let &rtp     = substitute(substitute(rtp, ',,*', ',', 'g'), '^,\|,$', '', 'g')

line 19:   let s:prtp   = &rtp

line 20: 

line 21:   if !empty(s:first_rtp)

line 22:     execute 'set rtp^='.s:first_rtp

line 22: set rtp^=/home/reggiemarr/.config/nvim

line 23:     execute 'set rtp+='.s:last_rtp

line 23: set rtp+=/home/reggiemarr/.config/nvim/after

line 24:   endif

function plug#end[82]..<SNR>2_reorg_rtp returning #0

continuing in function plug#end

line 83:   filetype plugin indent on

Searching for "filetype.vim" in "/home/reggiemarr/.config/nvim,/home/reggiemarr/.vim/plugged/LanguageClient-neovim,/home/reggiemarr/.vim/plugged/ncm2,/home/reggiemarr/.vim/plugged/nvim-yarp,/home/reggiemarr/.vim/plugged/ncm2-bufword,/home/reggiemarr/.vim/plugged/ncm2-path,/home/reggiemarr/.vim/plugged/fzf,/home/reggiemarr/.vim/plugged/nerdcommenter,/etc/xdg/xdg-i3/nvim,/etc/xdg/nvim,/home/reggiemarr/.local/share/nvim/site,/usr/share/i3/nvim/site,/usr/local/share/nvim/site,/usr/share/nvim/site,/var/lib/snapd/desktop/nvim/site,/usr/share/nvim/runtime,/var/lib/snapd/desktop/nvim/site/after,/usr/share/nvim/site/after,/usr/local/share/nvim/site/after,/usr/share/i3/nvim/site/after,/home/reggiemarr/.local/share/nvim/site/after,/etc/xdg/nvim/after,/etc/xdg/xdg-i3/nvim/after,/home/reggiemarr/.config/nvim/after"
Searching for "/home/reggiemarr/.config/nvim/filetype.vim"
Searching for "/home/reggiemarr/.vim/plugged/LanguageClient-neovim/filetype.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2/filetype.vim"
Searching for "/home/reggiemarr/.vim/plugged/nvim-yarp/filetype.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2-bufword/filetype.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2-path/filetype.vim"
Searching for "/home/reggiemarr/.vim/plugged/fzf/filetype.vim"
Searching for "/home/reggiemarr/.vim/plugged/nerdcommenter/filetype.vim"
Searching for "/etc/xdg/xdg-i3/nvim/filetype.vim"
Searching for "/etc/xdg/nvim/filetype.vim"
Searching for "/home/reggiemarr/.local/share/nvim/site/filetype.vim"
Searching for "/usr/share/i3/nvim/site/filetype.vim"
Searching for "/usr/local/share/nvim/site/filetype.vim"
Searching for "/usr/share/nvim/site/filetype.vim"
Searching for "/var/lib/snapd/desktop/nvim/site/filetype.vim"
Searching for "/usr/share/nvim/runtime/filetype.vim"
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/usr/share/nvim/runtime)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
line 83: sourcing "/usr/share/nvim/runtime/filetype.vim"
line 1: " Vim support file to detect file types

line 2: "

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>

line 4: " Last Change:^I2018 Feb 14

line 5: 

line 6: " Listen very carefully, I will say this only once

line 7: if exists("did_load_filetypes")

line 8:   finish

line 9: endif

line 10: let did_load_filetypes = 1

line 11: 

line 12: " Line continuation is used here, remove 'C' from 'cpoptions'

line 13: let s:cpo_save = &cpo

line 14: set cpo&vim

line 15: 

line 16: augroup filetypedetect

line 17: 

line 18: " Ignored extensions

line 19: if exists("*fnameescape")

line 21: au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew,?\+.pacsave,?\+.pacnew exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))

line 28: au BufNewFile,BufRead *~ let s:name = expand("<afile>") | let s:short = substitute(s:name, '\~$', '', '') | if s:name != s:short && s:short != "" |   exe "doau filetypedetect BufRead " . fnameescape(s:short) | endif | unlet! s:name s:short

line 32: au BufNewFile,BufRead ?\+.in if expand("<afile>:t") != "configure.in" |   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) | endif

line 33: elseif &verbose > 0

line 34:   echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"

line 35: endif

line 36: 

line 37: " Pattern used to match file names which should not be inspected.

line 38: " Currently finds compressed files.

line 39: if !exists("g:ft_ignore_pat")

line 40:   let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'

line 41: endif

line 42: 

line 43: " Function used for patterns that end in a star: don't set the filetype if the

line 44: " file name matches ft_ignore_pat.

line 45: func! s:StarSetf(ft)

line 50: 

line 51: " Vim help file

line 52: au BufNewFile,BufRead $VIMRUNTIME/doc/*.txt setf help

line 53: 

line 54: " Abaqus or Trasys

line 55: au BufNewFile,BufRead *.inp^I^I^Icall dist#ft#Check_inp()

line 56: 

line 57: " A-A-P recipe

line 58: au BufNewFile,BufRead *.aap^I^I^Isetf aap

line 59: 

line 60: " A2ps printing utility

line 61: au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps

line 62: 

line 63: " ABAB/4

line 64: au BufNewFile,BufRead *.abap^I^I^Isetf abap

line 65: 

line 66: " ABC music notation

line 67: au BufNewFile,BufRead *.abc^I^I^Isetf abc

line 68: 

line 69: " ABEL

line 70: au BufNewFile,BufRead *.abl^I^I^Isetf abel

line 71: 

line 72: " AceDB

line 73: au BufNewFile,BufRead *.wrm^I^I^Isetf acedb

line 74: 

line 75: " Ada (83, 9X, 95)

line 76: au BufNewFile,BufRead *.adb,*.ads,*.ada^I^Isetf ada

line 77: au BufNewFile,BufRead *.gpr^I^I^Isetf ada

line 78: 

line 79: " AHDL

line 80: au BufNewFile,BufRead *.tdf^I^I^Isetf ahdl

line 81: 

line 82: " AMPL

line 83: au BufNewFile,BufRead *.run^I^I^Isetf ampl

line 84: 

line 85: " Ant

line 86: au BufNewFile,BufRead build.xml^I^I^Isetf ant

line 87: 

line 88: " Arduino

line 89: au BufNewFile,BufRead *.ino,*.pde^I^Isetf arduino

line 90: 

line 91: " Apache style config file

line 92: au BufNewFile,BufRead proftpd.conf*^I^Icall s:StarSetf('apachestyle')

line 93: 

line 94: " Apache config file

line 95: au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf^I^Isetf apache

line 96: 

line 97: " XA65 MOS6510 cross assembler

line 98: au BufNewFile,BufRead *.a65^I^I^Isetf a65

line 99: 

line 100: " Applescript

line 101: au BufNewFile,BufRead *.scpt^I^I^Isetf applescript

line 102: 

line 103: " Applix ELF

line 105: au BufNewFile,BufRead *.am if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif

line 106: 

line 107: " ALSA configuration

line 108: au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf

line 109: 

line 110: " Arc Macro Language

line 111: au BufNewFile,BufRead *.aml^I^I^Isetf aml

line 112: 

line 113: " APT config file

line 114: au BufNewFile,BufRead apt.conf^I^I       setf aptconf

line 115: au BufNewFile,BufRead */.aptitude/config       setf aptconf

line 116: au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} setf aptconf

line 117: 

line 118: " Arch Inventory file

line 119: au BufNewFile,BufRead .arch-inventory,=tagging-method^Isetf arch

line 120: 

line 121: " ART*Enterprise (formerly ART-IM)

line 122: au BufNewFile,BufRead *.art^I^I^Isetf art

line 123: 

line 124: " AsciiDoc

line 125: au BufNewFile,BufRead *.asciidoc,*.adoc^I^Isetf asciidoc

line 126: 

line 127: " ASN.1

line 128: au BufNewFile,BufRead *.asn,*.asn1^I^Isetf asn

line 129: 

line 130: " Active Server Pages (with Visual Basic Script)

line 136: au BufNewFile,BufRead *.asa if exists("g:filetype_asa") |   exe "setf " . g:filetype_asa | else |   setf aspvbs | endif

line 137: 

line 138: " Active Server Pages (with Perl or Visual Basic Script)

line 146: au BufNewFile,BufRead *.asp if exists("g:filetype_asp") |   exe "setf " . g:filetype_asp | elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |   setf aspperl | else |   setf aspvbs | endif

line 147: 

line 148: " Grub (must be before catch *.lst)

line 149: au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub

line 150: 

line 151: " Assembly (all kinds)

line 152: " *.lst is not pure assembly, it has two extra columns (address, byte codes)

line 153: au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst^Icall dist#ft#FTasm()

line 154: 

line 155: " Macro (VAX)

line 156: au BufNewFile,BufRead *.mar^I^I^Isetf vmasm

line 157: 

line 158: " Atlas

line 159: au BufNewFile,BufRead *.atl,*.as^I^Isetf atlas

line 160: 

line 161: " Autoit v3

line 162: au BufNewFile,BufRead *.au3^I^I^Isetf autoit

line 163: 

line 164: " Autohotkey

line 165: au BufNewFile,BufRead *.ahk^I^I^Isetf autohotkey

line 166: 

line 167: " Automake

line 168: au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am^Isetf automake

line 169: 

line 170: " Autotest .at files are actually m4

line 171: au BufNewFile,BufRead *.at^I^I^Isetf m4

line 172: 

line 173: " Avenue

line 174: au BufNewFile,BufRead *.ave^I^I^Isetf ave

line 175: 

line 176: " Awk

line 177: au BufNewFile,BufRead *.awk^I^I^Isetf awk

line 178: 

line 179: " B

line 180: au BufNewFile,BufRead *.mch,*.ref,*.imp^I^Isetf b

line 181: 

line 182: " BASIC or Visual Basic

line 183: au BufNewFile,BufRead *.bas^I^I^Icall dist#ft#FTVB("basic")

line 184: 

line 185: " Visual Basic Script (close to Visual Basic) or Visual Basic .NET

line 186: au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl^Isetf vb

line 187: 

line 188: " IBasic file (similar to QBasic)

line 189: au BufNewFile,BufRead *.iba,*.ibi^I^Isetf ibasic

line 190: 

line 191: " FreeBasic file (similar to QBasic)

line 192: au BufNewFile,BufRead *.fb,*.bi^I^I^Isetf freebasic

line 193: 

line 194: " Batch file for MSDOS.

line 195: au BufNewFile,BufRead *.bat,*.sys^I^Isetf dosbatch

line 196: " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.

line 198: au BufNewFile,BufRead *.cmd if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif

line 199: 

line 200: " Batch file for 4DOS

line 201: au BufNewFile,BufRead *.btm^I^I^Icall dist#ft#FTbtm()

line 202: 

line 203: " BC calculator

line 204: au BufNewFile,BufRead *.bc^I^I^Isetf bc

line 205: 

line 206: " BDF font

line 207: au BufNewFile,BufRead *.bdf^I^I^Isetf bdf

line 208: 

line 209: " BibTeX bibliography database file

line 210: au BufNewFile,BufRead *.bib^I^I^Isetf bib

line 211: 

line 212: " BibTeX Bibliography Style

line 213: au BufNewFile,BufRead *.bst^I^I^Isetf bst

line 214: 

line 215: " BIND configuration

line 216: " sudoedit uses namedXXXX.conf

line 217: au BufNewFile,BufRead named*.conf,rndc*.conf,rndc*.key^Isetf named

line 218: 

line 219: " BIND zone

line 220: au BufNewFile,BufRead named.root^I^Isetf bindzone

line 221: au BufNewFile,BufRead *.db^I^I^Icall dist#ft#BindzoneCheck('')

line 222: 

line 223: " Blank

line 224: au BufNewFile,BufRead *.bl^I^I^Isetf blank

line 225: 

line 226: " Blkid cache file

line 227: au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml

line 228: 

line 229: " Bazel (http://bazel.io)

line 230: autocmd BufRead,BufNewFile *.bzl,WORKSPACE,BUILD.bazel ^Isetf bzl

line 231: if has("fname_case")

line 232:   " There is another check for BUILD further below.

line 233:   autocmd BufRead,BufNewFile BUILD^I^I^Isetf bzl

line 234: endif

line 235: 

line 236: " C or lpc

line 237: au BufNewFile,BufRead *.c^I^I^Icall dist#ft#FTlpc()

line 238: au BufNewFile,BufRead *.lpc,*.ulpc^I^Isetf lpc

line 239: 

line 240: " Calendar

line 241: au BufNewFile,BufRead calendar^I^I^Isetf calendar

line 242: 

line 243: " C#

line 244: au BufNewFile,BufRead *.cs^I^I^Isetf cs

line 245: 

line 246: " CSDL

line 247: au BufNewFile,BufRead *.csdl^I^I^Isetf csdl

line 248: 

line 249: " Cabal

line 250: au BufNewFile,BufRead *.cabal^I^I^Isetf cabal

line 251: 

line 252: " Cdrdao TOC

line 253: au BufNewFile,BufRead *.toc^I^I^Isetf cdrtoc

line 254: 

line 255: " Cdrdao config

line 256: au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao^Isetf cdrdaoconf

line 257: 

line 258: " Cfengine

line 259: au BufNewFile,BufRead cfengine.conf^I^Isetf cfengine

line 260: 

line 261: " ChaiScript

line 262: au BufRead,BufNewFile *.chai^I^I^Isetf chaiscript

line 263: 

line 264: " Comshare Dimension Definition Language

line 265: au BufNewFile,BufRead *.cdl^I^I^Isetf cdl

line 266: 

line 267: " Conary Recipe

line 268: au BufNewFile,BufRead *.recipe^I^I^Isetf conaryrecipe

line 269: 

line 270: " Controllable Regex Mutilator

line 271: au BufNewFile,BufRead *.crm^I^I^Isetf crm

line 272: 

line 273: " Cyn++

line 274: au BufNewFile,BufRead *.cyn^I^I^Isetf cynpp

line 275: 

line 276: " Cynlib

line 277: " .cc and .cpp files can be C++ or Cynlib.

line 279: au BufNewFile,BufRead *.cc if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif

line 281: au BufNewFile,BufRead *.cpp if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif

line 282: 

line 283: " C++

line 284: au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp

line 285: if has("fname_case")

line 286:   au BufNewFile,BufRead *.C,*.H setf cpp

line 287: endif

line 288: 

line 289: " .h files can be C, Ch C++, ObjC or ObjC++.

line 290: " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is

line 291: " detected automatically.

line 292: au BufNewFile,BufRead *.h^I^I^Icall dist#ft#FTheader()

line 293: 

line 294: " Ch (CHscript)

line 295: au BufNewFile,BufRead *.chf^I^I^Isetf ch

line 296: 

line 297: " TLH files are C++ headers generated by Visual C++'s #import from typelibs

line 298: au BufNewFile,BufRead *.tlh^I^I^Isetf cpp

line 299: 

line 300: " Cascading Style Sheets

line 301: au BufNewFile,BufRead *.css^I^I^Isetf css

line 302: 

line 303: " Century Term Command Scripts (*.cmd too)

line 304: au BufNewFile,BufRead *.con^I^I^Isetf cterm

line 305: 

line 306: " Changelog

line 308: au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch^Isetf debchangelog

line 309: 

line 315: au BufNewFile,BufRead [cC]hange[lL]og  if getline(1) =~ '; urgency='|   setf debchangelog| else|   setf changelog| endif

line 316: 

line 320: au BufNewFile,BufRead NEWS  if getline(1) =~ '; urgency='|   setf debchangelog| endif

line 321: 

line 322: " CHILL

line 323: au BufNewFile,BufRead *..ch^I^I^Isetf chill

line 324: 

line 325: " Changes for WEB and CWEB or CHILL

line 326: au BufNewFile,BufRead *.ch^I^I^Icall dist#ft#FTchange()

line 327: 

line 328: " ChordPro

line 329: au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro^Isetf chordpro

line 330: 

line 331: " Clean

line 332: au BufNewFile,BufRead *.dcl,*.icl^I^Isetf clean

line 333: 

line 334: " Clever

line 335: au BufNewFile,BufRead *.eni^I^I^Isetf cl

line 336: 

line 337: " Clever or dtd

line 338: au BufNewFile,BufRead *.ent^I^I^Icall dist#ft#FTent()

line 339: 

line 340: " Clipper (or FoxPro; could also be eviews)

line 346: au BufNewFile,BufRead *.prg if exists("g:filetype_prg") |   exe "setf " . g:filetype_prg | else |   setf clipper | endif

line 347: 

line 348: " Clojure

line 349: au BufNewFile,BufRead *.clj,*.cljs,*.cljx,*.cljc^I^Isetf clojure

line 350: 

line 351: " Cmake

line 352: au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in^I^Isetf cmake

line 353: 

line 354: " Cmusrc

line 355: au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc

line 356: au BufNewFile,BufRead */cmus/{rc,*.theme}^I^I^Isetf cmusrc

line 357: 

line 358: " Cobol

line 359: au BufNewFile,BufRead *.cbl,*.cob,*.lib^Isetf cobol

line 360: "   cobol or zope form controller python script? (heuristic)

line 366: au BufNewFile,BufRead *.cpy if getline(1) =~ '^##' |   setf python | else |   setf cobol | endif

line 367: 

line 368: " Coco/R

line 369: au BufNewFile,BufRead *.atg^I^I^Isetf coco

line 370: 

line 371: " Cold Fusion

line 372: au BufNewFile,BufRead *.cfm,*.cfi,*.cfc^I^Isetf cf

line 373: 

line 374: " Configure scripts

line 375: au BufNewFile,BufRead configure.in,configure.ac setf config

line 376: 

line 377: " CUDA  Cumpute Unified Device Architecture

line 378: au BufNewFile,BufRead *.cu,*.cuh^I^Isetf cuda

line 379: 

line 380: " Dockerfile

line 381: au BufNewFile,BufRead Dockerfile,*.Dockerfile^Isetf dockerfile

line 382: 

line 383: " WildPackets EtherPeek Decoder

line 384: au BufNewFile,BufRead *.dcd^I^I^Isetf dcd

line 385: 

line 386: " Enlightenment configuration files

line 387: au BufNewFile,BufRead *enlightenment/*.cfg^Isetf c

line 388: 

line 389: " Eterm

line 390: au BufNewFile,BufRead *Eterm/*.cfg^I^Isetf eterm

line 391: 

line 392: " Euphoria 3 or 4

line 393: au BufNewFile,BufRead *.eu,*.ew,*.ex,*.exu,*.exw  call dist#ft#EuphoriaCheck()

line 394: if has("fname_case")

line 395:    au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call dist#ft#EuphoriaCheck()

line 396: endif

line 397: 

line 398: " Lynx config files

line 399: au BufNewFile,BufRead lynx.cfg^I^I^Isetf lynx

line 400: 

line 401: " Quake

line 402: au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg^Isetf quake

line 403: au BufNewFile,BufRead *quake[1-3]/*.cfg^I^I^Isetf quake

line 404: 

line 405: " Quake C

line 406: au BufNewFile,BufRead *.qc^I^I^Isetf c

line 407: 

line 408: " Configure files

line 409: au BufNewFile,BufRead *.cfg^I^I^Isetf cfg

line 410: 

line 411: " Cucumber

line 412: au BufNewFile,BufRead *.feature^I^I^Isetf cucumber

line 413: 

line 414: " Communicating Sequential Processes

line 415: au BufNewFile,BufRead *.csp,*.fdr^I^Isetf csp

line 416: 

line 417: " CUPL logic description and simulation

line 418: au BufNewFile,BufRead *.pld^I^I^Isetf cupl

line 419: au BufNewFile,BufRead *.si^I^I^Isetf cuplsim

line 420: 

line 421: " Debian Control

line 422: au BufNewFile,BufRead */debian/control^I^Isetf debcontrol

line 426: au BufNewFile,BufRead control  if getline(1) =~ '^Source:'|   setf debcontrol| endif

line 427: 

line 428: " Debian Copyright

line 429: au BufNewFile,BufRead */debian/copyright^Isetf debcopyright

line 433: au BufNewFile,BufRead copyright  if getline(1) =~ '^Format:'|   setf debcopyright| endif

line 434: 

line 435: " Debian Sources.list

line 436: au BufNewFile,BufRead */etc/apt/sources.list^I^Isetf debsources

line 437: au BufNewFile,BufRead */etc/apt/sources.list.d/*.list^Isetf debsources

line 438: 

line 439: " Deny hosts

line 440: au BufNewFile,BufRead denyhosts.conf^I^Isetf denyhosts

line 441: 

line 442: " dnsmasq(8) configuration files

line 443: au BufNewFile,BufRead */etc/dnsmasq.conf^Isetf dnsmasq

line 444: 

line 445: " ROCKLinux package description

line 446: au BufNewFile,BufRead *.desc^I^I^Isetf desc

line 447: 

line 448: " the D language or dtrace

line 449: au BufNewFile,BufRead *.d^I^I^Icall dist#ft#DtraceCheck()

line 450: 

line 451: " Desktop files

line 452: au BufNewFile,BufRead *.desktop,.directory^Isetf desktop

line 453: 

line 454: " Dict config

line 455: au BufNewFile,BufRead dict.conf,.dictrc^I^Isetf dictconf

line 456: 

line 457: " Dictd config

line 458: au BufNewFile,BufRead dictd.conf^I^Isetf dictdconf

line 459: 

line 460: " Diff files

line 461: au BufNewFile,BufRead *.diff,*.rej^I^Isetf diff

line 467: au BufNewFile,BufRead *.patch if getline(1) =~ '^From [0-9a-f]\{40\} Mon Sep 17 00:00:00 2001$' |   setf gitsendemail | else |   setf diff | endif

line 468: 

line 469: " Dircolors

line 470: au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS^Isetf dircolors

line 471: 

line 472: " Diva (with Skill) or InstallShield

line 478: au BufNewFile,BufRead *.rul if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |   setf ishd | else |   setf diva | endif

line 479: 

line 480: " DCL (Digital Command Language - vms) or DNS zone file

line 481: au BufNewFile,BufRead *.com^I^I^Icall dist#ft#BindzoneCheck('dcl')

line 482: 

line 483: " DOT

line 484: au BufNewFile,BufRead *.dot^I^I^Isetf dot

line 485: 

line 486: " Dylan - lid files

line 487: au BufNewFile,BufRead *.lid^I^I^Isetf dylanlid

line 488: 

line 489: " Dylan - intr files (melange)

line 490: au BufNewFile,BufRead *.intr^I^I^Isetf dylanintr

line 491: 

line 492: " Dylan

line 493: au BufNewFile,BufRead *.dylan^I^I^Isetf dylan

line 494: 

line 495: " Microsoft Module Definition

line 496: au BufNewFile,BufRead *.def^I^I^Isetf def

line 497: 

line 498: " Dracula

line 499: au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe^Isetf dracula

line 500: 

line 501: " Datascript

line 502: au BufNewFile,BufRead *.ds^I^I^Isetf datascript

line 503: 

line 504: " dsl

line 505: au BufNewFile,BufRead *.dsl^I^I^Isetf dsl

line 506: 

line 507: " DTD (Document Type Definition for XML)

line 508: au BufNewFile,BufRead *.dtd^I^I^Isetf dtd

line 509: 

line 510: " DTS/DSTI (device tree files)

line 511: au BufNewFile,BufRead *.dts,*.dtsi^I^Isetf dts

line 512: 

line 513: " EDIF (*.edf,*.edif,*.edn,*.edo) or edn

line 514: au BufNewFile,BufRead *.ed\(f\|if\|o\)^I^Isetf edif

line 520: au BufNewFile,BufRead *.edn if getline(1) =~ '^\s*(\s*edif\>' |   setf edif | else |   setf clojure | endif

line 521: 

line 522: " EditorConfig (close enough to dosini)

line 523: au BufNewFile,BufRead .editorconfig^I^Isetf dosini

line 524: 

line 525: " Embedix Component Description

line 526: au BufNewFile,BufRead *.ecd^I^I^Isetf ecd

line 527: 

line 528: " Eiffel or Specman or Euphoria

line 529: au BufNewFile,BufRead *.e,*.E^I^I^Icall dist#ft#FTe()

line 530: 

line 531: " Elinks configuration

line 532: au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf^Isetf elinks

line 533: 

line 534: " ERicsson LANGuage; Yaws is erlang too

line 535: au BufNewFile,BufRead *.erl,*.hrl,*.yaws^Isetf erlang

line 536: 

line 537: " Elm Filter Rules file

line 538: au BufNewFile,BufRead filter-rules^I^Isetf elmfilt

line 539: 

line 540: " ESMTP rc file

line 541: au BufNewFile,BufRead *esmtprc^I^I^Isetf esmtprc

line 542: 

line 543: " ESQL-C

line 544: au BufNewFile,BufRead *.ec,*.EC^I^I^Isetf esqlc

line 545: 

line 546: " Esterel

line 547: au BufNewFile,BufRead *.strl^I^I^Isetf esterel

line 548: 

line 549: " Essbase script

line 550: au BufNewFile,BufRead *.csc^I^I^Isetf csc

line 551: 

line 552: " Exim

line 553: au BufNewFile,BufRead exim.conf^I^I^Isetf exim

line 554: 

line 555: " Expect

line 556: au BufNewFile,BufRead *.exp^I^I^Isetf expect

line 557: 

line 558: " Exports

line 559: au BufNewFile,BufRead exports^I^I^Isetf exports

line 560: 

line 561: " Falcon

line 562: au BufNewFile,BufRead *.fal^I^I^Isetf falcon

line 563: 

line 564: " Fantom

line 565: au BufNewFile,BufRead *.fan,*.fwt^I^Isetf fan

line 566: 

line 567: " Factor

line 568: au BufNewFile,BufRead *.factor^I^I^Isetf factor

line 569: 

line 570: " Fetchmail RC file

line 571: au BufNewFile,BufRead .fetchmailrc^I^Isetf fetchmail

line 572: 

line 573: " FlexWiki - disabled, because it has side effects when a .wiki file

line 574: " is not actually FlexWiki

line 575: "au BufNewFile,BufRead *.wiki^I^I^Isetf flexwiki

line 576: 

line 577: " Focus Executable

line 578: au BufNewFile,BufRead *.fex,*.focexec^I^Isetf focexec

line 579: 

line 580: " Focus Master file (but not for auto.master)

line 581: au BufNewFile,BufRead auto.master^I^Isetf conf

line 582: au BufNewFile,BufRead *.mas,*.master^I^Isetf master

line 583: 

line 584: " Forth

line 585: au BufNewFile,BufRead *.fs,*.ft,*.fth^I^Isetf forth

line 586: 

line 587: " Reva Forth

line 588: au BufNewFile,BufRead *.frt^I^I^Isetf reva

line 589: 

line 590: " Fortran

line 591: if has("fname_case")

line 592:   au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08^I setf fortran

line 593: endif

line 594: au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran

line 595: 

line 596: " Framescript

line 597: au BufNewFile,BufRead *.fsl^I^I^Isetf framescript

line 598: 

line 599: " FStab

line 600: au BufNewFile,BufRead fstab,mtab^I^Isetf fstab

line 601: 

line 602: " GDB command files

line 603: au BufNewFile,BufRead .gdbinit^I^I^Isetf gdb

line 604: 

line 605: " GDMO

line 606: au BufNewFile,BufRead *.mo,*.gdmo^I^Isetf gdmo

line 607: 

line 608: " Gedcom

line 609: au BufNewFile,BufRead *.ged,lltxxxxx.txt^Isetf gedcom

line 610: 

line 611: " Git

line 612: au BufNewFile,BufRead COMMIT_EDITMSG,MERGE_MSG,TAG_EDITMSG ^Isetf gitcommit

line 613: au BufNewFile,BufRead *.git/config,.gitconfig,/etc/gitconfig ^Isetf gitconfig

line 614: au BufNewFile,BufRead */.config/git/config^I^I^Isetf gitconfig

line 615: au BufNewFile,BufRead .gitmodules,*.git/modules/*/config^Isetf gitconfig

line 616: if !empty($XDG_CONFIG_HOME)

line 617:   au BufNewFile,BufRead $XDG_CONFIG_HOME/git/config^I^Isetf gitconfig

line 618: endif

line 619: au BufNewFile,BufRead git-rebase-todo^I^Isetf gitrebase

line 620: au BufRead,BufNewFile .gitsendemail.msg.??????^Isetf gitsendemail

line 624: au BufNewFile,BufRead .msg.[0-9]* if getline(1) =~ '^From.*# This line is ignored.$' |   setf gitsendemail | endif

line 628: au BufNewFile,BufRead *.git/* if getline(1) =~ '^\x\{40\}\>\|^ref: ' |   setf git | endif

line 629: 

line 630: " Gkrellmrc

line 631: au BufNewFile,BufRead gkrellmrc,gkrellmrc_?^Isetf gkrellmrc

line 632: 

line 633: " GP scripts (2.0 and onward)

line 634: au BufNewFile,BufRead *.gp,.gprc^I^Isetf gp

line 635: 

line 636: " GPG

line 637: au BufNewFile,BufRead */.gnupg/options^I^Isetf gpg

line 638: au BufNewFile,BufRead */.gnupg/gpg.conf^I^Isetf gpg

line 639: au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg

line 640: if !empty($GNUPGHOME)

line 641:   au BufNewFile,BufRead $GNUPGHOME/options^Isetf gpg

line 642:   au BufNewFile,BufRead $GNUPGHOME/gpg.conf^Isetf gpg

line 643: endif

line 644: 

line 645: " gnash(1) configuration files

line 646: au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash

line 647: 

line 648: " Gitolite

line 649: au BufNewFile,BufRead gitolite.conf^I^Isetf gitolite

line 650: au BufNewFile,BufRead */gitolite-admin/conf/*^Icall s:StarSetf('gitolite')

line 651: au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc^Isetf perl

line 652: 

line 653: " Gnuplot scripts

line 654: au BufNewFile,BufRead *.gpi^I^I^Isetf gnuplot

line 655: 

line 656: " Go (Google)

line 657: au BufNewFile,BufRead *.go^I^I^Isetf go

line 658: 

line 659: " GrADS scripts

line 660: au BufNewFile,BufRead *.gs^I^I^Isetf grads

line 661: 

line 662: " Gretl

line 663: au BufNewFile,BufRead *.gretl^I^I^Isetf gretl

line 664: 

line 665: " Groovy

line 666: au BufNewFile,BufRead *.gradle,*.groovy^I^Isetf groovy

line 667: 

line 668: " GNU Server Pages

line 669: au BufNewFile,BufRead *.gsp^I^I^Isetf gsp

line 670: 

line 671: " Group file

line 672: au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group

line 673: 

line 674: " GTK RC

line 675: au BufNewFile,BufRead .gtkrc,gtkrc^I^Isetf gtkrc

line 676: 

line 677: " Haml

line 678: au BufNewFile,BufRead *.haml^I^I^Isetf haml

line 679: 

line 680: " Hamster Classic | Playground files

line 681: au BufNewFile,BufRead *.hsc,*.hsm^I^Isetf hamster

line 682: 

line 683: " Haskell

line 684: au BufNewFile,BufRead *.hs,*.hs-boot^I^Isetf haskell

line 685: au BufNewFile,BufRead *.lhs^I^I^Isetf lhaskell

line 686: au BufNewFile,BufRead *.chs^I^I^Isetf chaskell

line 687: 

line 688: " Haste

line 689: au BufNewFile,BufRead *.ht^I^I^Isetf haste

line 690: au BufNewFile,BufRead *.htpp^I^I^Isetf hastepreproc

line 691: 

line 692: " Hercules

line 693: au BufNewFile,BufRead *.vc,*.ev,*.sum,*.errsum^Isetf hercules

line 694: 

line 695: " HEX (Intel)

line 696: au BufNewFile,BufRead *.hex,*.h32^I^Isetf hex

line 697: 

line 698: " Tilde (must be before HTML)

line 699: au BufNewFile,BufRead *.t.html^I^I^Isetf tilde

line 700: 

line 701: " HTML (.shtml and .stm for server side)

line 702: au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call dist#ft#FThtml()

line 703: 

line 704: " HTML with Ruby - eRuby

line 705: au BufNewFile,BufRead *.erb,*.rhtml^I^Isetf eruby

line 706: 

line 707: " HTML with M4

line 708: au BufNewFile,BufRead *.html.m4^I^I^Isetf htmlm4

line 709: 

line 710: " HTML Cheetah template

line 711: au BufNewFile,BufRead *.tmpl^I^I^Isetf htmlcheetah

line 712: 

line 713: " Host config

line 714: au BufNewFile,BufRead */etc/host.conf^I^Isetf hostconf

line 715: 

line 716: " Hosts access

line 717: au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess

line 718: 

line 719: " Hyper Builder

line 720: au BufNewFile,BufRead *.hb^I^I^Isetf hb

line 721: 

line 722: " Httest

line 723: au BufNewFile,BufRead *.htt,*.htb^I^Isetf httest

line 724: 

line 725: " Icon

line 726: au BufNewFile,BufRead *.icn^I^I^Isetf icon

line 727: 

line 728: " IDL (Interface Description Language)

line 729: au BufNewFile,BufRead *.idl^I^I^Icall dist#ft#FTidl()

line 730: 

line 731: " Microsoft IDL (Interface Description Language)  Also *.idl

line 732: " MOF = WMI (Windows Management Instrumentation) Managed Object Format

line 733: au BufNewFile,BufRead *.odl,*.mof^I^Isetf msidl

line 734: 

line 735: " Icewm menu

line 736: au BufNewFile,BufRead */.icewm/menu^I^Isetf icemenu

line 737: 

line 738: " Indent profile (must come before IDL *.pro!)

line 739: au BufNewFile,BufRead .indent.pro^I^Isetf indent

line 740: au BufNewFile,BufRead indent.pro^I^Icall dist#ft#ProtoCheck('indent')

line 741: 

line 742: " IDL (Interactive Data Language)

line 743: au BufNewFile,BufRead *.pro^I^I^Icall dist#ft#ProtoCheck('idlang')

line 744: 

line 745: " Indent RC

line 746: au BufNewFile,BufRead indentrc^I^I^Isetf indent

line 747: 

line 748: " Inform

line 749: au BufNewFile,BufRead *.inf,*.INF^I^Isetf inform

line 750: 

line 751: " Initng

line 752: au BufNewFile,BufRead */etc/initng/*/*.i,*.ii^Isetf initng

line 753: 

line 754: " Innovation Data Processing

line 755: au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c ^Isetf upstreamdat

line 756: au BufRead,BufNewFile fdrupstream.log,upstream.log\c,upstream.*.log\c,*.upstream.log\c,UPSTREAM-*.log\c ^Isetf upstreamlog

line 757: au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog

line 758: au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c ^Isetf usserverlog

line 759: au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c ^Isetf usw2kagtlog

line 760: 

line 761: " Ipfilter

line 762: au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules^Isetf ipfilter

line 763: 

line 764: " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)

line 765: au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl^Isetf fgl

line 766: 

line 767: " .INI file for MSDOS

line 768: au BufNewFile,BufRead *.ini^I^I^Isetf dosini

line 769: 

line 770: " SysV Inittab

line 771: au BufNewFile,BufRead inittab^I^I^Isetf inittab

line 772: 

line 773: " Inno Setup

line 774: au BufNewFile,BufRead *.iss^I^I^Isetf iss

line 775: 

line 776: " J

line 777: au BufNewFile,BufRead *.ijs^I^I^Isetf j

line 778: 

line 779: " JAL

line 780: au BufNewFile,BufRead *.jal,*.JAL^I^Isetf jal

line 781: 

line 782: " Jam

line 783: au BufNewFile,BufRead *.jpl,*.jpr^I^Isetf jam

line 784: 

line 785: " Java

line 786: au BufNewFile,BufRead *.java,*.jav^I^Isetf java

line 787: 

line 788: " JavaCC

line 789: au BufNewFile,BufRead *.jj,*.jjt^I^Isetf javacc

line 790: 

line 791: " JavaScript, ECMAScript

line 792: au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx,*.mjs   setf javascript

line 793: 

line 794: " Java Server Pages

line 795: au BufNewFile,BufRead *.jsp^I^I^Isetf jsp

line 796: 

line 797: " Java Properties resource file (note: doesn't catch font.properties.pl)

line 798: au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??^Isetf jproperties

line 799: au BufNewFile,BufRead *.properties_??_??_*^Icall s:StarSetf('jproperties')

line 800: 

line 801: " Jess

line 802: au BufNewFile,BufRead *.clp^I^I^Isetf jess

line 803: 

line 804: " Jgraph

line 805: au BufNewFile,BufRead *.jgr^I^I^Isetf jgraph

line 806: 

line 807: " Jovial

line 808: au BufNewFile,BufRead *.jov,*.j73,*.jovial^Isetf jovial

line 809: 

line 810: " JSON

line 811: au BufNewFile,BufRead *.json,*.jsonp,*.webmanifest^Isetf json

line 812: 

line 813: " Kixtart

line 814: au BufNewFile,BufRead *.kix^I^I^Isetf kix

line 815: 

line 816: " Kimwitu[++]

line 817: au BufNewFile,BufRead *.k^I^I^Isetf kwt

line 818: 

line 819: " Kivy

line 820: au BufNewFile,BufRead *.kv^I^I^Isetf kivy

line 821: 

line 822: " KDE script

line 823: au BufNewFile,BufRead *.ks^I^I^Isetf kscript

line 824: 

line 825: " Kconfig

line 826: au BufNewFile,BufRead Kconfig,Kconfig.debug^Isetf kconfig

line 827: 

line 828: " Lace (ISE)

line 829: au BufNewFile,BufRead *.ace,*.ACE^I^Isetf lace

line 830: 

line 831: " Latte

line 832: au BufNewFile,BufRead *.latte,*.lte^I^Isetf latte

line 833: 

line 834: " Limits

line 835: au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf^Isetf limits

line 836: 

line 837: " LambdaProlog (*.mod too, see Modsim)

line 838: au BufNewFile,BufRead *.sig^I^I^Isetf lprolog

line 839: 

line 840: " LDAP LDIF

line 841: au BufNewFile,BufRead *.ldif^I^I^Isetf ldif

line 842: 

line 843: " Ld loader

line 844: au BufNewFile,BufRead *.ld^I^I^Isetf ld

line 845: 

line 846: " Less

line 847: au BufNewFile,BufRead *.less^I^I^Isetf less

line 848: 

line 849: " Lex

line 850: au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++^Isetf lex

line 851: 

line 852: " Libao

line 853: au BufNewFile,BufRead */etc/libao.conf,*/.libao^Isetf libao

line 854: 

line 855: " Libsensors

line 856: au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf^Isetf sensors

line 857: 

line 858: " LFTP

line 859: au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc^Isetf lftp

line 860: 

line 861: " Lifelines (or Lex for C++!)

line 862: au BufNewFile,BufRead *.ll^I^I^Isetf lifelines

line 863: 

line 864: " Lilo: Linux loader

line 865: au BufNewFile,BufRead lilo.conf^I^I^Isetf lilo

line 866: 

line 867: " Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)

line 868: if has("fname_case")

line 869:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp

line 870: else

line 871:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp

line 872: endif

line 873: 

line 874: " SBCL implementation of Common Lisp

line 875: au BufNewFile,BufRead sbclrc,.sbclrc^I^Isetf lisp

line 876: 

line 877: " Liquid

line 878: au BufNewFile,BufRead *.liquid^I^I^Isetf liquid

line 879: 

line 880: " Lite

line 881: au BufNewFile,BufRead *.lite,*.lt^I^Isetf lite

line 882: 

line 883: " LiteStep RC files

line 884: au BufNewFile,BufRead */LiteStep/*/*.rc^I^Isetf litestep

line 885: 

line 886: " Login access

line 887: au BufNewFile,BufRead */etc/login.access^Isetf loginaccess

line 888: 

line 889: " Login defs

line 890: au BufNewFile,BufRead */etc/login.defs^I^Isetf logindefs

line 891: 

line 892: " Logtalk

line 893: au BufNewFile,BufRead *.lgt^I^I^Isetf logtalk

line 894: 

line 895: " LOTOS

line 896: au BufNewFile,BufRead *.lot,*.lotos^I^Isetf lotos

line 897: 

line 898: " Lout (also: *.lt)

line 899: au BufNewFile,BufRead *.lou,*.lout^I^Isetf lout

line 900: 

line 901: " Lua

line 902: au BufNewFile,BufRead *.lua^I^I^Isetf lua

line 903: 

line 904: " Luarocks

line 905: au BufNewFile,BufRead *.rockspec^I^Isetf lua

line 906: 

line 907: " Linden Scripting Language (Second Life)

line 908: au BufNewFile,BufRead *.lsl^I^I^Isetf lsl

line 909: 

line 910: " Lynx style file (or LotusScript!)

line 911: au BufNewFile,BufRead *.lss^I^I^Isetf lss

line 912: 

line 913: " M4

line 915: au BufNewFile,BufRead *.m4 if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif

line 916: 

line 917: " MaGic Point

line 918: au BufNewFile,BufRead *.mgp^I^I^Isetf mgp

line 919: 

line 920: " Mail (for Elm, trn, mutt, muttng, rn, slrn, neomutt)

line 921: au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},neomutt-*-\w\+,neomutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail

line 922: 

line 923: " Mail aliases

line 924: au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases^Isetf mailaliases

line 925: 

line 926: " Mailcap configuration file

line 927: au BufNewFile,BufRead .mailcap,mailcap^I^Isetf mailcap

line 928: 

line 929: " Makefile

line 930: au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make

line 931: 

line 932: " MakeIndex

line 933: au BufNewFile,BufRead *.ist,*.mst^I^Isetf ist

line 934: 

line 935: " Mallard

line 936: au BufNewFile,BufRead *.page^I^I^Isetf mallard

line 937: 

line 938: " Manpage

line 939: au BufNewFile,BufRead *.man^I^I^Isetf nroff

line 940: 

line 941: " Man config

line 942: au BufNewFile,BufRead */etc/man.conf,man.config^Isetf manconf

line 943: 

line 944: " Maple V

line 945: au BufNewFile,BufRead *.mv,*.mpl,*.mws^I^Isetf maple

line 946: 

line 947: " Map (UMN mapserver config file)

line 948: au BufNewFile,BufRead *.map^I^I^Isetf map

line 949: 

line 950: " Markdown

line 951: au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,*.md  setf markdown

line 952: 

line 953: " Mason

line 954: au BufNewFile,BufRead *.mason,*.mhtml,*.comp^Isetf mason

line 955: 

line 956: " Mathematica, Matlab, Murphi or Objective C

line 957: au BufNewFile,BufRead *.m^I^I^Icall dist#ft#FTm()

line 958: 

line 959: " Mathematica notebook

line 960: au BufNewFile,BufRead *.nb^I^I^Isetf mma

line 961: 

line 962: " Maya Extension Language

line 963: au BufNewFile,BufRead *.mel^I^I^Isetf mel

line 964: 

line 965: " Mercurial (hg) commit file

line 966: au BufNewFile,BufRead hg-editor-*.txt^I^Isetf hgcommit

line 967: 

line 968: " Mercurial config (looks like generic config file)

line 969: au BufNewFile,BufRead *.hgrc,*hgrc^I^Isetf cfg

line 970: 

line 971: " Messages (logs mostly)

line 972: au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages

line 973: 

line 974: " Metafont

line 975: au BufNewFile,BufRead *.mf^I^I^Isetf mf

line 976: 

line 977: " MetaPost

line 978: au BufNewFile,BufRead *.mp^I^I^Isetf mp

line 979: 

line 980: " MGL

line 981: au BufNewFile,BufRead *.mgl^I^I^Isetf mgl

line 982: 

line 983: " MIX - Knuth assembly

line 984: au BufNewFile,BufRead *.mix,*.mixal^I^Isetf mix

line 985: 

line 986: " MMIX or VMS makefile

line 987: au BufNewFile,BufRead *.mms^I^I^Icall dist#ft#FTmms()

line 988: 

line 989: " Symbian meta-makefile definition (MMP)

line 990: au BufNewFile,BufRead *.mmp^I^I^Isetf mmp

line 991: 

line 992: " Modsim III (or LambdaProlog)

line 998: au BufNewFile,BufRead *.mod if getline(1) =~ '\<module\>' |   setf lprolog | else |   setf modsim3 | endif

line 999: 

line 1000: " Modula 2  (.md removed in favor of Markdown)

line 1001: au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.mi^Isetf modula2

line 1002: 

line 1003: " Modula 3 (.m3, .i3, .mg, .ig)

line 1004: au BufNewFile,BufRead *.[mi][3g]^I^Isetf modula3

line 1005: 

line 1006: " Monk

line 1007: au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc^Isetf monk

line 1008: 

line 1009: " MOO

line 1010: au BufNewFile,BufRead *.moo^I^I^Isetf moo

line 1011: 

line 1012: " Modconf

line 1013: au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf

line 1014: 

line 1015: " Mplayer config

line 1016: au BufNewFile,BufRead mplayer.conf,*/.mplayer/config^Isetf mplayerconf

line 1017: 

line 1018: " Motorola S record

line 1019: au BufNewFile,BufRead *.s19,*.s28,*.s37,*.mot,*.srec^Isetf srec

line 1020: 

line 1021: " Mrxvtrc

line 1022: au BufNewFile,BufRead mrxvtrc,.mrxvtrc^I^Isetf mrxvtrc

line 1023: 

line 1024: " Msql

line 1025: au BufNewFile,BufRead *.msql^I^I^Isetf msql

line 1026: 

line 1027: " Mysql

line 1028: au BufNewFile,BufRead *.mysql^I^I^Isetf mysql

line 1029: 

line 1030: " Mutt setup files (must be before catch *.rc)

line 1031: au BufNewFile,BufRead */etc/Muttrc.d/*^I^Icall s:StarSetf('muttrc')

line 1032: 

line 1033: " M$ Resource files

line 1034: au BufNewFile,BufRead *.rc,*.rch^I^Isetf rc

line 1035: 

line 1036: " MuPAD source

line 1037: au BufRead,BufNewFile *.mu^I^I^Isetf mupad

line 1038: 

line 1039: " Mush

line 1040: au BufNewFile,BufRead *.mush^I^I^Isetf mush

line 1041: 

line 1042: " Mutt setup file (also for Muttng)

line 1043: au BufNewFile,BufRead Mutt{ng,}rc^I^Isetf muttrc

line 1044: 

line 1045: " N1QL

line 1046: au BufRead,BufNewfile *.n1ql,*.nql^I^Isetf n1ql

line 1047: 

line 1048: " Nano

line 1049: au BufNewFile,BufRead */etc/nanorc,*.nanorc  ^Isetf nanorc

line 1050: 

line 1051: " Nastran input/DMAP

line 1052: "au BufNewFile,BufRead *.dat^I^I^Isetf nastran

line 1053: 

line 1054: " Natural

line 1055: au BufNewFile,BufRead *.NS[ACGLMNPS]^I^Isetf natural

line 1056: 

line 1057: " Noemutt setup file

line 1058: au BufNewFile,BufRead Neomuttrc^I^I^Isetf neomuttrc

line 1059: 

line 1060: " Netrc

line 1061: au BufNewFile,BufRead .netrc^I^I^Isetf netrc

line 1062: 

line 1063: " Ninja file

line 1064: au BufNewFile,BufRead *.ninja^I^I^Isetf ninja

line 1065: 

line 1066: " Novell netware batch files

line 1067: au BufNewFile,BufRead *.ncf^I^I^Isetf ncf

line 1068: 

line 1069: " Nroff/Troff (*.ms and *.t are checked below)

line 1073: au BufNewFile,BufRead *.me if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |   setf nroff | endif

line 1074: au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom^Isetf nroff

line 1075: au BufNewFile,BufRead *.[1-9]^I^I^Icall dist#ft#FTnroff()

line 1076: 

line 1077: " Nroff or Objective C++

line 1078: au BufNewFile,BufRead *.mm^I^I^Icall dist#ft#FTmm()

line 1079: 

line 1080: " Not Quite C

line 1081: au BufNewFile,BufRead *.nqc^I^I^Isetf nqc

line 1082: 

line 1083: " NSE - Nmap Script Engine - uses Lua syntax

line 1084: au BufNewFile,BufRead *.nse^I^I^Isetf lua

line 1085: 

line 1086: " NSIS

line 1087: au BufNewFile,BufRead *.nsi,*.nsh^I^Isetf nsis

line 1088: 

line 1089: " OCAML

line 1090: au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit^Isetf ocaml

line 1091: 

line 1092: " Occam

line 1093: au BufNewFile,BufRead *.occ^I^I^Isetf occam

line 1094: 

line 1095: " Omnimark

line 1096: au BufNewFile,BufRead *.xom,*.xin^I^Isetf omnimark

line 1097: 

line 1098: " OpenROAD

line 1099: au BufNewFile,BufRead *.or^I^I^Isetf openroad

line 1100: 

line 1101: " OPL

line 1102: au BufNewFile,BufRead *.[Oo][Pp][Ll]^I^Isetf opl

line 1103: 

line 1104: " Oracle config file

line 1105: au BufNewFile,BufRead *.ora^I^I^Isetf ora

line 1106: 

line 1107: " Packet filter conf

line 1108: au BufNewFile,BufRead pf.conf^I^I^Isetf pf

line 1109: 

line 1110: " Pam conf

line 1111: au BufNewFile,BufRead */etc/pam.conf^I^Isetf pamconf

line 1112: 

line 1113: " PApp

line 1114: au BufNewFile,BufRead *.papp,*.pxml,*.pxsl^Isetf papp

line 1115: 

line 1116: " Password file

line 1117: au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd

line 1118: 

line 1119: " Pascal (also *.p)

line 1120: au BufNewFile,BufRead *.pas^I^I^Isetf pascal

line 1121: 

line 1122: " Delphi project file

line 1123: au BufNewFile,BufRead *.dpr^I^I^Isetf pascal

line 1124: 

line 1125: " PDF

line 1126: au BufNewFile,BufRead *.pdf^I^I^Isetf pdf

line 1127: 

line 1128: " PCMK - HAE - crm configure edit

line 1129: au BufNewFile,BufRead *.pcmk ^I^I^Isetf pcmk

line 1130: 

line 1131: " Perl

line 1132: if has("fname_case")

line 1133:   au BufNewFile,BufRead *.pl,*.PL^I^Icall dist#ft#FTpl()

line 1134: else

line 1135:   au BufNewFile,BufRead *.pl^I^I^Icall dist#ft#FTpl()

line 1136: endif

line 1137: au BufNewFile,BufRead *.plx,*.al,*.psgi^I^Isetf perl

line 1138: au BufNewFile,BufRead *.p6,*.pm6,*.pl6^I^Isetf perl6

line 1139: 

line 1140: " Perl, XPM or XPM2

line 1148: au BufNewFile,BufRead *.pm if getline(1) =~ "XPM2" |   setf xpm2 | elseif getline(1) =~ "XPM" |   setf xpm | else |   setf perl | endif

line 1149: 

line 1150: " Perl POD

line 1151: au BufNewFile,BufRead *.pod^I^I^Isetf pod

line 1152: au BufNewFile,BufRead *.pod6^I^I^Isetf pod6

line 1153: 

line 1154: " Php, php3, php4, etc.

line 1155: " Also Phtml (was used for PHP 2 in the past)

line 1156: " Also .ctp for Cake template file

line 1157: au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp^Isetf php

line 1158: 

line 1159: " Pike and Cmod

line 1160: au BufNewFile,BufRead *.pike,*.pmod^I^Isetf pike

line 1161: au BufNewFile,BufRead *.cmod^I^I^Isetf cmod

line 1162: 

line 1163: " Pinfo config

line 1164: au BufNewFile,BufRead */etc/pinforc,*/.pinforc^Isetf pinfo

line 1165: 

line 1166: " Palm Resource compiler

line 1167: au BufNewFile,BufRead *.rcp^I^I^Isetf pilrc

line 1168: 

line 1169: " Pine config

line 1170: au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex^I^Isetf pine

line 1171: 

line 1172: " PL/1, PL/I

line 1173: au BufNewFile,BufRead *.pli,*.pl1^I^Isetf pli

line 1174: 

line 1175: " PL/M (also: *.inp)

line 1176: au BufNewFile,BufRead *.plm,*.p36,*.pac^I^Isetf plm

line 1177: 

line 1178: " PL/SQL

line 1179: au BufNewFile,BufRead *.pls,*.plsql^I^Isetf plsql

line 1180: 

line 1181: " PLP

line 1182: au BufNewFile,BufRead *.plp^I^I^Isetf plp

line 1183: 

line 1184: " PO and PO template (GNU gettext)

line 1185: au BufNewFile,BufRead *.po,*.pot^I^Isetf po

line 1186: 

line 1187: " Postfix main config

line 1188: au BufNewFile,BufRead main.cf^I^I^Isetf pfmain

line 1189: 

line 1190: " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)

line 1191: au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai^I  setf postscr

line 1192: 

line 1193: " PostScript Printer Description

line 1194: au BufNewFile,BufRead *.ppd^I^I^Isetf ppd

line 1195: 

line 1196: " Povray

line 1197: au BufNewFile,BufRead *.pov^I^I^Isetf pov

line 1198: 

line 1199: " Povray configuration

line 1200: au BufNewFile,BufRead .povrayrc^I^I^Isetf povini

line 1201: 

line 1202: " Povray, PHP or assembly

line 1203: au BufNewFile,BufRead *.inc^I^I^Icall dist#ft#FTinc()

line 1204: 

line 1205: " Printcap and Termcap

line 1207: au BufNewFile,BufRead *printcap let b:ptcap_type = "print" | setf ptcap

line 1209: au BufNewFile,BufRead *termcap let b:ptcap_type = "term" | setf ptcap

line 1210: 

line 1211: " PCCTS / ANTRL

line 1212: "au BufNewFile,BufRead *.g^I^I^Isetf antrl

line 1213: au BufNewFile,BufRead *.g^I^I^Isetf pccts

line 1214: 

line 1215: " PPWizard

line 1216: au BufNewFile,BufRead *.it,*.ih^I^I^Isetf ppwiz

line 1217: 

line 1218: " Obj 3D file format

line 1219: " TODO: is there a way to avoid MS-Windows Object files?

line 1220: au BufNewFile,BufRead *.obj^I^I^Isetf obj

line 1221: 

line 1222: " Oracle Pro*C/C++

line 1223: au BufNewFile,BufRead *.pc^I^I^Isetf proc

line 1224: 

line 1225: " Privoxy actions file

line 1226: au BufNewFile,BufRead *.action^I^I^Isetf privoxy

line 1227: 

line 1228: " Procmail

line 1229: au BufNewFile,BufRead .procmail,.procmailrc^Isetf procmail

line 1230: 

line 1231: " Progress or CWEB

line 1232: au BufNewFile,BufRead *.w^I^I^Icall dist#ft#FTprogress_cweb()

line 1233: 

line 1234: " Progress or assembly

line 1235: au BufNewFile,BufRead *.i^I^I^Icall dist#ft#FTprogress_asm()

line 1236: 

line 1237: " Progress or Pascal

line 1238: au BufNewFile,BufRead *.p^I^I^Icall dist#ft#FTprogress_pascal()

line 1239: 

line 1240: " Software Distributor Product Specification File (POSIX 1387.2-1995)

line 1241: au BufNewFile,BufRead *.psf^I^I^Isetf psf

line 1245: au BufNewFile,BufRead INDEX,INFO if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |   setf psf | endif

line 1246: 

line 1247: " Prolog

line 1248: au BufNewFile,BufRead *.pdb^I^I^Isetf prolog

line 1249: 

line 1250: " Promela

line 1251: au BufNewFile,BufRead *.pml^I^I^Isetf promela

line 1252: 

line 1253: " Google protocol buffers

line 1254: au BufNewFile,BufRead *.proto^I^I^Isetf proto

line 1255: 

line 1256: " Protocols

line 1257: au BufNewFile,BufRead */etc/protocols^I^Isetf protocols

line 1258: 

line 1259: " Pyrex

line 1260: au BufNewFile,BufRead *.pyx,*.pxd^I^Isetf pyrex

line 1261: 

line 1262: " Python, Python Shell Startup and Python Stub Files

line 1263: " Quixote (Python-based web framework)

line 1264: au BufNewFile,BufRead *.py,*.pyw,.pythonstartup,.pythonrc,*.ptl,*.pyi  setf python

line 1265: 

line 1266: " Radiance

line 1267: au BufNewFile,BufRead *.rad,*.mat^I^Isetf radiance

line 1268: 

line 1269: " Ratpoison config/command files

line 1270: au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc^Isetf ratpoison

line 1271: 

line 1272: " RCS file

line 1273: au BufNewFile,BufRead *\,v^I^I^Isetf rcs

line 1274: 

line 1275: " Readline

line 1276: au BufNewFile,BufRead .inputrc,inputrc^I^Isetf readline

line 1277: 

line 1278: " Registry for MS-Windows

line 1280: au BufNewFile,BufRead *.reg if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif

line 1281: 

line 1282: " Renderman Interface Bytestream

line 1283: au BufNewFile,BufRead *.rib^I^I^Isetf rib

line 1284: 

line 1285: " Rexx

line 1286: au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit^Isetf rexx

line 1287: 

line 1288: " R (Splus)

line 1289: if has("fname_case")

line 1290:   au BufNewFile,BufRead *.s,*.S^I^I^Isetf r

line 1291: else

line 1292:   au BufNewFile,BufRead *.s^I^I^Isetf r

line 1293: endif

line 1294: 

line 1295: " R Help file

line 1296: if has("fname_case")

line 1297:   au BufNewFile,BufRead *.rd,*.Rd^I^Isetf rhelp

line 1298: else

line 1299:   au BufNewFile,BufRead *.rd^I^I^Isetf rhelp

line 1300: endif

line 1301: 

line 1302: " R noweb file

line 1303: if has("fname_case")

line 1304:   au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw^I^Isetf rnoweb

line 1305: else

line 1306:   au BufNewFile,BufRead *.rnw,*.snw^I^I^Isetf rnoweb

line 1307: endif

line 1308: 

line 1309: " R Markdown file

line 1310: if has("fname_case")

line 1311:   au BufNewFile,BufRead *.Rmd,*.rmd,*.Smd,*.smd^I^Isetf rmd

line 1312: else

line 1313:   au BufNewFile,BufRead *.rmd,*.smd^I^I^Isetf rmd

line 1314: endif

line 1315: 

line 1316: " R reStructuredText file

line 1317: if has("fname_case")

line 1318:   au BufNewFile,BufRead *.Rrst,*.rrst,*.Srst,*.srst^Isetf rrst

line 1319: else

line 1320:   au BufNewFile,BufRead *.rrst,*.srst^I^I^Isetf rrst

line 1321: endif

line 1322: 

line 1323: " Rexx, Rebol or R

line 1324: au BufNewFile,BufRead *.r,*.R^I^I^I^Icall dist#ft#FTr()

line 1325: 

line 1326: " Remind

line 1327: au BufNewFile,BufRead .reminders,*.remind,*.rem^I^Isetf remind

line 1328: 

line 1329: " Resolv.conf

line 1330: au BufNewFile,BufRead resolv.conf^I^Isetf resolv

line 1331: 

line 1332: " Relax NG Compact

line 1333: au BufNewFile,BufRead *.rnc^I^I^Isetf rnc

line 1334: 

line 1335: " Relax NG XML

line 1336: au BufNewFile,BufRead *.rng^I^I^Isetf rng

line 1337: 

line 1338: " RPL/2

line 1339: au BufNewFile,BufRead *.rpl^I^I^Isetf rpl

line 1340: 

line 1341: " Robots.txt

line 1342: au BufNewFile,BufRead robots.txt^I^Isetf robots

line 1343: 

line 1344: " Rpcgen

line 1345: au BufNewFile,BufRead *.x^I^I^Isetf rpcgen

line 1346: 

line 1347: " reStructuredText Documentation Format

line 1348: au BufNewFile,BufRead *.rst^I^I^Isetf rst

line 1349: 

line 1350: " RTF

line 1351: au BufNewFile,BufRead *.rtf^I^I^Isetf rtf

line 1352: 

line 1353: " Interactive Ruby shell

line 1354: au BufNewFile,BufRead .irbrc,irbrc^I^Isetf ruby

line 1355: 

line 1356: " Ruby

line 1357: au BufNewFile,BufRead *.rb,*.rbw^I^Isetf ruby

line 1358: 

line 1359: " RubyGems

line 1360: au BufNewFile,BufRead *.gemspec^I^I^Isetf ruby

line 1361: 

line 1362: " Rust

line 1363: au BufNewFile,BufRead *.rs^I^I^Isetf rust

line 1364: 

line 1365: " Rackup

line 1366: au BufNewFile,BufRead *.ru^I^I^Isetf ruby

line 1367: 

line 1368: " Bundler

line 1369: au BufNewFile,BufRead Gemfile^I^I^Isetf ruby

line 1370: 

line 1371: " Ruby on Rails

line 1372: au BufNewFile,BufRead *.builder,*.rxml,*.rjs^Isetf ruby

line 1373: 

line 1374: " Rantfile and Rakefile is like Ruby

line 1375: au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake^Isetf ruby

line 1376: 

line 1377: " S-lang (or shader language, or SmallLisp)

line 1378: au BufNewFile,BufRead *.sl^I^I^Isetf slang

line 1379: 

line 1380: " Samba config

line 1381: au BufNewFile,BufRead smb.conf^I^I^Isetf samba

line 1382: 

line 1383: " SAS script

line 1384: au BufNewFile,BufRead *.sas^I^I^Isetf sas

line 1385: 

line 1386: " Sass

line 1387: au BufNewFile,BufRead *.sass^I^I^Isetf sass

line 1388: 

line 1389: " Sather

line 1390: au BufNewFile,BufRead *.sa^I^I^Isetf sather

line 1391: 

line 1392: " Scala

line 1393: au BufNewFile,BufRead *.scala^I^I^Isetf scala

line 1394: 

line 1395: " SBT - Scala Build Tool

line 1396: au BufNewFile,BufRead *.sbt^I^I^Isetf sbt

line 1397: 

line 1398: " Scilab

line 1399: au BufNewFile,BufRead *.sci,*.sce^I^Isetf scilab

line 1400: 

line 1401: " SCSS

line 1402: au BufNewFile,BufRead *.scss^I^I^Isetf scss

line 1403: 

line 1404: " SD: Streaming Descriptors

line 1405: au BufNewFile,BufRead *.sd^I^I^Isetf sd

line 1406: 

line 1407: " SDL

line 1408: au BufNewFile,BufRead *.sdl,*.pr^I^Isetf sdl

line 1409: 

line 1410: " sed

line 1411: au BufNewFile,BufRead *.sed^I^I^Isetf sed

line 1412: 

line 1413: " Sieve (RFC 3028, 5228)

line 1414: au BufNewFile,BufRead *.siv,*.sieve^I^Isetf sieve

line 1415: 

line 1416: " Sendmail

line 1417: au BufNewFile,BufRead sendmail.cf^I^Isetf sm

line 1418: 

line 1419: " Sendmail .mc files are actually m4.  Could also be MS Message text file.

line 1420: au BufNewFile,BufRead *.mc^I^I^Icall dist#ft#McSetf()

line 1421: 

line 1422: " Services

line 1423: au BufNewFile,BufRead */etc/services^I^Isetf services

line 1424: 

line 1425: " Service Location config

line 1426: au BufNewFile,BufRead */etc/slp.conf^I^Isetf slpconf

line 1427: 

line 1428: " Service Location registration

line 1429: au BufNewFile,BufRead */etc/slp.reg^I^Isetf slpreg

line 1430: 

line 1431: " Service Location SPI

line 1432: au BufNewFile,BufRead */etc/slp.spi^I^Isetf slpspi

line 1433: 

line 1434: " Setserial config

line 1435: au BufNewFile,BufRead */etc/serial.conf^I^Isetf setserial

line 1436: 

line 1437: " SGML

line 1447: au BufNewFile,BufRead *.sgm,*.sgml if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |   setf sgmllnx | elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |   let b:docbk_type = "sgml" |   let b:docbk_ver = 4 |   setf docbk | else |   setf sgml | endif

line 1448: 

line 1449: " SGMLDECL

line 1453: au BufNewFile,BufRead *.decl,*.dcl,*.dec if getline(1).getline(2).getline(3) =~? '^<!SGML' |    setf sgmldecl | endif

line 1454: 

line 1455: " SGML catalog file

line 1456: au BufNewFile,BufRead catalog^I^I^Isetf catalog

line 1457: au BufNewFile,BufRead sgml.catalog*^I^Icall s:StarSetf('catalog')

line 1458: 

line 1459: " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.

line 1460: " Gentoo ebuilds and Arch Linux PKGBUILDs are actually bash scripts

line 1461: au BufNewFile,BufRead .bashrc*,bashrc,bash.bashrc,.bash[_-]profile*,.bash[_-]logout*,.bash[_-]aliases*,bash-fc[-.]*,*.bash,*/{,.}bash[_-]completion{,.d,.sh}{,/*},*.ebuild,*.eclass,PKGBUILD* call dist#ft#SetFileTypeSH("bash")

line 1462: au BufNewFile,BufRead .kshrc*,*.ksh call dist#ft#SetFileTypeSH("ksh")

line 1463: au BufNewFile,BufRead */etc/profile,.profile*,*.sh,*.env call dist#ft#SetFileTypeSH(getline(1))

line 1464: 

line 1465: " Shell script (Arch Linux) or PHP file (Drupal)

line 1471: au BufNewFile,BufRead *.install if getline(1) =~ '<?php' |   setf php | else |   call dist#ft#SetFileTypeSH("bash") | endif

line 1472: 

line 1473: " tcsh scripts

line 1474: au BufNewFile,BufRead .tcshrc*,*.tcsh,tcsh.tcshrc,tcsh.login^Icall dist#ft#SetFileTypeShell("tcsh")

line 1475: 

line 1476: " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)

line 1477: au BufNewFile,BufRead .login*,.cshrc*,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call dist#ft#CSH()

line 1478: 

line 1479: " Z-Shell script

line 1480: au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh

line 1481: au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')

line 1482: au BufNewFile,BufRead *.zsh^I^I^Isetf zsh

line 1483: 

line 1484: " Scheme

line 1485: au BufNewFile,BufRead *.scm,*.ss,*.rkt^I^Isetf scheme

line 1486: 

line 1487: " Screen RC

line 1488: au BufNewFile,BufRead .screenrc,screenrc^Isetf screen

line 1489: 

line 1490: " Simula

line 1491: au BufNewFile,BufRead *.sim^I^I^Isetf simula

line 1492: 

line 1493: " SINDA

line 1494: au BufNewFile,BufRead *.sin,*.s85^I^Isetf sinda

line 1495: 

line 1496: " SiSU

line 1497: au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu

line 1498: au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu

line 1499: 

line 1500: " SKILL

line 1501: au BufNewFile,BufRead *.il,*.ils,*.cdf^I^Isetf skill

line 1502: 

line 1503: " SLRN

line 1504: au BufNewFile,BufRead .slrnrc^I^I^Isetf slrnrc

line 1505: au BufNewFile,BufRead *.score^I^I^Isetf slrnsc

line 1506: 

line 1507: " Smalltalk (and TeX)

line 1508: au BufNewFile,BufRead *.st^I^I^Isetf st

line 1516: au BufNewFile,BufRead *.cls if getline(1) =~ '^%' |  setf tex | elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |  setf rexx | else |  setf st | endif

line 1517: 

line 1518: " Smarty templates

line 1519: au BufNewFile,BufRead *.tpl^I^I^Isetf smarty

line 1520: 

line 1521: " SMIL or XML

line 1527: au BufNewFile,BufRead *.smil if getline(1) =~ '<?\s*xml.*?>' |   setf xml | else |   setf smil | endif

line 1528: 

line 1529: " SMIL or SNMP MIB file

line 1535: au BufNewFile,BufRead *.smi if getline(1) =~ '\<smil\>' |   setf smil | else |   setf mib | endif

line 1536: 

line 1537: " SMITH

line 1538: au BufNewFile,BufRead *.smt,*.smith^I^Isetf smith

line 1539: 

line 1540: " Snobol4 and spitbol

line 1541: au BufNewFile,BufRead *.sno,*.spt^I^Isetf snobol4

line 1542: 

line 1543: " SNMP MIB files

line 1544: au BufNewFile,BufRead *.mib,*.my^I^Isetf mib

line 1545: 

line 1546: " Snort Configuration

line 1547: au BufNewFile,BufRead *.hog,snort.conf,vision.conf^Isetf hog

line 1548: au BufNewFile,BufRead *.rules^I^I^Icall dist#ft#FTRules()

line 1549: 

line 1550: " Spec (Linux RPM)

line 1551: au BufNewFile,BufRead *.spec^I^I^Isetf spec

line 1552: 

line 1553: " Speedup (AspenTech plant simulator)

line 1554: au BufNewFile,BufRead *.speedup,*.spdata,*.spd^Isetf spup

line 1555: 

line 1556: " Slice

line 1557: au BufNewFile,BufRead *.ice^I^I^Isetf slice

line 1558: 

line 1559: " Spice

line 1560: au BufNewFile,BufRead *.sp,*.spice^I^Isetf spice

line 1561: 

line 1562: " Spyce

line 1563: au BufNewFile,BufRead *.spy,*.spi^I^Isetf spyce

line 1564: 

line 1565: " Squid

line 1566: au BufNewFile,BufRead squid.conf^I^Isetf squid

line 1567: 

line 1568: " SQL for Oracle Designer

line 1569: au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks^Isetf sql

line 1570: 

line 1571: " SQL

line 1572: au BufNewFile,BufRead *.sql^I^I^Icall dist#ft#SQL()

line 1573: 

line 1574: " SQLJ

line 1575: au BufNewFile,BufRead *.sqlj^I^I^Isetf sqlj

line 1576: 

line 1577: " SQR

line 1578: au BufNewFile,BufRead *.sqr,*.sqi^I^Isetf sqr

line 1579: 

line 1580: " OpenSSH configuration

line 1581: au BufNewFile,BufRead ssh_config,*/.ssh/config^Isetf sshconfig

line 1582: 

line 1583: " OpenSSH server configuration

line 1584: au BufNewFile,BufRead sshd_config^I^Isetf sshdconfig

line 1585: 

line 1586: " Stata

line 1587: au BufNewFile,BufRead *.ado,*.do,*.imata,*.mata^Isetf stata

line 1588: " Also *.class, but not when it's a Java bytecode file

line 1590: au BufNewFile,BufRead *.class if getline(1) !~ "^\xca\xfe\xba\xbe" | setf stata | endif

line 1591: 

line 1592: " SMCL

line 1593: au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl^Isetf smcl

line 1594: 

line 1595: " Stored Procedures

line 1596: au BufNewFile,BufRead *.stp^I^I^Isetf stp

line 1597: 

line 1598: " Standard ML

line 1599: au BufNewFile,BufRead *.sml^I^I^Isetf sml

line 1600: 

line 1601: " Sratus VOS command macro

line 1602: au BufNewFile,BufRead *.cm^I^I^Isetf voscm

line 1603: 

line 1604: " Sysctl

line 1605: au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf^Isetf sysctl

line 1606: 

line 1607: " Systemd unit files

line 1608: au BufNewFile,BufRead */systemd/*.{automount,mount,path,service,socket,swap,target,timer}^Isetf systemd

line 1609: 

line 1610: " Synopsys Design Constraints

line 1611: au BufNewFile,BufRead *.sdc^I^I^Isetf sdc

line 1612: 

line 1613: " Sudoers

line 1614: au BufNewFile,BufRead */etc/sudoers,sudoers.tmp^Isetf sudoers

line 1615: 

line 1616: " SVG (Scalable Vector Graphics)

line 1617: au BufNewFile,BufRead *.svg^I^I^Isetf svg

line 1618: 

line 1619: " Tads (or Nroff or Perl test file)

line 1621: au BufNewFile,BufRead *.t if !dist#ft#FTnroff() && !dist#ft#FTperl() | setf tads | endif

line 1622: 

line 1623: " Tags

line 1624: au BufNewFile,BufRead tags^I^I^Isetf tags

line 1625: 

line 1626: " TAK

line 1627: au BufNewFile,BufRead *.tak^I^I^Isetf tak

line 1628: 

line 1629: " Task

line 1630: au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata

line 1631: au BufRead,BufNewFile *.task^I^I^Isetf taskedit

line 1632: 

line 1633: " Tcl (JACL too)

line 1634: au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl^Isetf tcl

line 1635: 

line 1636: " TealInfo

line 1637: au BufNewFile,BufRead *.tli^I^I^Isetf tli

line 1638: 

line 1639: " Telix Salt

line 1640: au BufNewFile,BufRead *.slt^I^I^Isetf tsalt

line 1641: 

line 1642: " Tera Term Language

line 1643: au BufRead,BufNewFile *.ttl^I^I^Isetf teraterm

line 1644: 

line 1645: " Terminfo

line 1646: au BufNewFile,BufRead *.ti^I^I^Isetf terminfo

line 1647: 

line 1648: " TeX

line 1649: au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl^Isetf tex

line 1650: au BufNewFile,BufRead *.tex^I^I^Icall dist#ft#FTtex()

line 1651: 

line 1652: " ConTeXt

line 1653: au BufNewFile,BufRead *.mkii,*.mkiv,*.mkvi   setf context

line 1654: 

line 1655: " Texinfo

line 1656: au BufNewFile,BufRead *.texinfo,*.texi,*.txi^Isetf texinfo

line 1657: 

line 1658: " TeX configuration

line 1659: au BufNewFile,BufRead texmf.cnf^I^I^Isetf texmf

line 1660: 

line 1661: " Tidy config

line 1662: au BufNewFile,BufRead .tidyrc,tidyrc^I^Isetf tidy

line 1663: 

line 1664: " TF mud client

line 1665: au BufNewFile,BufRead *.tf,.tfrc,tfrc^I^Isetf tf

line 1666: 

line 1667: " tmux configuration

line 1668: au BufNewFile,BufRead {.,}tmux*.conf^I^Isetf tmux

line 1669: 

line 1670: " TPP - Text Presentation Program

line 1671: au BufNewFile,BufReadPost *.tpp^I^I^Isetf tpp

line 1672: 

line 1673: " Treetop

line 1674: au BufRead,BufNewFile *.treetop^I^I^Isetf treetop

line 1675: 

line 1676: " Trustees

line 1677: au BufNewFile,BufRead trustees.conf^I^Isetf trustees

line 1678: 

line 1679: " TSS - Geometry

line 1680: au BufNewFile,BufReadPost *.tssgm^I^Isetf tssgm

line 1681: 

line 1682: " TSS - Optics

line 1683: au BufNewFile,BufReadPost *.tssop^I^Isetf tssop

line 1684: 

line 1685: " TSS - Command Line (temporary)

line 1686: au BufNewFile,BufReadPost *.tsscl^I^Isetf tsscl

line 1687: 

line 1688: " Tutor mode

line 1689: au BufNewFile,BufReadPost *.tutor^I^Isetf tutor

line 1690: 

line 1691: " TWIG files

line 1692: au BufNewFile,BufReadPost *.twig^I^Isetf twig

line 1693: 

line 1694: " Motif UIT/UIL files

line 1695: au BufNewFile,BufRead *.uit,*.uil^I^Isetf uil

line 1696: 

line 1697: " Udev conf

line 1698: au BufNewFile,BufRead */etc/udev/udev.conf^Isetf udevconf

line 1699: 

line 1700: " Udev permissions

line 1701: au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm

line 1702: "

line 1703: " Udev symlinks config

line 1704: au BufNewFile,BufRead */etc/udev/cdsymlinks.conf^Isetf sh

line 1705: 

line 1706: " UnrealScript

line 1707: au BufNewFile,BufRead *.uc^I^I^Isetf uc

line 1708: 

line 1709: " Updatedb

line 1710: au BufNewFile,BufRead */etc/updatedb.conf^Isetf updatedb

line 1711: 

line 1712: " Upstart (init(8)) config files

line 1713: au BufNewFile,BufRead */usr/share/upstart/*.conf^I       setf upstart

line 1714: au BufNewFile,BufRead */usr/share/upstart/*.override^I       setf upstart

line 1715: au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart

line 1716: au BufNewFile,BufRead */.init/*.conf,*/.init/*.override^I       setf upstart

line 1717: au BufNewFile,BufRead */.config/upstart/*.conf^I^I       setf upstart

line 1718: au BufNewFile,BufRead */.config/upstart/*.override^I       setf upstart

line 1719: 

line 1720: " Vera

line 1721: au BufNewFile,BufRead *.vr,*.vri,*.vrh^I^Isetf vera

line 1722: 

line 1723: " Verilog HDL

line 1724: au BufNewFile,BufRead *.v^I^I^Isetf verilog

line 1725: 

line 1726: " Verilog-AMS HDL

line 1727: au BufNewFile,BufRead *.va,*.vams^I^Isetf verilogams

line 1728: 

line 1729: " SystemVerilog

line 1730: au BufNewFile,BufRead *.sv,*.svh^I^Isetf systemverilog

line 1731: 

line 1732: " VHDL

line 1733: au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl

line 1734: au BufNewFile,BufRead *.vhdl_[0-9]*^I^Icall s:StarSetf('vhdl')

line 1735: 

line 1736: " Vim script

line 1737: au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc^Isetf vim

line 1738: 

line 1739: " Viminfo file

line 1740: au BufNewFile,BufRead .viminfo,_viminfo^I^Isetf viminfo

line 1741: 

line 1742: " Virata Config Script File or Drupal module

line 1748: au BufRead,BufNewFile *.hw,*.module,*.pkg if getline(1) =~ '<?php' |   setf php | else |   setf virata | endif

line 1749: 

line 1750: " Visual Basic (also uses *.bas) or FORM

line 1751: au BufNewFile,BufRead *.frm^I^I^Icall dist#ft#FTVB("form")

line 1752: 

line 1753: " SaxBasic is close to Visual Basic

line 1754: au BufNewFile,BufRead *.sba^I^I^Isetf vb

line 1755: 

line 1756: " Vgrindefs file

line 1757: au BufNewFile,BufRead vgrindefs^I^I^Isetf vgrindefs

line 1758: 

line 1759: " VRML V1.0c

line 1760: au BufNewFile,BufRead *.wrl^I^I^Isetf vrml

line 1761: 

line 1762: " Vroom (vim testing and executable documentation)

line 1763: au BufNewFile,BufRead *.vroom^I^I^Isetf vroom

line 1764: 

line 1765: " Webmacro

line 1766: au BufNewFile,BufRead *.wm^I^I^Isetf webmacro

line 1767: 

line 1768: " WebAssembly

line 1769: au BufNewFile,BufRead *.wast,*.wat^I^Isetf wast

line 1770: 

line 1771: " Wget config

line 1772: au BufNewFile,BufRead .wgetrc,wgetrc^I^Isetf wget

line 1773: 

line 1774: " Website MetaLanguage

line 1775: au BufNewFile,BufRead *.wml^I^I^Isetf wml

line 1776: 

line 1777: " Winbatch

line 1778: au BufNewFile,BufRead *.wbt^I^I^Isetf winbatch

line 1779: 

line 1780: " WSML

line 1781: au BufNewFile,BufRead *.wsml^I^I^Isetf wsml

line 1782: 

line 1783: " WPL

line 1784: au BufNewFile,BufRead *.wpl^I^I^Isetf xml

line 1785: 

line 1786: " WvDial

line 1787: au BufNewFile,BufRead wvdial.conf,.wvdialrc^Isetf wvdial

line 1788: 

line 1789: " CVS RC file

line 1790: au BufNewFile,BufRead .cvsrc^I^I^Isetf cvsrc

line 1791: 

line 1792: " CVS commit file

line 1793: au BufNewFile,BufRead cvs\d\+^I^I^Isetf cvs

line 1794: 

line 1795: " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment

line 1796: " lines in a WEB file).

line 1802: au BufNewFile,BufRead *.web if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |   setf web | else |   setf winbatch | endif

line 1803: 

line 1804: " Windows Scripting Host and Windows Script Component

line 1805: au BufNewFile,BufRead *.ws[fc]^I^I^Isetf wsh

line 1806: 

line 1807: " XHTML

line 1808: au BufNewFile,BufRead *.xhtml,*.xht^I^Isetf xhtml

line 1809: 

line 1810: " X Pixmap (dynamically sets colors, use BufEnter to make it work better)

line 1816: au BufEnter *.xpm if getline(1) =~ "XPM2" |   setf xpm2 | else |   setf xpm | endif

line 1817: au BufEnter *.xpm2^I^I^I^Isetf xpm2

line 1818: 

line 1819: " XFree86 config

line 1824: au BufNewFile,BufRead XF86Config if getline(1) =~ '\<XConfigurator\>' |   let b:xf86conf_xfree86_version = 3 | endif | setf xf86conf

line 1827: au BufNewFile,BufRead */xorg.conf.d/*.conf let b:xf86conf_xfree86_version = 4 | setf xf86conf

line 1828: 

line 1829: " Xorg config

line 1830: au BufNewFile,BufRead xorg.conf,xorg.conf-4^Ilet b:xf86conf_xfree86_version = 4 | setf xf86conf

line 1831: 

line 1832: " Xinetd conf

line 1833: au BufNewFile,BufRead */etc/xinetd.conf^I^Isetf xinetd

line 1834: 

line 1835: " XS Perl extension interface language

line 1836: au BufNewFile,BufRead *.xs^I^I^Isetf xs

line 1837: 

line 1838: " X resources file

line 1839: au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults

line 1840: 

line 1841: " Xmath

line 1842: au BufNewFile,BufRead *.msc,*.msf^I^Isetf xmath

line 1844: au BufNewFile,BufRead *.ms if !dist#ft#FTnroff() | setf xmath | endif

line 1845: 

line 1846: " XML  specific variants: docbk and xbl

line 1847: au BufNewFile,BufRead *.xml^I^I^Icall dist#ft#FTxml()

line 1848: 

line 1849: " XMI (holding UML models) is also XML

line 1850: au BufNewFile,BufRead *.xmi^I^I^Isetf xml

line 1851: 

line 1852: " CSPROJ files are Visual Studio.NET's XML-based project config files

line 1853: au BufNewFile,BufRead *.csproj,*.csproj.user^Isetf xml

line 1854: 

line 1855: " Qt Linguist translation source and Qt User Interface Files are XML

line 1856: au BufNewFile,BufRead *.ts,*.ui^I^I^Isetf xml

line 1857: 

line 1858: " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)

line 1859: au BufNewFile,BufRead *.tpm^I^I^Isetf xml

line 1860: 

line 1861: " Xdg menus

line 1862: au BufNewFile,BufRead */etc/xdg/menus/*.menu^Isetf xml

line 1863: 

line 1864: " ATI graphics driver configuration

line 1865: au BufNewFile,BufRead fglrxrc^I^I^Isetf xml

line 1866: 

line 1867: " Web Services Description Language (WSDL)

line 1868: au BufNewFile,BufRead *.wsdl^I^I^Isetf xml

line 1869: 

line 1870: " XLIFF (XML Localisation Interchange File Format) is also XML

line 1871: au BufNewFile,BufRead *.xlf^I^I^Isetf xml

line 1872: au BufNewFile,BufRead *.xliff^I^I^Isetf xml

line 1873: 

line 1874: " XML User Interface Language

line 1875: au BufNewFile,BufRead *.xul^I^I^Isetf xml

line 1876: 

line 1877: " X11 xmodmap (also see below)

line 1878: au BufNewFile,BufRead *Xmodmap^I^I^Isetf xmodmap

line 1879: 

line 1880: " Xquery

line 1881: au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy^Isetf xquery

line 1882: 

line 1883: " XSD

line 1884: au BufNewFile,BufRead *.xsd^I^I^Isetf xsd

line 1885: 

line 1886: " Xslt

line 1887: au BufNewFile,BufRead *.xsl,*.xslt^I^Isetf xslt

line 1888: 

line 1889: " Yacc

line 1890: au BufNewFile,BufRead *.yy,*.yxx,*.y++^I^Isetf yacc

line 1891: 

line 1892: " Yacc or racc

line 1893: au BufNewFile,BufRead *.y^I^I^Icall dist#ft#FTy()

line 1894: 

line 1895: " Yaml

line 1896: au BufNewFile,BufRead *.yaml,*.yml^I^Isetf yaml

line 1897: 

line 1898: " Raml

line 1899: au BufNewFile,BufRead *.raml^I^I^Isetf raml

line 1900: 

line 1901: " yum conf (close enough to dosini)

line 1902: au BufNewFile,BufRead */etc/yum.conf^I^Isetf dosini

line 1903: 

line 1904: " Zimbu

line 1905: au BufNewFile,BufRead *.zu^I^I^Isetf zimbu

line 1906: " Zimbu Templates

line 1907: au BufNewFile,BufRead *.zut^I^I^Isetf zimbutempl

line 1908: 

line 1909: " Zope

line 1910: "   dtml (zope dynamic template markup language), pt (zope page template),

line 1911: "   cpt (zope form controller page template)

line 1912: au BufNewFile,BufRead *.dtml,*.pt,*.cpt^I^Icall dist#ft#FThtml()

line 1913: "   zsql (zope sql method)

line 1914: au BufNewFile,BufRead *.zsql^I^I^Icall dist#ft#SQL()

line 1915: 

line 1916: " Z80 assembler asz80

line 1917: au BufNewFile,BufRead *.z8a^I^I^Isetf z8a

line 1918: 

line 1919: augroup END

line 1920: 

line 1921: 

line 1922: " Source the user-specified filetype file, for backwards compatibility with

line 1923: " Vim 5.x.

line 1924: if exists("myfiletypefile") && filereadable(expand(myfiletypefile))

line 1925:   execute "source " . myfiletypefile

line 1926: endif

line 1927: 

line 1928: 

line 1929: " Check for "*" after loading myfiletypefile, so that scripts.vim is only used

line 1930: " when there are no matching file name extensions.

line 1931: " Don't do this for compressed files.

line 1932: augroup filetypedetect

line 1935: au BufNewFile,BufRead * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif

line 1936: au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif

line 1937: 

line 1938: 

line 1939: " Extra checks for when no filetype has been detected now.  Mostly used for

line 1940: " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim

line 1941: " script file.

line 1942: " Most of these should call s:StarSetf() to avoid names ending in .gz and the

line 1943: " like are used.

line 1944: 

line 1945: " More Apache style config files

line 1946: au BufNewFile,BufRead */etc/proftpd/*.conf*,*/etc/proftpd/conf.*/*^Icall s:StarSetf('apachestyle')

line 1947: 

line 1948: " More Apache config files

line 1949: au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*^Icall s:StarSetf('apache')

line 1950: au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.d/*.conf*^I^Icall s:StarSetf('apache')

line 1951: 

line 1952: " Asterisk config file

line 1953: au BufNewFile,BufRead *asterisk/*.conf*^I^Icall s:StarSetf('asterisk')

line 1954: au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')

line 1955: 

line 1956: " Bazaar version control

line 1957: au BufNewFile,BufRead bzr_log.*^I^I^Isetf bzr

line 1958: 

line 1959: " Bazel build file

line 1960: if !has("fname_case")

line 1961:   au BufNewFile,BufRead BUILD^I^I^Isetf bzl

line 1962: endif

line 1963: 

line 1964: " BIND zone

line 1965: au BufNewFile,BufRead */named/db.*,*/bind/db.*^Icall s:StarSetf('bindzone')

line 1966: 

line 1967: " Calendar

line 1970: au BufNewFile,BufRead */.calendar/*,*/share/calendar/*/calendar.*,*/share/calendar/calendar.*^I^I^I^I^Icall s:StarSetf('calendar')

line 1971: 

line 1972: " Changelog

line 1978: au BufNewFile,BufRead [cC]hange[lL]og* if getline(1) =~ '; urgency='|  call s:StarSetf('debchangelog')|else|  call s:StarSetf('changelog')|endif

line 1979: 

line 1980: " Crontab

line 1981: au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*^I^Icall s:StarSetf('crontab')

line 1982: 

line 1983: " dnsmasq(8) configuration

line 1984: au BufNewFile,BufRead */etc/dnsmasq.d/*^I^Icall s:StarSetf('dnsmasq')

line 1985: 

line 1986: " Dracula

line 1987: au BufNewFile,BufRead drac.*^I^I^Icall s:StarSetf('dracula')

line 1988: 

line 1989: " Fvwm

line 1990: au BufNewFile,BufRead */.fvwm/*^I^I^Icall s:StarSetf('fvwm')

line 1992: au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook let b:fvwm_version = 1 | call s:StarSetf('fvwm')

line 1998: au BufNewFile,BufRead *fvwm2rc* if expand("<afile>:e") == "m4"|  call s:StarSetf('fvwm2m4')|else|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')|endif

line 1999: 

line 2000: " Gedcom

line 2001: au BufNewFile,BufRead */tmp/lltmp*^I^Icall s:StarSetf('gedcom')

line 2002: 

line 2003: " GTK RC

line 2004: au BufNewFile,BufRead .gtkrc*,gtkrc*^I^Icall s:StarSetf('gtkrc')

line 2005: 

line 2006: " Jam

line 2007: au BufNewFile,BufRead Prl*.*,JAM*.*^I^Icall s:StarSetf('jam')

line 2008: 

line 2009: " Jargon

line 2013: au! BufNewFile,BufRead *jarg* if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'|  call s:StarSetf('jargon')|endif

line 2014: 

line 2015: " Kconfig

line 2016: au BufNewFile,BufRead Kconfig.*^I^I^Icall s:StarSetf('kconfig')

line 2017: 

line 2018: " Lilo: Linux loader

line 2019: au BufNewFile,BufRead lilo.conf*^I^Icall s:StarSetf('lilo')

line 2020: 

line 2021: " Logcheck

line 2022: au BufNewFile,BufRead */etc/logcheck/*.d*/*^Icall s:StarSetf('logcheck')

line 2023: 

line 2024: " Makefile

line 2025: au BufNewFile,BufRead [mM]akefile*^I^Icall s:StarSetf('make')

line 2026: 

line 2027: " Ruby Makefile

line 2028: au BufNewFile,BufRead [rR]akefile*^I^Icall s:StarSetf('ruby')

line 2029: 

line 2030: " Mail (also matches muttrc.vim, so this is below the other checks)

line 2031: au BufNewFile,BufRead {neo,}mutt[[:alnum:]._-]\\\{6\}^Isetf mail

line 2032: 

line 2033: au BufNewFile,BufRead reportbug-*^I^Icall s:StarSetf('mail')

line 2034: 

line 2035: " Modconf

line 2039: au BufNewFile,BufRead */etc/modutils/* if executable(expand("<afile>")) != 1|  call s:StarSetf('modconf')|endif

line 2040: au BufNewFile,BufRead */etc/modprobe.*^I^Icall s:StarSetf('modconf')

line 2041: 

line 2042: " Mutt setup file

line 2043: au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*^Icall s:StarSetf('muttrc')

line 2044: au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*^I^Icall s:StarSetf('muttrc')

line 2045: 

line 2046: " Neomutt setup file

line 2047: au BufNewFile,BufRead .neomuttrc*,*/.neomutt/neomuttrc*^Icall s:StarSetf('neomuttrc')

line 2048: au BufNewFile,BufRead neomuttrc*,Neomuttrc*^I^Icall s:StarSetf('neomuttrc')

line 2049: 

line 2050: " Nroff macros

line 2051: au BufNewFile,BufRead tmac.*^I^I^Icall s:StarSetf('nroff')

line 2052: 

line 2053: " OpenBSD hostname.if

line 2054: au BufNewFile,BufRead /etc/hostname.*^I^Icall s:StarSetf('config')

line 2055: 

line 2056: " Pam conf

line 2057: au BufNewFile,BufRead */etc/pam.d/*^I^Icall s:StarSetf('pamconf')

line 2058: 

line 2059: " Printcap and Termcap

line 2063: au BufNewFile,BufRead *printcap* if !did_filetype()|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')|endif

line 2067: au BufNewFile,BufRead *termcap* if !did_filetype()|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')|endif

line 2068: 

line 2069: " ReDIF

line 2070: " Only used when the .rdf file was not detected to be XML.

line 2071: au BufRead,BufNewFile *.rdf^I^I^Icall dist#ft#Redif()

line 2072: 

line 2073: " Remind

line 2074: au BufNewFile,BufRead .reminders*^I^Icall s:StarSetf('remind')

line 2075: 

line 2076: " Vim script

line 2077: au BufNewFile,BufRead *vimrc*^I^I^Icall s:StarSetf('vim')

line 2078: 

line 2079: " Subversion commit file

line 2080: au BufNewFile,BufRead svn-commit*.tmp^I^Isetf svn

line 2081: 

line 2082: " X resources file

line 2083: au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')

line 2084: 

line 2085: " XFree86 config

line 2087: au BufNewFile,BufRead XF86Config-4* let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')

line 2092: au BufNewFile,BufRead XF86Config* if getline(1) =~ '\<XConfigurator\>'|  let b:xf86conf_xfree86_version = 3|endif|call s:StarSetf('xf86conf')

line 2093: 

line 2094: " X11 xmodmap

line 2095: au BufNewFile,BufRead *xmodmap*^I^I^Icall s:StarSetf('xmodmap')

line 2096: 

line 2097: " Xinetd conf

line 2098: au BufNewFile,BufRead */etc/xinetd.d/*^I^Icall s:StarSetf('xinetd')

line 2099: 

line 2100: " yum conf (close enough to dosini)

line 2101: au BufNewFile,BufRead */etc/yum.repos.d/*^Icall s:StarSetf('dosini')

line 2102: 

line 2103: " Z-Shell script

line 2104: au BufNewFile,BufRead zsh*,zlog*^I^Icall s:StarSetf('zsh')

line 2105: 

line 2106: 

line 2107: " Plain text files, needs to be far down to not override others.  This avoids

line 2108: " the "conf" type being used if there is a line starting with '#'.

line 2109: au BufNewFile,BufRead *.text,README setf text

line 2110: 

line 2111: " Help files match *.txt but should have a last line that is a modeline. 

line 2115: au BufNewFile,BufRead *.txt  if getline('$') !~ 'vim:.*ft=help'|   setf text| endif       

line 2116: 

line 2117: " Use the filetype detect plugins.  They may overrule any of the previously

line 2118: " detected filetypes.

line 2119: runtime! ftdetect/*.vim

Searching for "ftdetect/*.vim" in "/home/reggiemarr/.config/nvim,/home/reggiemarr/.vim/plugged/LanguageClient-neovim,/home/reggiemarr/.vim/plugged/ncm2,/home/reggiemarr/.vim/plugged/nvim-yarp,/home/reggiemarr/.vim/plugged/ncm2-bufword,/home/reggiemarr/.vim/plugged/ncm2-path,/home/reggiemarr/.vim/plugged/fzf,/home/reggiemarr/.vim/plugged/nerdcommenter,/etc/xdg/xdg-i3/nvim,/etc/xdg/nvim,/home/reggiemarr/.local/share/nvim/site,/usr/share/i3/nvim/site,/usr/local/share/nvim/site,/usr/share/nvim/site,/var/lib/snapd/desktop/nvim/site,/usr/share/nvim/runtime,/var/lib/snapd/desktop/nvim/site/after,/usr/share/nvim/site/after,/usr/local/share/nvim/site/after,/usr/share/i3/nvim/site/after,/home/reggiemarr/.local/share/nvim/site/after,/etc/xdg/nvim/after,/etc/xdg/xdg-i3/nvim/after,/home/reggiemarr/.config/nvim/after"
Searching for "/home/reggiemarr/.config/nvim/ftdetect/*.vim"
Searching for "/home/reggiemarr/.vim/plugged/LanguageClient-neovim/ftdetect/*.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2/ftdetect/*.vim"
Searching for "/home/reggiemarr/.vim/plugged/nvim-yarp/ftdetect/*.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2-bufword/ftdetect/*.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2-path/ftdetect/*.vim"
Searching for "/home/reggiemarr/.vim/plugged/fzf/ftdetect/*.vim"
Searching for "/home/reggiemarr/.vim/plugged/nerdcommenter/ftdetect/*.vim"
Searching for "/etc/xdg/xdg-i3/nvim/ftdetect/*.vim"
Searching for "/etc/xdg/nvim/ftdetect/*.vim"
Searching for "/home/reggiemarr/.local/share/nvim/site/ftdetect/*.vim"
Searching for "/usr/share/i3/nvim/site/ftdetect/*.vim"
Searching for "/usr/local/share/nvim/site/ftdetect/*.vim"
Searching for "/usr/share/nvim/site/ftdetect/*.vim"
Searching for "/var/lib/snapd/desktop/nvim/site/ftdetect/*.vim"
Searching for "/usr/share/nvim/runtime/ftdetect/*.vim"
Searching for "/var/lib/snapd/desktop/nvim/site/after/ftdetect/*.vim"
Searching for "/usr/share/nvim/site/after/ftdetect/*.vim"
Searching for "/usr/local/share/nvim/site/after/ftdetect/*.vim"
Searching for "/usr/share/i3/nvim/site/after/ftdetect/*.vim"
Searching for "/home/reggiemarr/.local/share/nvim/site/after/ftdetect/*.vim"
Searching for "/etc/xdg/nvim/after/ftdetect/*.vim"
Searching for "/etc/xdg/xdg-i3/nvim/after/ftdetect/*.vim"
Searching for "/home/reggiemarr/.config/nvim/after/ftdetect/*.vim"
not found in 'runtimepath': "ftdetect/*.vim"
line 2120: 

line 2121: " NOTE: The above command could have ended the filetypedetect autocmd group

line 2122: " and started another one. Let's make sure it has ended to get to a consistent

line 2123: " state.

line 2124: augroup END

line 2125: 

line 2126: " Generic configuration file. Use FALLBACK, it's just guessing!

line 2132: au filetypedetect BufNewFile,BufRead,StdinReadPost * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'^I|| getline(4) =~ '^#' || getline(5) =~ '^#') |   setf FALLBACK conf | endif

line 2133: 

line 2134: 

line 2135: " If the GUI is already running, may still need to install the Syntax menu.

line 2136: " Don't do it when the 'M' flag is included in 'guioptions'.

line 2138: if has("menu") && has("gui_running") && !exists("did_install_syntax_menu") && &guioptions !~# "M"

line 2139:   source <sfile>:p:h/menu.vim

line 2140: endif

line 2141: 

line 2142: " Function called for testing all functions defined here.  These are

line 2143: " script-local, thus need to be executed here.

line 2144: " Returns a string with error messages (hopefully empty).

line 2145: func! TestFiletypeFuncs(testlist)

line 2156: 

line 2157: " Restore 'cpoptions'

line 2158: let &cpo = s:cpo_save

line 2159: unlet s:cpo_save

finished sourcing /usr/share/nvim/runtime/filetype.vim
continuing in function plug#end
Searching for "/var/lib/snapd/desktop/nvim/site/after/filetype.vim"
Searching for "/usr/share/nvim/site/after/filetype.vim"
Searching for "/usr/local/share/nvim/site/after/filetype.vim"
Searching for "/usr/share/i3/nvim/site/after/filetype.vim"
Searching for "/home/reggiemarr/.local/share/nvim/site/after/filetype.vim"
Searching for "/etc/xdg/nvim/after/filetype.vim"
Searching for "/etc/xdg/xdg-i3/nvim/after/filetype.vim"
Searching for "/home/reggiemarr/.config/nvim/after/filetype.vim"
Searching for "ftplugin.vim" in "/home/reggiemarr/.config/nvim,/home/reggiemarr/.vim/plugged/LanguageClient-neovim,/home/reggiemarr/.vim/plugged/ncm2,/home/reggiemarr/.vim/plugged/nvim-yarp,/home/reggiemarr/.vim/plugged/ncm2-bufword,/home/reggiemarr/.vim/plugged/ncm2-path,/home/reggiemarr/.vim/plugged/fzf,/home/reggiemarr/.vim/plugged/nerdcommenter,/etc/xdg/xdg-i3/nvim,/etc/xdg/nvim,/home/reggiemarr/.local/share/nvim/site,/usr/share/i3/nvim/site,/usr/local/share/nvim/site,/usr/share/nvim/site,/var/lib/snapd/desktop/nvim/site,/usr/share/nvim/runtime,/var/lib/snapd/desktop/nvim/site/after,/usr/share/nvim/site/after,/usr/local/share/nvim/site/after,/usr/share/i3/nvim/site/after,/home/reggiemarr/.local/share/nvim/site/after,/etc/xdg/nvim/after,/etc/xdg/xdg-i3/nvim/after,/home/reggiemarr/.config/nvim/after"
Searching for "/home/reggiemarr/.config/nvim/ftplugin.vim"
Searching for "/home/reggiemarr/.vim/plugged/LanguageClient-neovim/ftplugin.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2/ftplugin.vim"
Searching for "/home/reggiemarr/.vim/plugged/nvim-yarp/ftplugin.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2-bufword/ftplugin.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2-path/ftplugin.vim"
Searching for "/home/reggiemarr/.vim/plugged/fzf/ftplugin.vim"
Searching for "/home/reggiemarr/.vim/plugged/nerdcommenter/ftplugin.vim"
Searching for "/etc/xdg/xdg-i3/nvim/ftplugin.vim"
Searching for "/etc/xdg/nvim/ftplugin.vim"
Searching for "/home/reggiemarr/.local/share/nvim/site/ftplugin.vim"
Searching for "/usr/share/i3/nvim/site/ftplugin.vim"
Searching for "/usr/local/share/nvim/site/ftplugin.vim"
Searching for "/usr/share/nvim/site/ftplugin.vim"
Searching for "/var/lib/snapd/desktop/nvim/site/ftplugin.vim"
Searching for "/usr/share/nvim/runtime/ftplugin.vim"
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/usr/share/nvim/runtime)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
line 83: sourcing "/usr/share/nvim/runtime/ftplugin.vim"
line 1: " Vim support file to switch on loading plugins for file types

line 2: "

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>

line 4: " Last change:^I2006 Apr 30

line 5: 

line 6: if exists("did_load_ftplugin")

line 7:   finish

line 8: endif

line 9: let did_load_ftplugin = 1

line 10: 

line 11: augroup filetypeplugin

line 12:   au FileType * call s:LoadFTPlugin()

line 13: 

line 14:   func! s:LoadFTPlugin()

line 35: augroup END

finished sourcing /usr/share/nvim/runtime/ftplugin.vim
continuing in function plug#end
Searching for "/var/lib/snapd/desktop/nvim/site/after/ftplugin.vim"
Searching for "/usr/share/nvim/site/after/ftplugin.vim"
Searching for "/usr/local/share/nvim/site/after/ftplugin.vim"
Searching for "/usr/share/i3/nvim/site/after/ftplugin.vim"
Searching for "/home/reggiemarr/.local/share/nvim/site/after/ftplugin.vim"
Searching for "/etc/xdg/nvim/after/ftplugin.vim"
Searching for "/etc/xdg/xdg-i3/nvim/after/ftplugin.vim"
Searching for "/home/reggiemarr/.config/nvim/after/ftplugin.vim"
Searching for "indent.vim" in "/home/reggiemarr/.config/nvim,/home/reggiemarr/.vim/plugged/LanguageClient-neovim,/home/reggiemarr/.vim/plugged/ncm2,/home/reggiemarr/.vim/plugged/nvim-yarp,/home/reggiemarr/.vim/plugged/ncm2-bufword,/home/reggiemarr/.vim/plugged/ncm2-path,/home/reggiemarr/.vim/plugged/fzf,/home/reggiemarr/.vim/plugged/nerdcommenter,/etc/xdg/xdg-i3/nvim,/etc/xdg/nvim,/home/reggiemarr/.local/share/nvim/site,/usr/share/i3/nvim/site,/usr/local/share/nvim/site,/usr/share/nvim/site,/var/lib/snapd/desktop/nvim/site,/usr/share/nvim/runtime,/var/lib/snapd/desktop/nvim/site/after,/usr/share/nvim/site/after,/usr/local/share/nvim/site/after,/usr/share/i3/nvim/site/after,/home/reggiemarr/.local/share/nvim/site/after,/etc/xdg/nvim/after,/etc/xdg/xdg-i3/nvim/after,/home/reggiemarr/.config/nvim/after"
Searching for "/home/reggiemarr/.config/nvim/indent.vim"
Searching for "/home/reggiemarr/.vim/plugged/LanguageClient-neovim/indent.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2/indent.vim"
Searching for "/home/reggiemarr/.vim/plugged/nvim-yarp/indent.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2-bufword/indent.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2-path/indent.vim"
Searching for "/home/reggiemarr/.vim/plugged/fzf/indent.vim"
Searching for "/home/reggiemarr/.vim/plugged/nerdcommenter/indent.vim"
Searching for "/etc/xdg/xdg-i3/nvim/indent.vim"
Searching for "/etc/xdg/nvim/indent.vim"
Searching for "/home/reggiemarr/.local/share/nvim/site/indent.vim"
Searching for "/usr/share/i3/nvim/site/indent.vim"
Searching for "/usr/local/share/nvim/site/indent.vim"
Searching for "/usr/share/nvim/site/indent.vim"
Searching for "/var/lib/snapd/desktop/nvim/site/indent.vim"
Searching for "/usr/share/nvim/runtime/indent.vim"
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/usr/share/nvim/runtime)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
line 83: sourcing "/usr/share/nvim/runtime/indent.vim"
line 1: " Vim support file to switch on loading indent files for file types

line 2: "

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>

line 4: " Last Change:^I2008 Feb 22

line 5: 

line 6: if exists("did_indent_on")

line 7:   finish

line 8: endif

line 9: let did_indent_on = 1

line 10: 

line 11: augroup filetypeindent

line 12:   au FileType * call s:LoadIndent()

line 13:   func! s:LoadIndent()

line 31: augroup END

finished sourcing /usr/share/nvim/runtime/indent.vim
continuing in function plug#end
Searching for "/var/lib/snapd/desktop/nvim/site/after/indent.vim"
Searching for "/usr/share/nvim/site/after/indent.vim"
Searching for "/usr/local/share/nvim/site/after/indent.vim"
Searching for "/usr/share/i3/nvim/site/after/indent.vim"
Searching for "/home/reggiemarr/.local/share/nvim/site/after/indent.vim"
Searching for "/etc/xdg/nvim/after/indent.vim"
Searching for "/etc/xdg/xdg-i3/nvim/after/indent.vim"
Searching for "/home/reggiemarr/.config/nvim/after/indent.vim"
line 84:   if has('vim_starting')

line 85:     if has('syntax') && !exists('g:syntax_on')

line 86:       syntax enable

line 86: so $VIMRUNTIME/syntax/syntax.vim

chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/usr/share/nvim/runtime/syntax)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
line 86: sourcing "/usr/share/nvim/runtime/syntax/syntax.vim"
line 1: " Vim syntax support file

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>

line 3: " Last Change:^I2001 Sep 04

line 4: 

line 5: " This file is used for ":syntax on".

line 6: " It installs the autocommands and starts highlighting for all buffers.

line 7: 

line 8: if !has("syntax")

line 9:   finish

line 10: endif

line 11: 

line 12: " If Syntax highlighting appears to be on already, turn it off first, so that

line 13: " any leftovers are cleared.

line 14: if exists("syntax_on") || exists("syntax_manual")

line 15:   so <sfile>:p:h/nosyntax.vim

line 16: endif

line 17: 

line 18: " Load the Syntax autocommands and set the default methods for highlighting.

line 19: runtime syntax/synload.vim

Searching for "syntax/synload.vim" in "/home/reggiemarr/.config/nvim,/home/reggiemarr/.vim/plugged/LanguageClient-neovim,/home/reggiemarr/.vim/plugged/ncm2,/home/reggiemarr/.vim/plugged/nvim-yarp,/home/reggiemarr/.vim/plugged/ncm2-bufword,/home/reggiemarr/.vim/plugged/ncm2-path,/home/reggiemarr/.vim/plugged/fzf,/home/reggiemarr/.vim/plugged/nerdcommenter,/etc/xdg/xdg-i3/nvim,/etc/xdg/nvim,/home/reggiemarr/.local/share/nvim/site,/usr/share/i3/nvim/site,/usr/local/share/nvim/site,/usr/share/nvim/site,/var/lib/snapd/desktop/nvim/site,/usr/share/nvim/runtime,/var/lib/snapd/desktop/nvim/site/after,/usr/share/nvim/site/after,/usr/local/share/nvim/site/after,/usr/share/i3/nvim/site/after,/home/reggiemarr/.local/share/nvim/site/after,/etc/xdg/nvim/after,/etc/xdg/xdg-i3/nvim/after,/home/reggiemarr/.config/nvim/after"
Searching for "/home/reggiemarr/.config/nvim/syntax/synload.vim"
Searching for "/home/reggiemarr/.vim/plugged/LanguageClient-neovim/syntax/synload.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2/syntax/synload.vim"
Searching for "/home/reggiemarr/.vim/plugged/nvim-yarp/syntax/synload.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2-bufword/syntax/synload.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2-path/syntax/synload.vim"
Searching for "/home/reggiemarr/.vim/plugged/fzf/syntax/synload.vim"
Searching for "/home/reggiemarr/.vim/plugged/nerdcommenter/syntax/synload.vim"
Searching for "/etc/xdg/xdg-i3/nvim/syntax/synload.vim"
Searching for "/etc/xdg/nvim/syntax/synload.vim"
Searching for "/home/reggiemarr/.local/share/nvim/site/syntax/synload.vim"
Searching for "/usr/share/i3/nvim/site/syntax/synload.vim"
Searching for "/usr/local/share/nvim/site/syntax/synload.vim"
Searching for "/usr/share/nvim/site/syntax/synload.vim"
Searching for "/var/lib/snapd/desktop/nvim/site/syntax/synload.vim"
Searching for "/usr/share/nvim/runtime/syntax/synload.vim"
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/usr/share/nvim/runtime/syntax)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
line 19: sourcing "/usr/share/nvim/runtime/syntax/synload.vim"
line 1: " Vim syntax support file

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>

line 3: " Last Change:^I2016 Nov 04

line 4: 

line 5: " This file sets up for syntax highlighting.

line 6: " It is loaded from "syntax.vim" and "manual.vim".

line 7: " 1. Set the default highlight groups.

line 8: " 2. Install Syntax autocommands for all the available syntax files.

line 9: 

line 10: if !has("syntax")

line 11:   finish

line 12: endif

line 13: 

line 14: " let others know that syntax has been switched on

line 15: let syntax_on = 1

line 16: 

line 17: " Set the default highlighting colors.  Use a color scheme if specified.

line 18: if exists("colors_name")

line 19:   exe "colors " . colors_name

line 20: else

line 21:   runtime! syntax/syncolor.vim

Searching for "syntax/syncolor.vim" in "/home/reggiemarr/.config/nvim,/home/reggiemarr/.vim/plugged/LanguageClient-neovim,/home/reggiemarr/.vim/plugged/ncm2,/home/reggiemarr/.vim/plugged/nvim-yarp,/home/reggiemarr/.vim/plugged/ncm2-bufword,/home/reggiemarr/.vim/plugged/ncm2-path,/home/reggiemarr/.vim/plugged/fzf,/home/reggiemarr/.vim/plugged/nerdcommenter,/etc/xdg/xdg-i3/nvim,/etc/xdg/nvim,/home/reggiemarr/.local/share/nvim/site,/usr/share/i3/nvim/site,/usr/local/share/nvim/site,/usr/share/nvim/site,/var/lib/snapd/desktop/nvim/site,/usr/share/nvim/runtime,/var/lib/snapd/desktop/nvim/site/after,/usr/share/nvim/site/after,/usr/local/share/nvim/site/after,/usr/share/i3/nvim/site/after,/home/reggiemarr/.local/share/nvim/site/after,/etc/xdg/nvim/after,/etc/xdg/xdg-i3/nvim/after,/home/reggiemarr/.config/nvim/after"
Searching for "/home/reggiemarr/.config/nvim/syntax/syncolor.vim"
Searching for "/home/reggiemarr/.vim/plugged/LanguageClient-neovim/syntax/syncolor.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2/syntax/syncolor.vim"
Searching for "/home/reggiemarr/.vim/plugged/nvim-yarp/syntax/syncolor.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2-bufword/syntax/syncolor.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2-path/syntax/syncolor.vim"
Searching for "/home/reggiemarr/.vim/plugged/fzf/syntax/syncolor.vim"
Searching for "/home/reggiemarr/.vim/plugged/nerdcommenter/syntax/syncolor.vim"
Searching for "/etc/xdg/xdg-i3/nvim/syntax/syncolor.vim"
Searching for "/etc/xdg/nvim/syntax/syncolor.vim"
Searching for "/home/reggiemarr/.local/share/nvim/site/syntax/syncolor.vim"
Searching for "/usr/share/i3/nvim/site/syntax/syncolor.vim"
Searching for "/usr/local/share/nvim/site/syntax/syncolor.vim"
Searching for "/usr/share/nvim/site/syntax/syncolor.vim"
Searching for "/var/lib/snapd/desktop/nvim/site/syntax/syncolor.vim"
Searching for "/usr/share/nvim/runtime/syntax/syncolor.vim"
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/usr/share/nvim/runtime/syntax)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
line 21: sourcing "/usr/share/nvim/runtime/syntax/syncolor.vim"
line 1: " Vim syntax support file

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>

line 3: " Last Change:^I2001 Sep 12

line 4: 

line 5: " This file sets up the default methods for highlighting.

line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".

line 7: " Also used from init_highlight().

line 8: 

line 9: if !exists("syntax_cmd") || syntax_cmd == "on"

line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links

line 11:   command -nargs=* SynColor hi <args>

line 12:   command -nargs=* SynLink hi link <args>

line 13: else

line 14:   if syntax_cmd == "enable"

line 15:     " ":syntax enable" keeps any existing colors

line 16:     command -nargs=* SynColor hi def <args>

line 17:     command -nargs=* SynLink hi def link <args>

line 18:   elseif syntax_cmd == "reset"

line 19:     " ":syntax reset" resets all colors to the default

line 20:     command -nargs=* SynColor hi <args>

line 21:     command -nargs=* SynLink hi! link <args>

line 22:   else

line 23:     " User defined syncolor file has already set the colors.

line 24:     finish

line 25:   endif

line 26: endif

line 27: 

line 28: " Many terminals can only use six different colors (plus black and white).

line 29: " Therefore the number of colors used is kept low. It doesn't look nice with

line 30: " too many colors anyway.

line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.

line 32: " There are two sets of defaults: for a dark and a light background.

line 33: if &background == "dark"

line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE

line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE

line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE

line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE

line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE

line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE

line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE

line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE

line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE

line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE

line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE

line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE

line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE

line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE

line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff

line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff

line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE

line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE

line 43: else

line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE

line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE

line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE

line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE

line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE

line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE

line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE

line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue

line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE

line 53: endif

line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red

line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red

line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow

line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow

line 56: 

line 57: " Common groups that link to default highlighting.

line 58: " You can specify other highlighting easily.

line 59: SynLink String^I^IConstant

line 59: hi link String^I^IConstant

line 60: SynLink Character^IConstant

line 60: hi link Character^IConstant

line 61: SynLink Number^I^IConstant

line 61: hi link Number^I^IConstant

line 62: SynLink Boolean^I^IConstant

line 62: hi link Boolean^I^IConstant

line 63: SynLink Float^I^INumber

line 63: hi link Float^I^INumber

line 64: SynLink Function^IIdentifier

line 64: hi link Function^IIdentifier

line 65: SynLink Conditional^IStatement

line 65: hi link Conditional^IStatement

line 66: SynLink Repeat^I^IStatement

line 66: hi link Repeat^I^IStatement

line 67: SynLink Label^I^IStatement

line 67: hi link Label^I^IStatement

line 68: SynLink Operator^IStatement

line 68: hi link Operator^IStatement

line 69: SynLink Keyword^I^IStatement

line 69: hi link Keyword^I^IStatement

line 70: SynLink Exception^IStatement

line 70: hi link Exception^IStatement

line 71: SynLink Include^I^IPreProc

line 71: hi link Include^I^IPreProc

line 72: SynLink Define^I^IPreProc

line 72: hi link Define^I^IPreProc

line 73: SynLink Macro^I^IPreProc

line 73: hi link Macro^I^IPreProc

line 74: SynLink PreCondit^IPreProc

line 74: hi link PreCondit^IPreProc

line 75: SynLink StorageClass^IType

line 75: hi link StorageClass^IType

line 76: SynLink Structure^IType

line 76: hi link Structure^IType

line 77: SynLink Typedef^I^IType

line 77: hi link Typedef^I^IType

line 78: SynLink Tag^I^ISpecial

line 78: hi link Tag^I^ISpecial

line 79: SynLink SpecialChar^ISpecial

line 79: hi link SpecialChar^ISpecial

line 80: SynLink Delimiter^ISpecial

line 80: hi link Delimiter^ISpecial

line 81: SynLink SpecialComment^ISpecial

line 81: hi link SpecialComment^ISpecial

line 82: SynLink Debug^I^ISpecial

line 82: hi link Debug^I^ISpecial

line 83: 

line 84: delcommand SynColor

line 85: delcommand SynLink

finished sourcing /usr/share/nvim/runtime/syntax/syncolor.vim
continuing in /usr/share/nvim/runtime/syntax/synload.vim
Searching for "/var/lib/snapd/desktop/nvim/site/after/syntax/syncolor.vim"
Searching for "/usr/share/nvim/site/after/syntax/syncolor.vim"
Searching for "/usr/local/share/nvim/site/after/syntax/syncolor.vim"
Searching for "/usr/share/i3/nvim/site/after/syntax/syncolor.vim"
Searching for "/home/reggiemarr/.local/share/nvim/site/after/syntax/syncolor.vim"
Searching for "/etc/xdg/nvim/after/syntax/syncolor.vim"
Searching for "/etc/xdg/xdg-i3/nvim/after/syntax/syncolor.vim"
Searching for "/home/reggiemarr/.config/nvim/after/syntax/syncolor.vim"
line 22: endif

line 23: 

line 24: " Line continuation is used here, remove 'C' from 'cpoptions'

line 25: let s:cpo_save = &cpo

line 26: set cpo&vim

line 27: 

line 28: " First remove all old syntax autocommands.

line 29: au! Syntax

line 30: 

line 31: au Syntax *^I^Icall s:SynSet()

line 32: 

line 33: fun! s:SynSet()

line 61: 

line 62: 

line 63: " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)

line 68: au Syntax c,cpp,cs,idl,java,php,datascript if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif

line 69: 

line 70: 

line 71: " Source the user-specified syntax highlighting file

line 72: if exists("mysyntaxfile")

line 73:   let s:fname = expand(mysyntaxfile)

line 74:   if filereadable(s:fname)

line 75:     execute "source " . fnameescape(s:fname)

line 76:   endif

line 77: endif

line 78: 

line 79: " Restore 'cpoptions'

line 80: let &cpo = s:cpo_save

line 81: unlet s:cpo_save

finished sourcing /usr/share/nvim/runtime/syntax/synload.vim
continuing in /usr/share/nvim/runtime/syntax/syntax.vim
line 20: 

line 21: " Load the FileType autocommands if not done yet.

line 22: if exists("did_load_filetypes")

line 23:   let s:did_ft = 1

line 24: else

line 25:   filetype on

line 26:   let s:did_ft = 0

line 27: endif

line 28: 

line 29: " Set up the connection between FileType and Syntax autocommands.

line 30: " This makes the syntax automatically set when the file type is detected.

line 31: augroup syntaxset

line 32:   au! FileType *^Iexe "set syntax=" . expand("<amatch>")

line 33: augroup END

line 34: 

line 35: 

line 36: " Execute the syntax autocommands for the each buffer.

line 37: " If the filetype wasn't detected yet, do that now.

line 38: " Always do the syntaxset autocommands, for buffers where the 'filetype'

line 39: " already was set manually (e.g., help buffers).

line 40: doautoall syntaxset FileType

line 41: if !s:did_ft

line 42:   doautoall filetypedetect BufRead

line 43: endif

finished sourcing /usr/share/nvim/runtime/syntax/syntax.vim
continuing in function plug#end
line 87:     end

line 88:   else

line 89:     call s:reload_plugins()

line 90:   endif

function plug#end returning #0

continuing in /home/reggiemarr/.config/nvim/init.vim

line 37: 

line 38: " Open files in vertical horizontal split

line 42: nnoremap <silent> <C-g> :call fzf#run({   'right': winwidth('.') / 2,   'sink':  'vertical botright split',   'height': '40%'})<CR>

line 43: nnoremap <C-p> :Files<Cr>

line 44: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

line 45: " For Nerdcommenter

line 46: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

line 47: filetype plugin on

Searching for "filetype.vim" in "/home/reggiemarr/.config/nvim,/home/reggiemarr/.vim/plugged/LanguageClient-neovim,/home/reggiemarr/.vim/plugged/ncm2,/home/reggiemarr/.vim/plugged/nvim-yarp,/home/reggiemarr/.vim/plugged/ncm2-bufword,/home/reggiemarr/.vim/plugged/ncm2-path,/home/reggiemarr/.vim/plugged/fzf,/home/reggiemarr/.vim/plugged/nerdcommenter,/etc/xdg/xdg-i3/nvim,/etc/xdg/nvim,/home/reggiemarr/.local/share/nvim/site,/usr/share/i3/nvim/site,/usr/local/share/nvim/site,/usr/share/nvim/site,/var/lib/snapd/desktop/nvim/site,/usr/share/nvim/runtime,/var/lib/snapd/desktop/nvim/site/after,/usr/share/nvim/site/after,/usr/local/share/nvim/site/after,/usr/share/i3/nvim/site/after,/home/reggiemarr/.local/share/nvim/site/after,/etc/xdg/nvim/after,/etc/xdg/xdg-i3/nvim/after,/home/reggiemarr/.config/nvim/after"
Searching for "/home/reggiemarr/.config/nvim/filetype.vim"
Searching for "/home/reggiemarr/.vim/plugged/LanguageClient-neovim/filetype.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2/filetype.vim"
Searching for "/home/reggiemarr/.vim/plugged/nvim-yarp/filetype.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2-bufword/filetype.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2-path/filetype.vim"
Searching for "/home/reggiemarr/.vim/plugged/fzf/filetype.vim"
Searching for "/home/reggiemarr/.vim/plugged/nerdcommenter/filetype.vim"
Searching for "/etc/xdg/xdg-i3/nvim/filetype.vim"
Searching for "/etc/xdg/nvim/filetype.vim"
Searching for "/home/reggiemarr/.local/share/nvim/site/filetype.vim"
Searching for "/usr/share/i3/nvim/site/filetype.vim"
Searching for "/usr/local/share/nvim/site/filetype.vim"
Searching for "/usr/share/nvim/site/filetype.vim"
Searching for "/var/lib/snapd/desktop/nvim/site/filetype.vim"
Searching for "/usr/share/nvim/runtime/filetype.vim"
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/usr/share/nvim/runtime)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
line 47: sourcing "/usr/share/nvim/runtime/filetype.vim"
line 1: " Vim support file to detect file types

line 2: "

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>

line 4: " Last Change:^I2018 Feb 14

line 5: 

line 6: " Listen very carefully, I will say this only once

line 7: if exists("did_load_filetypes")

line 8:   finish

finished sourcing /usr/share/nvim/runtime/filetype.vim
continuing in /home/reggiemarr/.config/nvim/init.vim
Searching for "/var/lib/snapd/desktop/nvim/site/after/filetype.vim"
Searching for "/usr/share/nvim/site/after/filetype.vim"
Searching for "/usr/local/share/nvim/site/after/filetype.vim"
Searching for "/usr/share/i3/nvim/site/after/filetype.vim"
Searching for "/home/reggiemarr/.local/share/nvim/site/after/filetype.vim"
Searching for "/etc/xdg/nvim/after/filetype.vim"
Searching for "/etc/xdg/xdg-i3/nvim/after/filetype.vim"
Searching for "/home/reggiemarr/.config/nvim/after/filetype.vim"
Searching for "ftplugin.vim" in "/home/reggiemarr/.config/nvim,/home/reggiemarr/.vim/plugged/LanguageClient-neovim,/home/reggiemarr/.vim/plugged/ncm2,/home/reggiemarr/.vim/plugged/nvim-yarp,/home/reggiemarr/.vim/plugged/ncm2-bufword,/home/reggiemarr/.vim/plugged/ncm2-path,/home/reggiemarr/.vim/plugged/fzf,/home/reggiemarr/.vim/plugged/nerdcommenter,/etc/xdg/xdg-i3/nvim,/etc/xdg/nvim,/home/reggiemarr/.local/share/nvim/site,/usr/share/i3/nvim/site,/usr/local/share/nvim/site,/usr/share/nvim/site,/var/lib/snapd/desktop/nvim/site,/usr/share/nvim/runtime,/var/lib/snapd/desktop/nvim/site/after,/usr/share/nvim/site/after,/usr/local/share/nvim/site/after,/usr/share/i3/nvim/site/after,/home/reggiemarr/.local/share/nvim/site/after,/etc/xdg/nvim/after,/etc/xdg/xdg-i3/nvim/after,/home/reggiemarr/.config/nvim/after"
Searching for "/home/reggiemarr/.config/nvim/ftplugin.vim"
Searching for "/home/reggiemarr/.vim/plugged/LanguageClient-neovim/ftplugin.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2/ftplugin.vim"
Searching for "/home/reggiemarr/.vim/plugged/nvim-yarp/ftplugin.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2-bufword/ftplugin.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2-path/ftplugin.vim"
Searching for "/home/reggiemarr/.vim/plugged/fzf/ftplugin.vim"
Searching for "/home/reggiemarr/.vim/plugged/nerdcommenter/ftplugin.vim"
Searching for "/etc/xdg/xdg-i3/nvim/ftplugin.vim"
Searching for "/etc/xdg/nvim/ftplugin.vim"
Searching for "/home/reggiemarr/.local/share/nvim/site/ftplugin.vim"
Searching for "/usr/share/i3/nvim/site/ftplugin.vim"
Searching for "/usr/local/share/nvim/site/ftplugin.vim"
Searching for "/usr/share/nvim/site/ftplugin.vim"
Searching for "/var/lib/snapd/desktop/nvim/site/ftplugin.vim"
Searching for "/usr/share/nvim/runtime/ftplugin.vim"
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/usr/share/nvim/runtime)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
line 47: sourcing "/usr/share/nvim/runtime/ftplugin.vim"
line 1: " Vim support file to switch on loading plugins for file types

line 2: "

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>

line 4: " Last change:^I2006 Apr 30

line 5: 

line 6: if exists("did_load_ftplugin")

line 7:   finish

finished sourcing /usr/share/nvim/runtime/ftplugin.vim
continuing in /home/reggiemarr/.config/nvim/init.vim
Searching for "/var/lib/snapd/desktop/nvim/site/after/ftplugin.vim"
Searching for "/usr/share/nvim/site/after/ftplugin.vim"
Searching for "/usr/local/share/nvim/site/after/ftplugin.vim"
Searching for "/usr/share/i3/nvim/site/after/ftplugin.vim"
Searching for "/home/reggiemarr/.local/share/nvim/site/after/ftplugin.vim"
Searching for "/etc/xdg/nvim/after/ftplugin.vim"
Searching for "/etc/xdg/xdg-i3/nvim/after/ftplugin.vim"
Searching for "/home/reggiemarr/.config/nvim/after/ftplugin.vim"
line 48: " Add spaces after comment delimiters by default

line 49: "let g:NERDSpaceDelims = 1

line 50: 

line 51: " Use compact syntax for prettified multi-line comments

line 52: let g:NERDCompactSexyComs = 1

line 53: 

line 54: " Align line-wise comment delimiters flush left instead of following code indentation

line 55: let g:NERDDefaultAlign = 'left'

line 56: 

line 57: " Set a language to use its alternate delimiters by default

line 58: let g:NERDAltDelims_java = 1

line 59: 

line 60: " Add your own custom formats or override the defaults

line 61: let g:NERDCustomDelimiters = { 'c': { 'left': '/**','right': '*/' } }

line 62: 

line 63: " Allow commenting and inverting empty lines (useful when commenting a region)

line 64: let g:NERDCommentEmptyLines = 1

line 65: 

line 66: " Enable trimming of trailing whitespace when uncommenting

line 67: let g:NERDTrimTrailingWhitespace = 1

line 68: 

line 69: " Enable NERDCommenterToggle to check all selected lines is commented or not

line 70: let g:NERDToggleCheckAllLines = 1

line 71: vmap <silent><Ctrl

No mapping found
line 72: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

line 73: " For dein.vim

line 74: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

line 75: "let g:deoplete#enable_at_startup = 1

line 76: "call dein#add('Shougo/deoplete.nvim')

line 77: "if !has('nvim')

line 78: "  call dein#add('roxma/nvim-yarp')

line 79: "  call dein#add('roxma/vim-hug-neovim-rpc')

line 80: "endif

line 81: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

line 82: " SETS

line 83: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

line 84: syntax on

line 84: so $VIMRUNTIME/syntax/syntax.vim

chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/usr/share/nvim/runtime/syntax)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
line 84: sourcing "/usr/share/nvim/runtime/syntax/syntax.vim"
line 1: " Vim syntax support file

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>

line 3: " Last Change:^I2001 Sep 04

line 4: 

line 5: " This file is used for ":syntax on".

line 6: " It installs the autocommands and starts highlighting for all buffers.

line 7: 

line 8: if !has("syntax")

line 9:   finish

line 10: endif

line 11: 

line 12: " If Syntax highlighting appears to be on already, turn it off first, so that

line 13: " any leftovers are cleared.

line 14: if exists("syntax_on") || exists("syntax_manual")

line 15:   so <sfile>:p:h/nosyntax.vim

chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/usr/share/nvim/runtime/syntax)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
line 15: sourcing "/usr/share/nvim/runtime/syntax/nosyntax.vim"
line 1: " Vim syntax support file

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>

line 3: " Last Change:^I2006 Apr 16

line 4: 

line 5: " This file is used for ":syntax off".

line 6: " It removes the autocommands and stops highlighting for all buffers.

line 7: 

line 8: if !has("syntax")

line 9:   finish

line 10: endif

line 11: 

line 12: " Remove all autocommands for the Syntax event.  This also avoids that

line 13: " "syntax=foo" in a modeline triggers the SynSet() function of synload.vim.

line 14: au! Syntax

line 15: 

line 16: " remove all syntax autocommands and remove the syntax for each buffer

line 17: augroup syntaxset

line 18:   au!

line 19:   au BufEnter * syn clear

line 20:   au BufEnter * if exists("b:current_syntax") | unlet b:current_syntax | endif

line 21:   doautoall syntaxset BufEnter *

line 22:   au!

line 23: augroup END

line 24: 

line 25: if exists("syntax_on")

line 26:   unlet syntax_on

line 27: endif

line 28: if exists("syntax_manual")

line 29:   unlet syntax_manual

line 30: endif

finished sourcing /usr/share/nvim/runtime/syntax/nosyntax.vim
continuing in /usr/share/nvim/runtime/syntax/syntax.vim
line 16: endif

line 17: 

line 18: " Load the Syntax autocommands and set the default methods for highlighting.

line 19: runtime syntax/synload.vim

Searching for "syntax/synload.vim" in "/home/reggiemarr/.config/nvim,/home/reggiemarr/.vim/plugged/LanguageClient-neovim,/home/reggiemarr/.vim/plugged/ncm2,/home/reggiemarr/.vim/plugged/nvim-yarp,/home/reggiemarr/.vim/plugged/ncm2-bufword,/home/reggiemarr/.vim/plugged/ncm2-path,/home/reggiemarr/.vim/plugged/fzf,/home/reggiemarr/.vim/plugged/nerdcommenter,/etc/xdg/xdg-i3/nvim,/etc/xdg/nvim,/home/reggiemarr/.local/share/nvim/site,/usr/share/i3/nvim/site,/usr/local/share/nvim/site,/usr/share/nvim/site,/var/lib/snapd/desktop/nvim/site,/usr/share/nvim/runtime,/var/lib/snapd/desktop/nvim/site/after,/usr/share/nvim/site/after,/usr/local/share/nvim/site/after,/usr/share/i3/nvim/site/after,/home/reggiemarr/.local/share/nvim/site/after,/etc/xdg/nvim/after,/etc/xdg/xdg-i3/nvim/after,/home/reggiemarr/.config/nvim/after"
Searching for "/home/reggiemarr/.config/nvim/syntax/synload.vim"
Searching for "/home/reggiemarr/.vim/plugged/LanguageClient-neovim/syntax/synload.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2/syntax/synload.vim"
Searching for "/home/reggiemarr/.vim/plugged/nvim-yarp/syntax/synload.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2-bufword/syntax/synload.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2-path/syntax/synload.vim"
Searching for "/home/reggiemarr/.vim/plugged/fzf/syntax/synload.vim"
Searching for "/home/reggiemarr/.vim/plugged/nerdcommenter/syntax/synload.vim"
Searching for "/etc/xdg/xdg-i3/nvim/syntax/synload.vim"
Searching for "/etc/xdg/nvim/syntax/synload.vim"
Searching for "/home/reggiemarr/.local/share/nvim/site/syntax/synload.vim"
Searching for "/usr/share/i3/nvim/site/syntax/synload.vim"
Searching for "/usr/local/share/nvim/site/syntax/synload.vim"
Searching for "/usr/share/nvim/site/syntax/synload.vim"
Searching for "/var/lib/snapd/desktop/nvim/site/syntax/synload.vim"
Searching for "/usr/share/nvim/runtime/syntax/synload.vim"
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/usr/share/nvim/runtime/syntax)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
line 19: sourcing "/usr/share/nvim/runtime/syntax/synload.vim"
line 1: " Vim syntax support file

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>

line 3: " Last Change:^I2016 Nov 04

line 4: 

line 5: " This file sets up for syntax highlighting.

line 6: " It is loaded from "syntax.vim" and "manual.vim".

line 7: " 1. Set the default highlight groups.

line 8: " 2. Install Syntax autocommands for all the available syntax files.

line 9: 

line 10: if !has("syntax")

line 11:   finish

line 12: endif

line 13: 

line 14: " let others know that syntax has been switched on

line 15: let syntax_on = 1

line 16: 

line 17: " Set the default highlighting colors.  Use a color scheme if specified.

line 18: if exists("colors_name")

line 19:   exe "colors " . colors_name

line 20: else

line 21:   runtime! syntax/syncolor.vim

Searching for "syntax/syncolor.vim" in "/home/reggiemarr/.config/nvim,/home/reggiemarr/.vim/plugged/LanguageClient-neovim,/home/reggiemarr/.vim/plugged/ncm2,/home/reggiemarr/.vim/plugged/nvim-yarp,/home/reggiemarr/.vim/plugged/ncm2-bufword,/home/reggiemarr/.vim/plugged/ncm2-path,/home/reggiemarr/.vim/plugged/fzf,/home/reggiemarr/.vim/plugged/nerdcommenter,/etc/xdg/xdg-i3/nvim,/etc/xdg/nvim,/home/reggiemarr/.local/share/nvim/site,/usr/share/i3/nvim/site,/usr/local/share/nvim/site,/usr/share/nvim/site,/var/lib/snapd/desktop/nvim/site,/usr/share/nvim/runtime,/var/lib/snapd/desktop/nvim/site/after,/usr/share/nvim/site/after,/usr/local/share/nvim/site/after,/usr/share/i3/nvim/site/after,/home/reggiemarr/.local/share/nvim/site/after,/etc/xdg/nvim/after,/etc/xdg/xdg-i3/nvim/after,/home/reggiemarr/.config/nvim/after"
Searching for "/home/reggiemarr/.config/nvim/syntax/syncolor.vim"
Searching for "/home/reggiemarr/.vim/plugged/LanguageClient-neovim/syntax/syncolor.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2/syntax/syncolor.vim"
Searching for "/home/reggiemarr/.vim/plugged/nvim-yarp/syntax/syncolor.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2-bufword/syntax/syncolor.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2-path/syntax/syncolor.vim"
Searching for "/home/reggiemarr/.vim/plugged/fzf/syntax/syncolor.vim"
Searching for "/home/reggiemarr/.vim/plugged/nerdcommenter/syntax/syncolor.vim"
Searching for "/etc/xdg/xdg-i3/nvim/syntax/syncolor.vim"
Searching for "/etc/xdg/nvim/syntax/syncolor.vim"
Searching for "/home/reggiemarr/.local/share/nvim/site/syntax/syncolor.vim"
Searching for "/usr/share/i3/nvim/site/syntax/syncolor.vim"
Searching for "/usr/local/share/nvim/site/syntax/syncolor.vim"
Searching for "/usr/share/nvim/site/syntax/syncolor.vim"
Searching for "/var/lib/snapd/desktop/nvim/site/syntax/syncolor.vim"
Searching for "/usr/share/nvim/runtime/syntax/syncolor.vim"
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/usr/share/nvim/runtime/syntax)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
line 21: sourcing "/usr/share/nvim/runtime/syntax/syncolor.vim"
line 1: " Vim syntax support file

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>

line 3: " Last Change:^I2001 Sep 12

line 4: 

line 5: " This file sets up the default methods for highlighting.

line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".

line 7: " Also used from init_highlight().

line 8: 

line 9: if !exists("syntax_cmd") || syntax_cmd == "on"

line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links

line 11:   command -nargs=* SynColor hi <args>

line 12:   command -nargs=* SynLink hi link <args>

line 13: else

line 14:   if syntax_cmd == "enable"

line 15:     " ":syntax enable" keeps any existing colors

line 16:     command -nargs=* SynColor hi def <args>

line 17:     command -nargs=* SynLink hi def link <args>

line 18:   elseif syntax_cmd == "reset"

line 19:     " ":syntax reset" resets all colors to the default

line 20:     command -nargs=* SynColor hi <args>

line 21:     command -nargs=* SynLink hi! link <args>

line 22:   else

line 23:     " User defined syncolor file has already set the colors.

line 24:     finish

line 25:   endif

line 26: endif

line 27: 

line 28: " Many terminals can only use six different colors (plus black and white).

line 29: " Therefore the number of colors used is kept low. It doesn't look nice with

line 30: " too many colors anyway.

line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.

line 32: " There are two sets of defaults: for a dark and a light background.

line 33: if &background == "dark"

line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE

line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE

line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE

line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE

line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE

line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE

line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE

line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE

line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE

line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE

line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE

line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE

line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE

line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE

line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff

line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff

line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE

line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE

line 43: else

line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE

line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE

line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE

line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE

line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE

line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE

line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE

line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue

line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE

line 53: endif

line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red

line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red

line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow

line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow

line 56: 

line 57: " Common groups that link to default highlighting.

line 58: " You can specify other highlighting easily.

line 59: SynLink String^I^IConstant

line 59: hi link String^I^IConstant

line 60: SynLink Character^IConstant

line 60: hi link Character^IConstant

line 61: SynLink Number^I^IConstant

line 61: hi link Number^I^IConstant

line 62: SynLink Boolean^I^IConstant

line 62: hi link Boolean^I^IConstant

line 63: SynLink Float^I^INumber

line 63: hi link Float^I^INumber

line 64: SynLink Function^IIdentifier

line 64: hi link Function^IIdentifier

line 65: SynLink Conditional^IStatement

line 65: hi link Conditional^IStatement

line 66: SynLink Repeat^I^IStatement

line 66: hi link Repeat^I^IStatement

line 67: SynLink Label^I^IStatement

line 67: hi link Label^I^IStatement

line 68: SynLink Operator^IStatement

line 68: hi link Operator^IStatement

line 69: SynLink Keyword^I^IStatement

line 69: hi link Keyword^I^IStatement

line 70: SynLink Exception^IStatement

line 70: hi link Exception^IStatement

line 71: SynLink Include^I^IPreProc

line 71: hi link Include^I^IPreProc

line 72: SynLink Define^I^IPreProc

line 72: hi link Define^I^IPreProc

line 73: SynLink Macro^I^IPreProc

line 73: hi link Macro^I^IPreProc

line 74: SynLink PreCondit^IPreProc

line 74: hi link PreCondit^IPreProc

line 75: SynLink StorageClass^IType

line 75: hi link StorageClass^IType

line 76: SynLink Structure^IType

line 76: hi link Structure^IType

line 77: SynLink Typedef^I^IType

line 77: hi link Typedef^I^IType

line 78: SynLink Tag^I^ISpecial

line 78: hi link Tag^I^ISpecial

line 79: SynLink SpecialChar^ISpecial

line 79: hi link SpecialChar^ISpecial

line 80: SynLink Delimiter^ISpecial

line 80: hi link Delimiter^ISpecial

line 81: SynLink SpecialComment^ISpecial

line 81: hi link SpecialComment^ISpecial

line 82: SynLink Debug^I^ISpecial

line 82: hi link Debug^I^ISpecial

line 83: 

line 84: delcommand SynColor

line 85: delcommand SynLink

finished sourcing /usr/share/nvim/runtime/syntax/syncolor.vim
continuing in /usr/share/nvim/runtime/syntax/synload.vim
Searching for "/var/lib/snapd/desktop/nvim/site/after/syntax/syncolor.vim"
Searching for "/usr/share/nvim/site/after/syntax/syncolor.vim"
Searching for "/usr/local/share/nvim/site/after/syntax/syncolor.vim"
Searching for "/usr/share/i3/nvim/site/after/syntax/syncolor.vim"
Searching for "/home/reggiemarr/.local/share/nvim/site/after/syntax/syncolor.vim"
Searching for "/etc/xdg/nvim/after/syntax/syncolor.vim"
Searching for "/etc/xdg/xdg-i3/nvim/after/syntax/syncolor.vim"
Searching for "/home/reggiemarr/.config/nvim/after/syntax/syncolor.vim"
line 22: endif

line 23: 

line 24: " Line continuation is used here, remove 'C' from 'cpoptions'

line 25: let s:cpo_save = &cpo

line 26: set cpo&vim

line 27: 

line 28: " First remove all old syntax autocommands.

line 29: au! Syntax

line 30: 

line 31: au Syntax *^I^Icall s:SynSet()

line 32: 

line 33: fun! s:SynSet()

line 61: 

line 62: 

line 63: " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)

line 68: au Syntax c,cpp,cs,idl,java,php,datascript if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif

line 69: 

line 70: 

line 71: " Source the user-specified syntax highlighting file

line 72: if exists("mysyntaxfile")

line 73:   let s:fname = expand(mysyntaxfile)

line 74:   if filereadable(s:fname)

line 75:     execute "source " . fnameescape(s:fname)

line 76:   endif

line 77: endif

line 78: 

line 79: " Restore 'cpoptions'

line 80: let &cpo = s:cpo_save

line 81: unlet s:cpo_save

finished sourcing /usr/share/nvim/runtime/syntax/synload.vim
continuing in /usr/share/nvim/runtime/syntax/syntax.vim
line 20: 

line 21: " Load the FileType autocommands if not done yet.

line 22: if exists("did_load_filetypes")

line 23:   let s:did_ft = 1

line 24: else

line 25:   filetype on

line 26:   let s:did_ft = 0

line 27: endif

line 28: 

line 29: " Set up the connection between FileType and Syntax autocommands.

line 30: " This makes the syntax automatically set when the file type is detected.

line 31: augroup syntaxset

line 32:   au! FileType *^Iexe "set syntax=" . expand("<amatch>")

line 33: augroup END

line 34: 

line 35: 

line 36: " Execute the syntax autocommands for the each buffer.

line 37: " If the filetype wasn't detected yet, do that now.

line 38: " Always do the syntaxset autocommands, for buffers where the 'filetype'

line 39: " already was set manually (e.g., help buffers).

line 40: doautoall syntaxset FileType

line 41: if !s:did_ft

line 42:   doautoall filetypedetect BufRead

line 43: endif

finished sourcing /usr/share/nvim/runtime/syntax/syntax.vim
continuing in /home/reggiemarr/.config/nvim/init.vim
line 85: 

line 86: "Convert tabs to spaces

line 87: set expandtab

line 88: set shiftwidth=4

line 89: set tabstop=4

line 90: set softtabstop=4

line 91: " Search details

line 92: set incsearch

line 93: set hlsearch

line 94: " Do no wrap searching

line 95: set nowrapscan

line 96: " To aid the colorscheme...

line 97: set t_Co=256

line 98: " Create line numbers on the left side of vi, 6 digits worth

line 99: set number

line 100: set numberwidth=6

line 101: " Set text wrapping at 80 columns

line 102: set tw=80

line 103: " Indent to the tab positiion when  you cross over the 80 line limit.

line 104: set smartindent

line 105: " Leave a couple of lines at the top and bottom when scrolling

line 106: set scrolloff=2

line 107: " Give context on where you are in the file

line 108: set ruler

line 109: " wrapping is a problem more often than not.

line 110: set nowrap

line 111: 

line 112: 

line 113: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

line 114: " MAPPING

line 115: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

line 116: " Make 'Q' not annoyingly enter into ex edit mode!

line 117: "nnoremap Q <nop>

line 118: "nnoremap K <nop>

line 119: 

line 120: " Always show a ctags list

line 121: "nnoremap <C-]> g<C-]>

line 122: 

line 123: " Window splitting (vertical and horizontal)

line 124: "nnoremap <C-v> :vsp<CR>

line 125: "nnoremap <C-h> :sp<CR>

line 126: " Auto completion

line 127: "imap <tab> <C-p>

line 128: if executable('ag')

line 129:     " Use ag over grep

line 130:     "set gepprg=ag\ --color \ -n \ -B 5 \ -A 5

line 131: 

line 132:     " Use af in CtrlP for listing files. Lightning fast and respects .gitignore

line 133:     "let g:ctrlp_user_command = 'ag %s -l --color -g ""'

line 134: 

line 135:     " ag is fast enough that we don't need to cache

line 136:     "let g"ctrlp_use_caching = 0

line 137: endif

line 138: 

line 139: "let g:ycm_global_ycm_extra_conf = "~/Projects/workRequest/bugfixes/release/.ycm_extra_conf.py"

line 140: 

line 141: " bind \ to grep short cut

line 142: command -nargs=+ -complete=file -bar Ag silent! <args>|cwindow|redraw!

line 143: nnoremap \ :Ag<SPACE>

line 144: 

line 145: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

line 146: " DOXYGEN

line 147: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

line 148: map <F5> O/^[A*^[74.A//**^[o^[i *^MBrief.^M^MDetailed.^M^M@returns^M^M^[A*^[76.A/^[6kb

line 149: map <F6> O/**^M^?/^[O

line 150: map <F7> A /**<  */^[hhi

line 151: 

line 152: 

line 153: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

line 154: " UNDO

line 155: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

line 156: if has('persistent_undo')

line 157:     set undodir=$HOME/.vim/undodir

line 158:     set undofile

line 159:     set undolevels=1000

line 160:     set undoreload=10000

line 161: endif

line 162: 

line 163: 

line 164: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

line 165: " AUTOCOMPLETE

line 166: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

line 167: if has('wildmenu')

line 168: "    set wildmode=list:longest,full

line 169:     set wildignore+=*.a,*.o,*.orig,*~

line 170:     set wildmenu

line 171:     set wildmode=longest,list

line 172: endif

line 173: 

line 174: 

line 175: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

line 176: " MOUSE

line 177: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

line 178: " Allow the mouse to be used for selecting

line 179: " :set mouse=""     Disable all mouse behaviour.

line 180: " :set mouse=a      Enable all mouse behaviour (the default).

line 181: " :set mouse+=v     Enable visual mode (v)

line 182: " :set mouse-=c     Disable mouse in command mode.

line 183: 

line 184: 

line 185: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

line 186: " COLORS

line 187: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

line 188: highlight Folded       ctermfg=7   ctermbg=8

line 189: highlight FoldColumn   ctermfg=7   ctermbg=8

line 190: highlight Search       ctermfg=16  ctermbg=11

line 191: highlight VertSplit    ctermfg=8   ctermbg=0

line 192: highlight StatusLine   ctermfg=8   ctermbg=2

line 193: highlight StatusLineNC ctermfg=8   ctermbg=60

line 194: highlight LineNr       ctermfg=60

line 195: highlight Comment      ctermfg=60

line 196: highlight Number       ctermfg=202

line 197: highlight Search       ctermfg=15  ctermbg=12

line 198: highlight Todo         ctermfg=15  ctermbg=11

line 199: 

line 200: 

line 201: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

line 202: " SYNTAX HIGHLIGHTING

line 203: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

line 204: "autocmd BufRead,BufNewFile *.c,*.h,*.cpp syntax match pointer /\*[a-z,A-Z,0-9]*++/

line 205: "autocmd BufRead,BufNewFile *.c,*.h,*.cpp highlight pointer term = NONE ctermfg=Yellow

line 206: "autocmd BufRead,BufNewFile *.c,*.h,*.cpp syntax match privCtx /privCtx/

line 207: "autocmd BufRead,BufNewFile *.c,*.h,*.cpp highlight privCtx term = NONE ctermfg=Yellow

line 208: "autocmd BufRead,BufNewFile *.c,*.h,*.cpp syntax match annotate

line 209: "\ /\/\*\* [\:A-Za-z0-9 \n\r\*\\\/]* \*\*\//

line 210: "autocmd BufRead,BufNewFile *.c,*.h,*.cpp highlight annotate

line 211: "\ term=NONE ctermfg=8 ctermbg=2 cterm=bold

line 212: "autocmd BufRead,BufNewFile *.c,*.h,*.cpp syntax match wescam /moduleSend\w*/

line 213: "autocmd BufRead,BufNewFile *.c,*.h,*.cpp syntax keyword wescam

line 214: "\ MSG_Q_ID msgQDelete msgQCreate msgQSend msgQReceive

line 215: "\ moduleAddCmdQ moduleRemoveCmdQ moduleAddCmd moduleGetCmd moduleRemoveCmd

line 216: "\ moduleAddCmdRespQ moduleRemoveCmdRespQ moduleAddCmdResp moduleAddCmdResp

line 217: "\ moduleRemoveCmdResp

line 218: "autocmd BufRead,BufNewFile *.c,*.h,*.cpp highlight wescam term=NONE ctermfg=Yellow

line 219: "

line 220: "autocmd BufRead,BufNewFile *.c,*.h,*.cpp syntax match defining /#\(define\|undef\) \w*/

line 221: "autocmd BufRead,BufNewFile *.c,*.h,*.cpp highlight defining term=NONE ctermfg=205

line 222: "

line 223: ""syn match unimportant /moduleLogError(.*\n\=.*\n\=.*);/

line 224: "autocmd BufRead,BufNewFile *.c,*.h,*.cpp syntax match unimportant

line 225: "\ /moduleLogError([a-zA-Z0-9-+><,\n \*"%.\\/&:?\[\]_\(\)]*);/

line 226: "autocmd BufRead,BufNewFile *.c,*.h,*.cpp highlight unimportant term=NONE ctermfg=244

line 227: "autocmd BufRead,BufNewFile *.c,*.h,*.cpp syntax match this /this/

line 228: "autocmd BufRead,BufNewFile *.c,*.h,*.cpp highlight this term=NONE ctermfg=3

line 229: "autocmd BufRead,BufNewFile *.c,*.h,*.cpp syntax match Identifier /\w\+_t\ze\W/

line 230: "autocmd BufRead,BufNewFile *.c,*.h,*.cpp syntax match Identifier 'rtems_[a-z_]*\( \|(\)'

line 231: "autocmd BufRead,BufNewFile *.c,*.h,*.cpp syntax keyword cSpecial

line 232: "\ TRUE FALSE

line 233: "\ UNITY UNITY_FLOAT UNITY_SHIFT

line 234: "\ UNITY7 UNITY7_FLOAT UNITY7_SHIFT

line 235: "\ UNITY23 UNITY23_FLOAT UNITY23_SHIFT

line 236: "\ BIT_1 BIT_2 BIT_3 BIT_4 BIT_5 BIT_6 BIT_7 BIT_8

line 237: "\ BIT_9 BIT_10 BIT_11 BIT_12 BIT_13 BIT_14 BIT_15

line 238: "\ BIT_A BIT_B BIT_C BIT_D BIT_E BIT_F

line 239: "\ BIT_16 BIT_17 BIT_18 BIT_19 BIT_20 BIT_21 BIT_22

line 240: "\ BIT_23 BIT_24 BIT_25 BIT_26 BIT_27 BIT_28 BIT_29

line 241: "\ BIT_30 BIT_31

line 242: 

line 243: 

line 244: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

line 245: " AUTO COMMANDS

line 246: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

line 247: if has("autocmd")

line 248: " autocmd BufRead,BufNewFile *.[ch] let fname = expand('<afile>:p:h') . '/types.vim'

line 249: " autocmd BufRead,BufNewFile *.[ch] if filereadable(fname)

line 250: " autocmd BufRead,BufNewFile *.[ch]   exe 'so ' . fname

line 251: " autocmd BufRead,BufNewFile *.[ch] endif

line 252: 

line 253: " Remove trailing whitepsaces for each line on save.

line 254: " Highlight text that goes past the 80 line limit.

line 255: augroup vimrc_autocmds

line 256: " autocmd BufReadPre * setlocal foldmethod=syntax

line 257: " autocmd BufWinEnter * if &fdm == 'syntax' | setlocal foldmethod=manual | endif

line 258:   autocmd BufEnter * highlight OverLength ctermbg=7 ctermfg=0 guibg=#707070

line 259:   autocmd BufEnter * match OverLength /\%81v.*/

line 260: augroup END

line 261: 

line 262: if has("autocmd")

line 263: " autocmd BufRead,BufNewFile *.[ch] let fname = expand('<afile>:p:h') . '/types.vim'

line 264: " autocmd BufRead,BufNewFile *.[ch] if filereadable(fname)

line 265: " autocmd BufRead,BufNewFile *.[ch]   exe 'so ' . fname

line 266: " autocmd BufRead,BufNewFile *.[ch] endif

line 267: " Remove trailing whitepsaces for each line on save.

line 268:   autocmd BufWritePre * :%s/\s\+$//e

line 269: endif

line 270: 

line 271: augroup cprog

line 272:   " Remove all cprog autocommands

line 273:   au!

line 274: 

line 275:   " For *.c and *.h files set formatting of comments and set C-indenting on.

line 276:   " For other files switch it off.

line 277:   " Don't change the order, it's important that the line with * comes first.

line 278:     autocmd BufRead,BufNewFile *       set formatoptions=tcql nocindent comments&

line 279:     autocmd BufRead,BufNewFile *.c,*.h,*.cpp set formatoptions=croql cindent comments=sr:/*,mb:*,el:*/,://

line 280:     set cino=:0,(0,c1

line 281:   augroup END

line 282: 

line 283:   autocmd BufWritePre * :%s/\s\+$//e

line 284: endif

line 285: 

line 286: " Automatically update the ctags file when a file is written

line 287: function! DelTagOfFile(file)

line 296: 

line 297: function! UpdateTags()

line 305: autocmd BufWritePost *.cpp,*.h,*.c call UpdateTags()

line 306: 

line 307: " Required for operations modifying multiple buffers like rename.

line 308: set hidden

line 309: 

line 313: let g:LanguageClient_serverCommands = { 'rust': ['~/.cargo/bin/rustup', 'run', 'stable', 'rls'], 'python': ['/usr/local/bin/pyls'], }

line 314: 

line 315: nnoremap <F5> :call LanguageClient_contextMenu()<CR>

line 316: nnoremap <silent> gd :call LanguageClient#textDocument_definition()<CR>

line 317: 

line 318: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

line 319: " Custom COMMANDS

line 320: """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

line 321: nnoremap <C-c> :y+

line 322: nnoremap <C-f> :%s/

line 323: nnoremap <C-o> :!

line 324: nnoremap <C-j> :!

line 325: nnoremap <F7> :! git rev-parse --abbrev-ref HEAD <CR>

line 326: 

line 327: set ignorecase

line 328: " get the notename

line 329: "function! GetNoteName()

line 330: "    let s:branch = system('git rev-parse --abbrev-ref HEAD')

line 331: "    let s:shortBranch = substitute(s:branch,".*\/rm\/","","")

line 332: "    let l:noteName = "~/notes/" . substitute(s:shortBranch,"_.*","","") . ".md"

line 333: "    execute "vsplit" l:noteName

line 334: "endfunction

line 335: 

line 336: "nnoremap <C-m> :call GetNoteName()<CR>

line 337: " Git Fugitive

line 338: "set statusline=%{fugitive#statusline()}

line 339: 

line 340: 

line 341: " execute pathogen#infect()

line 342: " set rtp+=/usr/local/opt/fzf

line 343: "/home/linuxbrew/.linuxbrew/opt/fzf

finished sourcing /home/reggiemarr/.config/nvim/init.vim
Searching for "pack/*/start/*" in "/home/reggiemarr/.config/nvim,/etc/xdg/xdg-i3/nvim,/etc/xdg/nvim,/home/reggiemarr/.local/share/nvim/site,/usr/share/i3/nvim/site,/usr/local/share/nvim/site,/usr/share/nvim/site,/var/lib/snapd/desktop/nvim/site,/usr/share/nvim/runtime,/var/lib/snapd/desktop/nvim/site/after,/usr/share/nvim/site/after,/usr/local/share/nvim/site/after,/usr/share/i3/nvim/site/after,/home/reggiemarr/.local/share/nvim/site/after,/etc/xdg/nvim/after,/etc/xdg/xdg-i3/nvim/after,/home/reggiemarr/.config/nvim/after"
Searching for "/home/reggiemarr/.config/nvim/pack/*/start/*"
Searching for "/etc/xdg/xdg-i3/nvim/pack/*/start/*"
Searching for "/etc/xdg/nvim/pack/*/start/*"
Searching for "/home/reggiemarr/.local/share/nvim/site/pack/*/start/*"
Searching for "/usr/share/i3/nvim/site/pack/*/start/*"
Searching for "/usr/local/share/nvim/site/pack/*/start/*"
Searching for "/usr/share/nvim/site/pack/*/start/*"
Searching for "/var/lib/snapd/desktop/nvim/site/pack/*/start/*"
Searching for "/usr/share/nvim/runtime/pack/*/start/*"
Searching for "/var/lib/snapd/desktop/nvim/site/after/pack/*/start/*"
Searching for "/usr/share/nvim/site/after/pack/*/start/*"
Searching for "/usr/local/share/nvim/site/after/pack/*/start/*"
Searching for "/usr/share/i3/nvim/site/after/pack/*/start/*"
Searching for "/home/reggiemarr/.local/share/nvim/site/after/pack/*/start/*"
Searching for "/etc/xdg/nvim/after/pack/*/start/*"
Searching for "/etc/xdg/xdg-i3/nvim/after/pack/*/start/*"
Searching for "/home/reggiemarr/.config/nvim/after/pack/*/start/*"
not found in 'packpath': "pack/*/start/*"
Searching for "plugin/**/*.vim" in "/home/reggiemarr/.config/nvim,/home/reggiemarr/.vim/plugged/LanguageClient-neovim,/home/reggiemarr/.vim/plugged/ncm2,/home/reggiemarr/.vim/plugged/nvim-yarp,/home/reggiemarr/.vim/plugged/ncm2-bufword,/home/reggiemarr/.vim/plugged/ncm2-path,/home/reggiemarr/.vim/plugged/fzf,/home/reggiemarr/.vim/plugged/nerdcommenter,/etc/xdg/xdg-i3/nvim,/etc/xdg/nvim,/home/reggiemarr/.local/share/nvim/site,/usr/share/i3/nvim/site,/usr/local/share/nvim/site,/usr/share/nvim/site,/var/lib/snapd/desktop/nvim/site,/usr/share/nvim/runtime,/var/lib/snapd/desktop/nvim/site/after,/usr/share/nvim/site/after,/usr/local/share/nvim/site/after,/usr/share/i3/nvim/site/after,/home/reggiemarr/.local/share/nvim/site/after,/etc/xdg/nvim/after,/etc/xdg/xdg-i3/nvim/after,/home/reggiemarr/.config/nvim/after"
Searching for "/home/reggiemarr/.config/nvim/plugin/**/*.vim"
Searching for "/home/reggiemarr/.vim/plugged/LanguageClient-neovim/plugin/**/*.vim"
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/home/reggiemarr/.vim/plugged/LanguageClient-neovim/plugin)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
sourcing "/home/reggiemarr/.vim/plugged/LanguageClient-neovim/plugin/LanguageClient.vim"
line 1: if !exists('g:LanguageClient_serverCommands')

line 2:     let g:LanguageClient_serverCommands = {}

line 3: endif

line 4: 

line 5: function! LanguageClient_textDocument_hover(...)

line 8: 

line 9: function! LanguageClient_textDocument_definition(...)

line 12: 

line 13: function! LanguageClient_textDocument_typeDefinition(...)

line 16: 

line 17: function! LanguageClient_textDocument_implementation(...)

line 20: 

line 21: function! LanguageClient_textDocument_rename(...)

line 24: 

line 25: function! LanguageClient_textDocument_documentSymbol(...)

line 28: 

line 29: function! LanguageClient_textDocument_references(...)

line 32: 

line 33: function! LanguageClient_textDocument_codeAction(...)

line 36: 

line 37: function! LanguageClient_textDocument_completion(...)

line 40: 

line 41: function! LanguageClient_textDocument_formatting(...)

line 44: 

line 45: function! LanguageClient_textDocument_rangeFormatting(...)

line 48: 

line 49: function! LanguageClient_textDocument_documentHighlight(...)

line 52: 

line 53: function! LanguageClient_workspace_symbol(...)

line 56: 

line 57: function! LanguageClient_workspace_applyEdit(...)

line 60: 

line 61: function! LanguageClient_workspace_executeCommand(...)

line 64: 

line 65: function! LanguageClient_setLoggingLevel(...)

line 68: 

line 69: function! LanguageClient_registerServerCommands(...)

line 72: 

line 73: function! LanguageClient_registerHandlers(...)

line 76: 

line 77: function! LanguageClient_omniComplete(...)

line 80: 

line 81: function! LanguageClient_complete(...)

line 84: 

line 85: function! LanguageClient_serverStatus(...)

line 88: 

line 89: function! LanguageClient_serverStatusMessage(...)

line 92: 

line 93: function! LanguageClient_statusLine(...)

line 96: 

line 97: function! LanguageClient_clearDocumentHighlight(...)

line 100: 

line 101: function! LanguageClient_cquery_base(...)

line 104: 

line 105: function! LanguageClient_cquery_vars(...)

line 108: 

line 109: function! LanguageClient_closeFloatingHover(...)

line 112: 

line 113: command! -nargs=* LanguageClientStart :call LanguageClient#startServer(<f-args>)

line 114: command! LanguageClientStop :call LanguageClient#exit()

line 115: 

line 116: augroup languageClient

line 117:     autocmd!

line 118:     autocmd FileType * call LanguageClient#handleFileType()

line 119:     autocmd BufNewFile * call LanguageClient#handleBufNewFile()

line 120:     autocmd BufWritePost * call LanguageClient#handleBufWritePost()

line 121:     autocmd BufDelete * call LanguageClient#handleBufDelete()

line 122:     autocmd TextChanged * call LanguageClient#handleTextChanged()

line 123:     autocmd TextChangedI * call LanguageClient#handleTextChanged()

line 124:     if exists('##TextChangedP')

line 125:         autocmd TextChangedP * call LanguageClient#handleTextChanged()

line 126:     endif

line 127:     autocmd CursorMoved * call LanguageClient#handleCursorMoved()

line 128:     autocmd VimLeavePre * call LanguageClient#handleVimLeavePre()

line 129: 

line 130:     autocmd CompleteDone * call LanguageClient#handleCompleteDone()

line 131: 

line 132:     if get(g:, 'LanguageClient_signatureHelpOnCompleteDone', 0)

line 134:         autocmd CompleteDone * call LanguageClient#textDocument_signatureHelp({}, 's:HandleOutputNothing')

line 135:     endif

line 136: augroup END

finished sourcing /home/reggiemarr/.vim/plugged/LanguageClient-neovim/plugin/LanguageClient.vim
Searching for "/home/reggiemarr/.vim/plugged/ncm2/plugin/**/*.vim"
Searching for "/home/reggiemarr/.vim/plugged/nvim-yarp/plugin/**/*.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2-bufword/plugin/**/*.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2-path/plugin/**/*.vim"
Searching for "/home/reggiemarr/.vim/plugged/fzf/plugin/**/*.vim"
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/home/reggiemarr/.vim/plugged/fzf/plugin)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
sourcing "/home/reggiemarr/.vim/plugged/fzf/plugin/fzf.vim"
line 1: " Copyright (c) 2017 Junegunn Choi

line 2: "

line 3: " MIT License

line 4: "

line 5: " Permission is hereby granted, free of charge, to any person obtaining

line 6: " a copy of this software and associated documentation files (the

line 7: " "Software"), to deal in the Software without restriction, including

line 8: " without limitation the rights to use, copy, modify, merge, publish,

line 9: " distribute, sublicense, and/or sell copies of the Software, and to

line 10: " permit persons to whom the Software is furnished to do so, subject to

line 11: " the following conditions:

line 12: "

line 13: " The above copyright notice and this permission notice shall be

line 14: " included in all copies or substantial portions of the Software.

line 15: "

line 16: " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

line 17: " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

line 18: " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

line 19: " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE

line 20: " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION

line 21: " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION

line 22: " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

line 23: 

line 24: if exists('g:loaded_fzf')

line 25:   finish

line 26: endif

line 27: let g:loaded_fzf = 1

line 28: 

line 29: let s:is_win = has('win32') || has('win64')

line 30: if s:is_win && &shellslash

line 31:   set noshellslash

line 32:   let s:base_dir = expand('<sfile>:h:h')

line 33:   set shellslash

line 34: else

line 35:   let s:base_dir = expand('<sfile>:h:h')

line 36: endif

line 37: if s:is_win

line 38:   let s:term_marker = '&::FZF'

line 39: 

line 40:   function! s:fzf_call(fn, ...)

line 49: 

line 50:   " Use utf-8 for fzf.vim commands

line 51:   " Return array of shell commands for cmd.exe

line 52:   function! s:wrap_cmds(cmds)

line 63: else

line 64:   let s:term_marker = ";#FZF"

line 65: 

line 66:   function! s:fzf_call(fn, ...)

line 69: 

line 70:   function! s:wrap_cmds(cmds)

line 73: endif

line 74: 

line 75: function! s:shellesc_cmd(arg)

line 82: 

line 83: function! fzf#shellescape(arg, ...)

line 90: 

line 91: function! s:fzf_getcwd()

line 94: 

line 95: function! s:fzf_fnamemodify(fname, mods)

line 98: 

line 99: function! s:fzf_expand(fmt)

line 102: 

line 103: function! s:fzf_tempname()

line 106: 

line 107: let s:default_layout = { 'down': '~40%' }

line 108: let s:layout_keys = ['window', 'up', 'down', 'left', 'right']

line 109: let s:fzf_go = s:base_dir.'/bin/fzf'

line 110: let s:fzf_tmux = s:base_dir.'/bin/fzf-tmux'

line 111: let s:install = s:base_dir.'/install'

line 112: let s:installed = 0

line 113: 

line 114: let s:cpo_save = &cpo

line 115: set cpo&vim

line 116: 

line 117: function! s:fzf_exec()

line 143: 

line 144: function! s:tmux_enabled()

line 160: 

line 161: function! s:escape(path)

line 165: 

line 166: " Upgrade legacy options

line 167: function! s:upgrade(dict)

line 180: 

line 181: function! s:error(msg)

line 186: 

line 187: function! s:warn(msg)

line 192: 

line 193: function! s:has_any(dict, keys)

line 201: 

line 202: function! s:open(cmd, target)

line 208: 

line 209: function! s:common_sink(action, lines) abort

line 246: 

line 247: function! s:get_color(attr, ...)

line 259: 

line 260: function! s:defaults()

line 265: 

line 266: function! s:validate_layout(layout)

line 275: 

line 276: function! s:evaluate_opts(options)

line 280: 

line 281: " [name string,] [opts dict,] [fullscreen boolean]

line 282: function! fzf#wrap(...)

line 341: 

line 342: function! s:use_sh()

line 352: 

line 353: function! fzf#run(...) abort

line 428: 

line 429: function! s:present(dict, ...)

line 437: 

line 438: function! s:fzf_tmux(dict)

line 455: 

line 456: function! s:splittable(dict)

line 460: 

line 461: function! s:pushd(dict)

line 477: 

line 478: augroup fzf_popd

line 479:   autocmd!

line 480:   autocmd WinEnter * call s:dopopd()

line 481: augroup END

line 482: 

line 483: function! s:dopopd()

line 508: 

line 509: function! s:xterm_launcher()

line 518: unlet! s:launcher

line 519: if s:is_win || has('win32unix')

line 520:   let s:launcher = '%s'

line 521: else

line 522:   let s:launcher = function('s:xterm_launcher')

line 523: endif

line 524: 

line 525: function! s:exit_handler(code, command, ...)

line 537: 

line 538: function! s:execute(dict, command, use_height, temps) abort

line 588: 

line 589: function! s:execute_tmux(dict, command, temps) abort

line 602: 

line 603: function! s:calc_size(max, val, dict)

line 622: 

line 623: function! s:getpos()

line 626: 

line 627: function! s:split(dict)

line 660: 

line 661: function! s:execute_term(dict, command, temps) abort

line 741: 

line 742: function! s:collect(temps) abort

line 751: 

line 752: function! s:callback(dict, lines) abort

line 783: 

line 787: let s:default_action = { 'ctrl-t': 'tab split', 'ctrl-x': 'split', 'ctrl-v': 'vsplit' }

line 788: 

line 789: function! s:shortpath()

line 797: 

line 798: function! s:cmd(bang, ...) abort

line 815: 

line 816: command! -nargs=* -complete=dir -bang FZF call s:cmd(<bang>0, <f-args>)

line 817: 

line 818: let &cpo = s:cpo_save

line 819: unlet s:cpo_save

finished sourcing /home/reggiemarr/.vim/plugged/fzf/plugin/fzf.vim
Searching for "/home/reggiemarr/.vim/plugged/nerdcommenter/plugin/**/*.vim"
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/home/reggiemarr/.vim/plugged/nerdcommenter/plugin)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
sourcing "/home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim"
line 1: " ============================================================================

line 2: " File:        NERD_commenter.vim

line 3: " Description: vim global plugin that provides easy code commenting

line 4: " Author:      Martin Grenfell <martin.grenfell at gmail dot com>

line 5: " Maintainer:  Caleb Maclennan <caleb@alerque.com>

line 6: " Version:     2.5.1

line 7: " Last Change: Tue Nov  7 10:45:53 +03 2017

line 8: " License:     This program is free software. It comes without any warranty,

line 9: "              to the extent permitted by applicable law. You can redistribute

line 10: "              it and/or modify it under the terms of the Do What The Fuck You

line 11: "              Want To Public License, Version 2, as published by Sam Hocevar.

line 12: "              See http://sam.zoy.org/wtfpl/COPYING for more details.

line 13: "

line 14: " ============================================================================

line 15: 

line 16: " Section: script init stuff {{{1

line 17: if exists("loaded_nerd_comments")

line 18:     finish

line 19: endif

line 20: if v:version < 700

line 21:     echoerr "NERDCommenter: this plugin requires vim >= 7. DOWNLOAD IT! You'll thank me later!"

line 22:     finish

line 23: endif

line 24: let loaded_nerd_comments = 1

line 25: 

line 26: " Function: s:InitVariable() function {{{2

line 27: " This function is used to initialise a given variable to a given value. The

line 28: " variable is only initialised if it does not exist prior

line 29: "

line 30: " Args:

line 31: "   -var: the name of the var to be initialised

line 32: "   -value: the value to initialise var to

line 33: "

line 34: " Returns:

line 35: "   1 if the var is set, 0 otherwise

line 36: function s:InitVariable(var, value)

line 43: 

line 44: " Section: space string init{{{2

line 45: " When putting spaces after the left delimiter and before the right we use

line 46: " s:spaceStr for the space char. This way we can make it add anything after

line 47: " the left and before the right by modifying this variable

line 48: let s:spaceStr = ' '

line 49: let s:lenSpaceStr = strlen(s:spaceStr)

line 50: 

line 51: " Section: variable initialization {{{2

line 52: call s:InitVariable("g:NERDAllowAnyVisualDelims", 1)

calling function <SNR>12_InitVariable('g:NERDAllowAnyVisualDelims', 1)

line 1:     if !exists(a:var)

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"

line 2: let g:NERDAllowAnyVisualDelims = '1'

line 3:         return 1

function <SNR>12_InitVariable returning #1

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 53: call s:InitVariable("g:NERDBlockComIgnoreEmpty", 0)

calling function <SNR>12_InitVariable('g:NERDBlockComIgnoreEmpty', 0)

line 1:     if !exists(a:var)

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"

line 2: let g:NERDBlockComIgnoreEmpty = '0'

line 3:         return 1

function <SNR>12_InitVariable returning #1

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 54: call s:InitVariable("g:NERDCommentWholeLinesInVMode", 0)

calling function <SNR>12_InitVariable('g:NERDCommentWholeLinesInVMode', 0)

line 1:     if !exists(a:var)

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"

line 2: let g:NERDCommentWholeLinesInVMode = '0'

line 3:         return 1

function <SNR>12_InitVariable returning #1

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 55: call s:InitVariable("g:NERDCommentEmptyLines", 0)

calling function <SNR>12_InitVariable('g:NERDCommentEmptyLines', 0)

line 1:     if !exists(a:var)

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"

line 3:         return 1

line 4:     endif

line 5:     return 0

function <SNR>12_InitVariable returning #0

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 56: call s:InitVariable("g:NERDCompactSexyComs", 0)

calling function <SNR>12_InitVariable('g:NERDCompactSexyComs', 0)

line 1:     if !exists(a:var)

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"

line 3:         return 1

line 4:     endif

line 5:     return 0

function <SNR>12_InitVariable returning #0

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 57: call s:InitVariable("g:NERDCreateDefaultMappings", 1)

calling function <SNR>12_InitVariable('g:NERDCreateDefaultMappings', 1)

line 1:     if !exists(a:var)

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"

line 2: let g:NERDCreateDefaultMappings = '1'

line 3:         return 1

function <SNR>12_InitVariable returning #1

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 58: call s:InitVariable("g:NERDDefaultNesting", 1)

calling function <SNR>12_InitVariable('g:NERDDefaultNesting', 1)

line 1:     if !exists(a:var)

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"

line 2: let g:NERDDefaultNesting = '1'

line 3:         return 1

function <SNR>12_InitVariable returning #1

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 59: call s:InitVariable("g:NERDMenuMode", 3)

calling function <SNR>12_InitVariable('g:NERDMenuMode', 3)

line 1:     if !exists(a:var)

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"

line 2: let g:NERDMenuMode = '3'

line 3:         return 1

function <SNR>12_InitVariable returning #1

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 60: call s:InitVariable("g:NERDLPlace", "[>")

calling function <SNR>12_InitVariable('g:NERDLPlace', '[>')

line 1:     if !exists(a:var)

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"

line 2: let g:NERDLPlace = '[>'

line 3:         return 1

function <SNR>12_InitVariable returning #1

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 61: call s:InitVariable("g:NERDUsePlaceHolders", 1)

calling function <SNR>12_InitVariable('g:NERDUsePlaceHolders', 1)

line 1:     if !exists(a:var)

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"

line 2: let g:NERDUsePlaceHolders = '1'

line 3:         return 1

function <SNR>12_InitVariable returning #1

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 62: call s:InitVariable("g:NERDRemoveAltComs", 1)

calling function <SNR>12_InitVariable('g:NERDRemoveAltComs', 1)

line 1:     if !exists(a:var)

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"

line 2: let g:NERDRemoveAltComs = '1'

line 3:         return 1

function <SNR>12_InitVariable returning #1

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 63: call s:InitVariable("g:NERDRemoveExtraSpaces", 0)

calling function <SNR>12_InitVariable('g:NERDRemoveExtraSpaces', 0)

line 1:     if !exists(a:var)

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"

line 2: let g:NERDRemoveExtraSpaces = '0'

line 3:         return 1

function <SNR>12_InitVariable returning #1

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 64: call s:InitVariable("g:NERDRPlace", "<]")

calling function <SNR>12_InitVariable('g:NERDRPlace', '<]')

line 1:     if !exists(a:var)

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"

line 2: let g:NERDRPlace = '<]'

line 3:         return 1

function <SNR>12_InitVariable returning #1

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 65: call s:InitVariable("g:NERDSpaceDelims", 0)

calling function <SNR>12_InitVariable('g:NERDSpaceDelims', 0)

line 1:     if !exists(a:var)

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"

line 2: let g:NERDSpaceDelims = '0'

line 3:         return 1

function <SNR>12_InitVariable returning #1

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 66: call s:InitVariable("g:NERDDefaultAlign", "none")

calling function <SNR>12_InitVariable('g:NERDDefaultAlign', 'none')

line 1:     if !exists(a:var)

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"

line 3:         return 1

line 4:     endif

line 5:     return 0

function <SNR>12_InitVariable returning #0

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 67: call s:InitVariable("g:NERDTrimTrailingWhitespace", 0)

calling function <SNR>12_InitVariable('g:NERDTrimTrailingWhitespace', 0)

line 1:     if !exists(a:var)

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"

line 3:         return 1

line 4:     endif

line 5:     return 0

function <SNR>12_InitVariable returning #0

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 68: call s:InitVariable("g:NERDToggleCheckAllLines", 0)

calling function <SNR>12_InitVariable('g:NERDToggleCheckAllLines', 0)

line 1:     if !exists(a:var)

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"

line 3:         return 1

line 4:     endif

line 5:     return 0

function <SNR>12_InitVariable returning #0

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 69: call s:InitVariable("g:NERDDisableTabsInBlockComm", 0)

calling function <SNR>12_InitVariable('g:NERDDisableTabsInBlockComm', 0)

line 1:     if !exists(a:var)

line 2:         execute 'let ' . a:var . ' = ' . "'" . a:value . "'"

line 2: let g:NERDDisableTabsInBlockComm = '0'

line 3:         return 1

function <SNR>12_InitVariable returning #1

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 70: 

line 71: let s:NERDFileNameEscape="[]#*$%'\" ?`!&();<>\\"

line 72: 

line 489: let s:delimiterMap = { 'aap': { 'left': '#' }, 'abc': { 'left': '%' }, 'acedb': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' }, 'actionscript': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' }, 'ada': { 'left': '--', 'leftAlt': '--  ' }, 'ahdl': { 'left': '--' }, 'ahk': { 'left': ';', 'leftAlt': '/*', 'rightAlt': '*/' }, 'amiga': { 'left': ';' }, 'aml': { 'left': '/*' }, 'ampl': { 'left': '#' }, 'ansible': { 'left': '#' }, 'apache': { 'left': '#' }, 'apachestyle': { 'left': '#' }, 'apdl': { 'left': '!' }, 'applescript': { 'left': '--', 'leftAlt': '(*', 'rightAlt': '*)' }, 'armasm': { 'left': ';' }, 'asciidoc': { 'left': '//' }, 'asm': { 'left': ';', 'leftAlt': '#' }, 'asm68k': { 'left': ';' }, 'asn': { 'left': '--' }, 'asp': { 'left': '%', 'leftAlt': '%*', 'rightAlt': '*%' }, 'aspvbs': { 'left': '''', 'leftAlt': '<!--', 'rightAlt': '-->' }, 'asterisk': { 'left': ';' }, 'asy': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' }, 'atlas': { 'left': 'C', 'right': '$' }, 'augeas': { 'left': '(*'

line 490: 

line 491: let g:NERDDelimiterMap = s:delimiterMap

line 492: 

line 493: if exists("g:NERDCustomDelimiters")

line 494:     call extend(s:delimiterMap, g:NERDCustomDelimiters)

line 495: endif

line 496: 

line 497: " Section: Comment mapping functions, autocommands and commands {{{1

line 498: " ============================================================================

line 499: " Section: Comment enabler autocommands {{{2

line 500: " ============================================================================

line 501: 

line 502: augroup NERDCommenter

line 503: 

line 504:     "if the user enters a buffer or reads a buffer then we gotta set up

line 505:     "the comment delimiters for that new filetype

line 506:     autocmd BufEnter,BufRead * :call s:SetUpForNewFiletype(&filetype, 0)

line 507: 

line 508:     "if the filetype of a buffer changes, force the script to reset the

line 509:     "delimiters for the buffer

line 510:     autocmd Filetype * :call s:SetUpForNewFiletype(&filetype, 1)

line 511: augroup END

line 512: 

line 513: 

line 514: " Function: s:SetUpForNewFiletype(filetype) function {{{2

line 515: " This function is responsible for setting up buffer scoped variables for the

line 516: " given filetype.

line 517: "

line 518: " Args:

line 519: "   -filetype: the filetype to set delimiters for

line 520: "   -forceReset: 1 if the delimiters should be reset if they have already be

line 521: "    set for this buffer.

line 522: "

line 523: function s:SetUpForNewFiletype(filetype, forceReset)

line 563: 

line 564: function s:CreateDelimMapFromCms()

line 582: 

line 583: " Function: s:SwitchToAlternativeDelimiters(printMsgs) function {{{2

line 584: " This function is used to swap the delimiters that are being used to the

line 585: " alternative delimiters for that filetype. For example, if a c++ file is

line 586: " being edited and // comments are being used, after this function is called

line 587: " /**/ comments will be used.

line 588: "

line 589: " Args:

line 590: "   -printMsgs: if this is 1 then a message is echoed to the user telling them

line 591: "    if this function changed the delimiters or not

line 592: function s:SwitchToAlternativeDelimiters(printMsgs)

line 632: 

line 633: " Section: Comment delimiter add/removal functions {{{1

line 634: " ============================================================================

line 635: " Function: s:AppendCommentToLine(){{{2

line 636: " This function appends comment delimiters at the EOL and places the cursor in

line 637: " position to start typing the comment

line 638: function s:AppendCommentToLine()

line 662: 

line 663: " Function: s:CommentBlock(top, bottom, lSide, rSide, forceNested ) {{{2

line 664: " This function is used to comment out a region of code. This region is

line 665: " specified as a bounding box by arguments to the function.

line 666: "

line 667: " Args:

line 668: "   -top: the line number for the top line of code in the region

line 669: "   -bottom: the line number for the bottom line of code in the region

line 670: "   -lSide: the column number for the left most column in the region

line 671: "   -rSide: the column number for the right most column in the region

line 672: "   -forceNested: a flag indicating whether comments should be nested

line 673: function s:CommentBlock(top, bottom, lSide, rSide, forceNested )

line 796: 

line 797: " Function: s:CommentLines(forceNested, alignLeft, alignRight, firstLine, lastLine) {{{2

line 798: " This function comments a range of lines.

line 799: "

line 800: " Args:

line 801: "   -forceNested: a flag indicating whether the called is requesting the comment

line 802: "    to be nested if need be

line 803: "   -align: should be "left", "start", "both" or "none"

line 804: "   -firstLine/lastLine: the top and bottom lines to comment

line 805: function s:CommentLines(forceNested, align, firstLine, lastLine)

line 865: 

line 866: " Function: s:CommentLinesMinimal(firstLine, lastLine) {{{2

line 867: " This function comments a range of lines in a minimal style. I

line 868: "

line 869: " Args:

line 870: "   -firstLine/lastLine: the top and bottom lines to comment

line 871: function s:CommentLinesMinimal(firstLine, lastLine)

line 926: 

line 927: " Function: s:CommentLinesSexy(topline, bottomline) function {{{2

line 928: " This function is used to comment lines in the 'Sexy' style. E.g., in c:

line 929: " /*

line 930: "  * This is a sexy comment

line 931: "  */

line 932: " Args:

line 933: "   -topline: the line number of the top line in the sexy comment

line 934: "   -bottomline: the line number of the bottom line in the sexy comment

line 935: function s:CommentLinesSexy(topline, bottomline)

line 1061: 

line 1062: " Function: s:CommentLinesToggle(forceNested, firstLine, lastLine) {{{2

line 1063: " Applies "toggle" commenting to the given range of lines

line 1064: "

line 1065: " Args:

line 1066: "   -forceNested: a flag indicating whether the called is requesting the comment

line 1067: "    to be nested if need be

line 1068: "   -firstLine/lastLine: the top and bottom lines to comment

line 1069: function s:CommentLinesToggle(forceNested, firstLine, lastLine)

line 1118: 

line 1119: " Function: s:CommentRegion(topline, topCol, bottomLine, bottomCol) function {{{2

line 1120: " This function comments chunks of text selected in visual mode.

line 1121: " It will comment exactly the text that they have selected.

line 1122: " Args:

line 1123: "   -topLine: the line number of the top line in the sexy comment

line 1124: "   -topCol: top left column for this comment

line 1125: "   -bottomline: the line number of the bottom line in the sexy comment

line 1126: "   -bottomCol: the bottom right column for this comment

line 1127: "   -forceNested: whether the caller wants comments to be nested if the

line 1128: "    line(s) are already commented

line 1129: function s:CommentRegion(topLine, topCol, bottomLine, bottomCol, forceNested)

line 1170: 

line 1171: " Function: s:InvertComment(firstLine, lastLine) function {{{2

line 1172: " Inverts the comments on the lines between and including the given line

line 1173: " numbers i.e all commented lines are uncommented and vice versa

line 1174: " Args:

line 1175: "   -firstLine: the top of the range of lines to be inverted

line 1176: "   -lastLine: the bottom of the range of lines to be inverted

line 1177: function s:InvertComment(firstLine, lastLine)

line 1208: 

line 1209: function! NERDCommentIsLineCommented(lineNo)

line 1213: 

line 1214: " Function: NERDComment(mode, type) function {{{2

line 1215: " This function is a Wrapper for the main commenting functions

line 1216: "

line 1217: " Args:

line 1218: "   -mode: a character indicating the mode in which the comment is requested:

line 1219: "   'n' for Normal mode, 'x' for Visual mode

line 1220: "   -type: the type of commenting requested. Can be 'Sexy', 'Invert',

line 1221: "    'Minimal', 'Toggle', 'AlignLeft', 'AlignBoth', 'Comment',

line 1222: "    'Nested', 'ToEOL', 'Append', 'Insert', 'Uncomment', 'Yank'

line 1223: function! NERDComment(mode, type) range

line 1355: 

line 1356: " Function: s:PlaceDelimitersAndInsBetween() function {{{2

line 1357: " This is function is called to place comment delimiters down and place the

line 1358: " cursor between them

line 1359: function s:PlaceDelimitersAndInsBetween()

line 1406: 

line 1407: " Function: s:RemoveDelimiters(left, right, line) {{{2

line 1408: " this function is called to remove the first left comment delimiter and the

line 1409: " last right delimiter of the given line.

line 1410: "

line 1411: " The arguments left and right must be strings. If there is no right delimiter (as

line 1412: " is the case for e.g vim file comments) them the argument right should be ""

line 1413: "

line 1414: " Args:

line 1415: "   -left: the left comment delimiter

line 1416: "   -right: the right comment delimiter

line 1417: "   -line: the line to remove the delimiters from

line 1418: function s:RemoveDelimiters(left, right, line)

line 1455: 

line 1456: " Function: s:SetupStateBeforeLineComment(topLine, bottomLine) {{{2

line 1457: " Changes ignorecase and foldmethod options before commenting lines and saves

line 1458: " their original values in a dict, which is returned as a result

line 1459: "

line 1460: " Args:

line 1461: " topLine: the top line of the visual selection to uncomment

line 1462: " bottomLine: the bottom line of the visual selection to uncomment

line 1463: "

line 1464: " Return: a dict with the state prior to configuration changes

line 1465: "

line 1466: function s:SetupStateBeforeLineComment(topLine, bottomLine)

line 1484: 

line 1485: " Function: s:RecoverStateAfterLineComment(state) {{{2

line 1486: " Receives the state returned by s:SetupStateBeforeLineComment and restores

line 1487: " the state accordingly

line 1488: "

line 1489: " Args:

line 1490: " state: the top line of the visual selection to uncomment

line 1491: " bottomLine: the bottom line of the visual selection to uncomment

line 1492: function s:RecoverStateAfterLineComment(state)

line 1500: 

line 1501: " Function: s:TrimTrailingWhitespace(line) {{{2

line 1502: " This function removes all the trailing whitespace

line 1503: " Args:

line 1504: "   -line: the target line

line 1505: function s:TrimTrailingWhitespace(line)

line 1509: 

line 1510: " Function: s:UncommentLines(topLine, bottomLine) {{{2

line 1511: " This function uncomments the given lines

line 1512: "

line 1513: " Args:

line 1514: " topLine: the top line of the visual selection to uncomment

line 1515: " bottomLine: the bottom line of the visual selection to uncomment

line 1516: function s:UncommentLines(topLine, bottomLine)

line 1555: 

line 1556: " Function: s:UncommentLinesSexy(topline, bottomline) {{{2

line 1557: " This function removes all the comment characters associated with the sexy

line 1558: " comment spanning the given lines

line 1559: " Args:

line 1560: "   -topline/bottomline: the top/bottom lines of the sexy comment

line 1561: function s:UncommentLinesSexy(topline, bottomline)

line 1686: 

line 1687: " Function: s:UncommentLineNormal(line) {{{2

line 1688: " uncomments the given line and returns the result

line 1689: " Args:

line 1690: "   -line: the line to uncomment

line 1691: function s:UncommentLineNormal(line)

line 1763: 

line 1764: " Function: s:UncommentLinesNormal(topline, bottomline) {{{2

line 1765: " This function is called to uncomment lines that aren't a sexy comment

line 1766: " Args:

line 1767: "   -topline/bottomline: the top/bottom line numbers of the comment

line 1768: function s:UncommentLinesNormal(topline, bottomline)

line 1776: 

line 1777: 

line 1778: " Section: Other helper functions {{{1

line 1779: " ============================================================================

line 1780: 

line 1781: " Function: s:AddLeftDelim(delim, theLine) {{{2

line 1782: " Args:

line 1783: function s:AddLeftDelim(delim, theLine)

line 1786: 

line 1787: " Function: s:AddLeftDelimAligned(delim, theLine) {{{2

line 1788: " Args:

line 1789: function s:AddLeftDelimAligned(delim, theLine, alignIndx)

line 1800: 

line 1801: " Function: s:AddRightDelim(delim, theLine) {{{2

line 1802: " Args:

line 1803: function s:AddRightDelim(delim, theLine)

line 1810: 

line 1811: " Function: s:AddRightDelimAligned(delim, theLine, alignIndx) {{{2

line 1812: " Args:

line 1813: function s:AddRightDelimAligned(delim, theLine, alignIndx)

line 1828: 

line 1829: " Function: s:AltMultipart() {{{2

line 1830: " returns 1 if the alternative delimiters are multipart

line 1831: function s:AltMultipart()

line 1834: 

line 1835: " Function: s:AltNested() {{{2

line 1836: " returns 1 if the alternate multipart (if any) delimiters allow nesting

line 1837: function s:AltNested()

line 1840: 

line 1841: " Function: s:CanCommentLine(forceNested, line) {{{2

line 1842: "This function is used to determine whether the given line can be commented.

line 1843: "It returns 1 if it can be and 0 otherwise

line 1844: "

line 1845: " Args:

line 1846: "   -forceNested: a flag indicating whether the caller wants comments to be nested

line 1847: "    if the current line is already commented

line 1848: "   -lineNum: the line number of the line to check for commentability

line 1849: function s:CanCommentLine(forceNested, lineNum)

line 1877: 

line 1878: " Function: s:CanPlaceCursor(line, col) {{{2

line 1879: " returns 1 if the cursor can be placed exactly in the given position

line 1880: function s:CanPlaceCursor(line, col)

line 1888: 

line 1889: " Function: s:CanSexyCommentLines(topline, bottomline) {{{2

line 1890: " Return: 1 if the given lines can be commented sexually, 0 otherwise

line 1891: function s:CanSexyCommentLines(topline, bottomline)

line 1907: " Function: s:CanToggleCommentLine(forceNested, line) {{{2

line 1908: "This function is used to determine whether the given line can be toggle commented.

line 1909: "It returns 1 if it can be and 0 otherwise

line 1910: "

line 1911: " Args:

line 1912: "   -lineNum: the line number of the line to check for commentability

line 1913: function s:CanToggleCommentLine(forceNested, lineNum)

line 1932: 

line 1933: " Function: s:ConvertLeadingSpacesToTabs(line) {{{2

line 1934: " This function takes a line and converts all leading tabs on that line into

line 1935: " spaces

line 1936: "

line 1937: " Args:

line 1938: "   -line: the line whose leading tabs will be converted

line 1939: function s:ConvertLeadingSpacesToTabs(line)

line 1947: 

line 1948: 

line 1949: " Function: s:ConvertLeadingTabsToSpaces(line) {{{2

line 1950: " This function takes a line and converts all leading spaces on that line into

line 1951: " tabs

line 1952: "

line 1953: " Args:

line 1954: "   -line: the line whose leading spaces will be converted

line 1955: function s:ConvertLeadingTabsToSpaces(line)

line 1963: 

line 1964: " Function: s:ConvertLeadingWhiteSpace(line) {{{2

line 1965: " Converts the leading white space to tabs/spaces depending on &ts

line 1966: "

line 1967: " Args:

line 1968: "   -line: the line to convert

line 1969: function s:ConvertLeadingWhiteSpace(line)

line 1981: 

line 1982: 

line 1983: " Function: s:CountNonESCedOccurances(str, searchstr, escChar) {{{2

line 1984: " This function counts the number of substrings contained in another string.

line 1985: " These substrings are only counted if they are not escaped with escChar

line 1986: " Args:

line 1987: "   -str: the string to look for searchstr in

line 1988: "   -searchstr: the substring to search for in str

line 1989: "   -escChar: the escape character which, when preceding an instance of

line 1990: "    searchstr, will cause it not to be counted

line 1991: function s:CountNonESCedOccurances(str, searchstr, escChar)

line 2010: " Function: s:DoesBlockHaveDelim(delim, top, bottom) {{{2

line 2011: " Returns 1 if the given block of lines has a delimiter (a:delim) in it

line 2012: " Args:

line 2013: "   -delim: the comment delimiter to check the block for

line 2014: "   -top: the top line number of the block

line 2015: "   -bottom: the bottom line number of the block

line 2016: function s:DoesBlockHaveDelim(delim, top, bottom)

line 2027: 

line 2028: " Function: s:DoesBlockHaveMultipartDelim(top, bottom) {{{2

line 2029: " Returns 1 if the given block has a >= 1 multipart delimiter in it

line 2030: " Args:

line 2031: "   -top: the top line number of the block

line 2032: "   -bottom: the bottom line number of the block

line 2033: function s:DoesBlockHaveMultipartDelim(top, bottom)

line 2043: 

line 2044: 

line 2045: " Function: s:Esc(str) {{{2

line 2046: " Escapes all the tricky chars in the given string

line 2047: function s:Esc(str)

line 2051: 

line 2052: " Function: s:FindDelimiterIndex(delimiter, line) {{{2

line 2053: " This function is used to get the string index of the input comment delimiter

line 2054: " on the input line. If no valid comment delimiter is found in the line then

line 2055: " -1 is returned

line 2056: " Args:

line 2057: "   -delimiter: the delimiter we are looking to find the index of

line 2058: "   -line: the line we are looking for delimiter on

line 2059: function s:FindDelimiterIndex(delimiter, line)

line 2104: 

line 2105: " Function: s:FindBoundingLinesOfSexyCom(lineNum) {{{2

line 2106: " This function takes in a line number and tests whether this line number is

line 2107: " the top/bottom/middle line of a sexy comment. If it is then the top/bottom

line 2108: " lines of the sexy comment are returned

line 2109: " Args:

line 2110: "   -lineNum: the line number that is to be tested whether it is the

line 2111: "    top/bottom/middle line of a sexy com

line 2112: " Returns:

line 2113: "   A string that has the top/bottom lines of the sexy comment encoded in it.

line 2114: "   The format is 'topline,bottomline'. If a:lineNum turns out not to be the

line 2115: "   top/bottom/middle of a sexy comment then -1 is returned

line 2116: function s:FindBoundingLinesOfSexyCom(lineNum)

line 2178: 

line 2179: 

line 2180: " Function: s:GetSexyComMarker() {{{2

line 2181: " Returns the sexy comment marker for the current filetype.

line 2182: "

line 2183: " C style sexy comments are assumed if possible. If not then the sexy comment

line 2184: " marker is the last char of the delimiter pair that has both left and right

line 2185: " delimiters and has the longest left delimiter

line 2186: "

line 2187: " Args:

line 2188: "   -space: specifies whether the marker is to have a space string after it

line 2189: "    (the space string will only be added if NERDSpaceDelims is set)

line 2190: "   -esc: specifies whether the tricky chars in the marker are to be ESCed

line 2191: function s:GetSexyComMarker(space, esc)

line 2231: 

line 2232: " Function: s:SexyNested() {{{2

line 2233: " Returns 1 if the sexy delimeters allow nesting

line 2234: " TODO this is ugly copy&paste from the GetSexyComLeft/Right functions,

line 2235: " these could all be cleaned up

line 2236: function s:SexyNested()

line 2254: 

line 2255: " Function: s:GetSexyComLeft(space, esc) {{{2

line 2256: " Returns the left delimiter for sexy comments for this filetype or -1 if

line 2257: " there is none. C style sexy comments are used if possible

line 2258: " Args:

line 2259: "   -space: specifies if the delimiter has a space string on the end

line 2260: "   (the space string will only be added if NERDSpaceDelims is set)

line 2261: "   -esc: specifies whether the tricky chars in the string are ESCed

line 2262: function s:GetSexyComLeft(space, esc)

line 2291: 

line 2292: " Function: s:GetSexyComRight(space, esc) {{{2

line 2293: " Returns the right delimiter for sexy comments for this filetype or -1 if

line 2294: " there is none. C style sexy comments are used if possible.

line 2295: " Args:

line 2296: "   -space: specifies if the delimiter has a space string on the start

line 2297: "   (the space string will only be added if NERDSpaceDelims

line 2298: "   is specified for the current filetype)

line 2299: "   -esc: specifies whether the tricky chars in the string are ESCed

line 2300: function s:GetSexyComRight(space, esc)

line 2329: 

line 2330: " Function: s:HasMultipartDelims() {{{2

line 2331: " Returns 1 if the current filetype has at least one set of multipart delimiters

line 2332: function s:HasMultipartDelims()

line 2335: 

line 2336: " Function: s:HasLeadingTabs(...) {{{2

line 2337: " Returns 1 if any of the given strings have leading tabs

line 2338: function s:HasLeadingTabs(...)

line 2346: " Function: s:HasCStyleComments() {{{2

line 2347: " Returns 1 if the current filetype has c style comment delimiters

line 2348: function s:HasCStyleComments()

line 2351: 

line 2352: " Function: s:IsCommentedNormOrSexy(lineNum) {{{2

line 2353: "This function is used to determine whether the given line is commented with

line 2354: "either set of delimiters or if it is part of a sexy comment

line 2355: "

line 2356: " Args:

line 2357: "   -lineNum: the line number of the line to check

line 2358: function s:IsCommentedNormOrSexy(lineNum)

line 2372: 

line 2373: " Function: s:IsCommented(left, right, line) {{{2

line 2374: "This function is used to determine whether the given line is commented with

line 2375: "the given delimiters

line 2376: "

line 2377: " Args:

line 2378: "   -line: the line that to check if commented

line 2379: "   -left/right: the left and right delimiters to check for

line 2380: function s:IsCommented(left, right, line)

line 2387: 

line 2388: " Function: s:IsCommentedFromStartOfLine(left, line) {{{2

line 2389: "This function is used to determine whether the given line is commented with

line 2390: "the given delimiters at the start of the line i.e the left delimiter is the

line 2391: "first thing on the line (apart from spaces\tabs)

line 2392: "

line 2393: " Args:

line 2394: "   -line: the line that to check if commented

line 2395: "   -left: the left delimiter to check for

line 2396: function s:IsCommentedFromStartOfLine(left, line)

line 2402: 

line 2403: " Function: s:IsCommentedOutermost(left, right, leftAlt, rightAlt, line) {{{2

line 2404: " Finds the type of the outermost delimiters on the line

line 2405: "

line 2406: " Args:

line 2407: "   -line: the line that to check if the outermost comments on it are

line 2408: "    left/right

line 2409: "   -left/right: the left and right delimiters to check for

line 2410: "   -leftAlt/rightAlt: the left and right alternative delimiters to check for

line 2411: "

line 2412: " Returns:

line 2413: "   0 if the line is not commented with either set of delimiters

line 2414: "   1 if the line is commented with the left/right delimiter set

line 2415: "   2 if the line is commented with the leftAlt/rightAlt delim set

line 2416: function s:IsCommentedOutermost(left, right, leftAlt, rightAlt, line)

line 2444: 

line 2445: 

line 2446: " Function: s:IsDelimValid(delimiter, delIndx, line) {{{2

line 2447: " This function is responsible for determining whether a given instance of a

line 2448: " comment delimiter is a real delimiter or not. For example, in java the

line 2449: " // string is a comment delimiter but in the line:

line 2450: "               System.out.println("//");

line 2451: " it does not count as a comment delimiter. This function is responsible for

line 2452: " distinguishing between such cases. It does so by applying a set of

line 2453: " heuristics that are not fool proof but should work most of the time.

line 2454: "

line 2455: " Args:

line 2456: "   -delimiter: the delimiter we are validating

line 2457: "   -delIndx: the position of delimiter in line

line 2458: "   -line: the line that delimiter occurs in

line 2459: "

line 2460: " Returns:

line 2461: " 0 if the given delimiter is not a real delimiter (as far as we can tell) ,

line 2462: " 1 otherwise

line 2463: function s:IsDelimValid(delimiter, delIndx, line)

line 2522: 

line 2523: " Function: s:IsNumEven(num) {{{2

line 2524: " A small function the returns 1 if the input number is even and 0 otherwise

line 2525: " Args:

line 2526: "   -num: the number to check

line 2527: function s:IsNumEven(num)

line 2530: 

line 2531: " Function: s:IsEscaped(str, indx, escChar) {{{2

line 2532: " This function takes a string, an index into that string and an esc char and

line 2533: " returns 1 if the char at the index is escaped (i.e if it is preceded by an

line 2534: " odd number of esc chars)

line 2535: " Args:

line 2536: "   -str: the string to check

line 2537: "   -indx: the index into str that we want to check

line 2538: "   -escChar: the escape char the char at indx may be ESCed with

line 2539: function s:IsEscaped(str, indx, escChar)

line 2559: 

line 2560: " Function: s:IsInSexyComment(line) {{{2

line 2561: " returns 1 if the given line number is part of a sexy comment

line 2562: function s:IsInSexyComment(line)

line 2565: 

line 2566: " Function: s:IsSexyComment(topline, bottomline) {{{2

line 2567: " This function takes in 2 line numbers and returns 1 if the lines between and

line 2568: " including the given line numbers are a sexy comment. It returns 0 otherwise.

line 2569: " Args:

line 2570: "   -topline: the line that the possible sexy comment starts on

line 2571: "   -bottomline: the line that the possible sexy comment stops on

line 2572: function s:IsSexyComment(topline, bottomline)

line 2646: 

line 2647: " Function: s:LastIndexOfDelim(delim, str) {{{2

line 2648: " This function takes a string and a delimiter and returns the last index of

line 2649: " that delimiter in string

line 2650: " Args:

line 2651: "   -delim: the delimiter to look for

line 2652: "   -str: the string to look for delimiter in

line 2653: function s:LastIndexOfDelim(delim, str)

line 2684: 

line 2685: " Function: s:Left(...) {{{2

line 2686: " returns left delimiter data

line 2687: function s:Left(...)

line 2706: 

line 2707: " Function: s:LeftMostIndx(countCommentedLines, countEmptyLines, topline, bottomline) {{{2

line 2708: " This function takes in 2 line numbers and returns the index of the left most

line 2709: " char (that is not a space or a tab) on all of these lines.

line 2710: " Args:

line 2711: "   -countCommentedLines: 1 if lines that are commented are to be checked as

line 2712: "    well. 0 otherwise

line 2713: "   -countEmptyLines: 1 if empty lines are to be counted in the search

line 2714: "   -topline: the top line to be checked

line 2715: "   -bottomline: the bottom line to be checked

line 2716: function s:LeftMostIndx(countCommentedLines, countEmptyLines, topline, bottomline)

line 2750: 

line 2751: " Function: s:Multipart() {{{2

line 2752: " returns 1 if the current delimiters are multipart

line 2753: function s:Multipart()

line 2756: 

line 2757: " Function: s:NerdEcho(msg, typeOfMsg) {{{2

line 2758: " Args:

line 2759: "   -msg: the message to echo

line 2760: "   -typeOfMsg: 0 = warning message

line 2761: "               1 = normal message

line 2762: function s:NerdEcho(msg, typeOfMsg)

line 2771: 

line 2772: " Function: s:Nested() {{{2

line 2773: " returns 1 if the current multipart (if any) delimiters allow nesting

line 2774: function s:Nested()

line 2777: 

line 2778: " Function: s:NumberOfLeadingTabs(s) {{{2

line 2779: " returns the number of leading tabs in the given string

line 2780: function s:NumberOfLeadingTabs(s)

line 2783: 

line 2784: " Function: s:NumLinesInBuf() {{{2

line 2785: " Returns the number of lines in the current buffer

line 2786: function s:NumLinesInBuf()

line 2789: 

line 2790: " Function: s:ReplaceDelims(toReplace1, toReplace2, replacor1, replacor2, str) {{{2

line 2791: " This function takes in a string, 2 delimiters in that string and 2 strings

line 2792: " to replace these delimiters with.

line 2793: "

line 2794: " Args:

line 2795: "   -toReplace1: the first delimiter to replace

line 2796: "   -toReplace2: the second delimiter to replace

line 2797: "   -replacor1: the string to replace toReplace1 with

line 2798: "   -replacor2: the string to replace toReplace2 with

line 2799: "   -str: the string that the delimiters to be replaced are in

line 2800: function s:ReplaceDelims(toReplace1, toReplace2, replacor1, replacor2, str)

line 2805: 

line 2806: " Function: s:ReplaceLeftMostDelim(toReplace, replacor, str) {{{2

line 2807: " This function takes a string and a delimiter and replaces the left most

line 2808: " occurrence of this delimiter in the string with a given string

line 2809: "

line 2810: " Args:

line 2811: "   -toReplace: the delimiter in str that is to be replaced

line 2812: "   -replacor: the string to replace toReplace with

line 2813: "   -str: the string that contains toReplace

line 2814: function s:ReplaceLeftMostDelim(toReplace, replacor, str)

line 2829: 

line 2830: " Function: s:ReplaceRightMostDelim(toReplace, replacor, str) {{{2

line 2831: " This function takes a string and a delimiter and replaces the right most

line 2832: " occurrence of this delimiter in the string with a given string

line 2833: "

line 2834: " Args:

line 2835: "   -toReplace: the delimiter in str that is to be replaced

line 2836: "   -replacor: the string to replace toReplace with

line 2837: "   -str: the string that contains toReplace

line 2838: "

line 2839: function s:ReplaceRightMostDelim(toReplace, replacor, str)

line 2854: 

line 2855: "FUNCTION: s:RestoreScreenState() {{{2

line 2856: "

line 2857: "Sets the screen state back to what it was when s:SaveScreenState was last

line 2858: "called.

line 2859: "

line 2860: function s:RestoreScreenState()

line 2869: 

line 2870: " Function: s:Right(...) {{{2

line 2871: " returns right delimiter data

line 2872: function s:Right(...)

line 2891: 

line 2892: " Function: s:RightMostIndx(countCommentedLines, countEmptyLines, topline, bottomline) {{{2

line 2893: " This function takes in 2 line numbers and returns the index of the right most

line 2894: " char on all of these lines.

line 2895: " Args:

line 2896: "   -countCommentedLines: 1 if lines that are commented are to be checked as

line 2897: "    well. 0 otherwise

line 2898: "   -countEmptyLines: 1 if empty lines are to be counted in the search

line 2899: "   -topline: the top line to be checked

line 2900: "   -bottomline: the bottom line to be checked

line 2901: function s:RightMostIndx(countCommentedLines, countEmptyLines, topline, bottomline)

line 2930: 

line 2931: "FUNCTION: s:SaveScreenState() {{{2

line 2932: "Saves the current cursor position in the current buffer and the window

line 2933: "scroll position

line 2934: function s:SaveScreenState()

line 2938: 

line 2939: " Function: s:SwapOuterMultiPartDelimsForPlaceHolders(line) {{{2

line 2940: " This function takes a line and swaps the outer most multi-part delimiters for

line 2941: " place holders

line 2942: " Args:

line 2943: "   -line: the line to swap the delimiters in

line 2944: "

line 2945: function s:SwapOuterMultiPartDelimsForPlaceHolders(line)

line 2966: 

line 2967: " Function: s:SwapOuterPlaceHoldersForMultiPartDelims(line) {{{2

line 2968: " This function takes a line and swaps the outermost place holders for

line 2969: " multi-part delimiters

line 2970: " Args:

line 2971: "   -line: the line to swap the delimiters in

line 2972: "

line 2973: function s:SwapOuterPlaceHoldersForMultiPartDelims(line)

line 2987: " Function: s:TabbedCol(line, col) {{{2

line 2988: " Gets the col number for given line and existing col number. The new col

line 2989: " number is the col number when all leading spaces are converted to tabs

line 2990: " Args:

line 2991: "   -line:the line to get the rel col for

line 2992: "   -col: the abs col

line 2993: function s:TabbedCol(line, col)

line 2998: "FUNCTION: s:TabSpace() {{{2

line 2999: "returns a string of spaces equal in length to &tabstop

line 3000: function s:TabSpace()

line 3009: 

line 3010: " Function: s:UnEsc(str, escChar) {{{2

line 3011: " This function removes all the escape chars from a string

line 3012: " Args:

line 3013: "   -str: the string to remove esc chars from

line 3014: "   -escChar: the escape char to be removed

line 3015: function s:UnEsc(str, escChar)

line 3018: 

line 3019: " Function: s:UntabbedCol(line, col) {{{2

line 3020: " Takes a line and a col and returns the absolute column of col taking into

line 3021: " account that a tab is worth 3 or 4 (or whatever) spaces.

line 3022: " Args:

line 3023: "   -line:the line to get the abs col for

line 3024: "   -col: the col that doesn't take into account tabs

line 3025: function s:UntabbedCol(line, col)

line 3030: " Section: Comment mapping and menu item setup {{{1

line 3031: " ===========================================================================

line 3032: 

line 3033: " Create menu items for the specified modes.  If a:combo is not empty, then

line 3034: " also define mappings and show a:combo in the menu items.

line 3035: function! s:CreateMaps(modes, target, desc, combo)

line 3065: call s:CreateMaps('nx', 'Comment',    'Comment', 'cc')

calling function <SNR>12_CreateMaps('nx', 'Comment', 'Comment', 'cc')

line 1:     " Build up a map command like

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'

line 3:     let plug = '<plug>NERDCommenter' . a:target

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'

line 5:     let plug_end = '", "' . a:target . '")<cr>'

line 6:     " Build up a menu command like

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')

line 11:     if strlen(a:combo)

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo

line 14:     endif

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)

line 16:     " Execute the commands built above for each requested mode.

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 19: nnoremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")<cr>

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 21: nmap <leader>cc <plug>NERDCommenterComment

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 26: nmenu <silent> &Plugin.&comment.Comment<Tab>\\cc <plug>NERDCommenterComment

line 27:         endif

line 28:     endfor

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 19: xnoremap <silent> <plug>NERDCommenterComment :call NERDComment("x", "Comment")<cr>

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 21: xmap <leader>cc <plug>NERDCommenterComment

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 26: xmenu <silent> &Plugin.&comment.Comment<Tab>\\cc <plug>NERDCommenterComment

line 27:         endif

line 28:     endfor

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 27:         endif

line 28:     endfor

function <SNR>12_CreateMaps returning #0

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 3066: call s:CreateMaps('nx', 'Toggle',     'Toggle', 'c<space>')

calling function <SNR>12_CreateMaps('nx', 'Toggle', 'Toggle', 'c<space>')

line 1:     " Build up a map command like

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'

line 3:     let plug = '<plug>NERDCommenter' . a:target

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'

line 5:     let plug_end = '", "' . a:target . '")<cr>'

line 6:     " Build up a menu command like

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')

line 11:     if strlen(a:combo)

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo

line 14:     endif

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)

line 16:     " Execute the commands built above for each requested mode.

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 19: nnoremap <silent> <plug>NERDCommenterToggle :call NERDComment("n", "Toggle")<cr>

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 21: nmap <leader>c<space> <plug>NERDCommenterToggle

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 26: nmenu <silent> &Plugin.&comment.Toggle<Tab>\\c<space> <plug>NERDCommenterToggle

line 27:         endif

line 28:     endfor

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 19: xnoremap <silent> <plug>NERDCommenterToggle :call NERDComment("x", "Toggle")<cr>

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 21: xmap <leader>c<space> <plug>NERDCommenterToggle

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 26: xmenu <silent> &Plugin.&comment.Toggle<Tab>\\c<space> <plug>NERDCommenterToggle

line 27:         endif

line 28:     endfor

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 27:         endif

line 28:     endfor

function <SNR>12_CreateMaps returning #0

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 3067: call s:CreateMaps('nx', 'Minimal',    'Minimal', 'cm')

calling function <SNR>12_CreateMaps('nx', 'Minimal', 'Minimal', 'cm')

line 1:     " Build up a map command like

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'

line 3:     let plug = '<plug>NERDCommenter' . a:target

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'

line 5:     let plug_end = '", "' . a:target . '")<cr>'

line 6:     " Build up a menu command like

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')

line 11:     if strlen(a:combo)

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo

line 14:     endif

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)

line 16:     " Execute the commands built above for each requested mode.

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 19: nnoremap <silent> <plug>NERDCommenterMinimal :call NERDComment("n", "Minimal")<cr>

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 21: nmap <leader>cm <plug>NERDCommenterMinimal

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 26: nmenu <silent> &Plugin.&comment.Minimal<Tab>\\cm <plug>NERDCommenterMinimal

line 27:         endif

line 28:     endfor

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 19: xnoremap <silent> <plug>NERDCommenterMinimal :call NERDComment("x", "Minimal")<cr>

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 21: xmap <leader>cm <plug>NERDCommenterMinimal

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 26: xmenu <silent> &Plugin.&comment.Minimal<Tab>\\cm <plug>NERDCommenterMinimal

line 27:         endif

line 28:     endfor

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 27:         endif

line 28:     endfor

function <SNR>12_CreateMaps returning #0

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 3068: call s:CreateMaps('nx', 'Nested',     'Nested', 'cn')

calling function <SNR>12_CreateMaps('nx', 'Nested', 'Nested', 'cn')

line 1:     " Build up a map command like

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'

line 3:     let plug = '<plug>NERDCommenter' . a:target

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'

line 5:     let plug_end = '", "' . a:target . '")<cr>'

line 6:     " Build up a menu command like

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')

line 11:     if strlen(a:combo)

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo

line 14:     endif

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)

line 16:     " Execute the commands built above for each requested mode.

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 19: nnoremap <silent> <plug>NERDCommenterNested :call NERDComment("n", "Nested")<cr>

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 21: nmap <leader>cn <plug>NERDCommenterNested

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 26: nmenu <silent> &Plugin.&comment.Nested<Tab>\\cn <plug>NERDCommenterNested

line 27:         endif

line 28:     endfor

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 19: xnoremap <silent> <plug>NERDCommenterNested :call NERDComment("x", "Nested")<cr>

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 21: xmap <leader>cn <plug>NERDCommenterNested

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 26: xmenu <silent> &Plugin.&comment.Nested<Tab>\\cn <plug>NERDCommenterNested

line 27:         endif

line 28:     endfor

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 27:         endif

line 28:     endfor

function <SNR>12_CreateMaps returning #0

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 3069: call s:CreateMaps('n',  'ToEOL',      'To EOL', 'c$')

calling function <SNR>12_CreateMaps('n', 'ToEOL', 'To EOL', 'c$')

line 1:     " Build up a map command like

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'

line 3:     let plug = '<plug>NERDCommenter' . a:target

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'

line 5:     let plug_end = '", "' . a:target . '")<cr>'

line 6:     " Build up a menu command like

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')

line 11:     if strlen(a:combo)

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo

line 14:     endif

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)

line 16:     " Execute the commands built above for each requested mode.

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 19: nnoremap <silent> <plug>NERDCommenterToEOL :call NERDComment("n", "ToEOL")<cr>

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 21: nmap <leader>c$ <plug>NERDCommenterToEOL

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 26: nmenu <silent> &Plugin.&comment.To\ EOL<Tab>\\c$ <plug>NERDCommenterToEOL

line 27:         endif

line 28:     endfor

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 27:         endif

line 28:     endfor

function <SNR>12_CreateMaps returning #0

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 3070: call s:CreateMaps('nx', 'Invert',     'Invert', 'ci')

calling function <SNR>12_CreateMaps('nx', 'Invert', 'Invert', 'ci')

line 1:     " Build up a map command like

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'

line 3:     let plug = '<plug>NERDCommenter' . a:target

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'

line 5:     let plug_end = '", "' . a:target . '")<cr>'

line 6:     " Build up a menu command like

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')

line 11:     if strlen(a:combo)

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo

line 14:     endif

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)

line 16:     " Execute the commands built above for each requested mode.

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 19: nnoremap <silent> <plug>NERDCommenterInvert :call NERDComment("n", "Invert")<cr>

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 21: nmap <leader>ci <plug>NERDCommenterInvert

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 26: nmenu <silent> &Plugin.&comment.Invert<Tab>\\ci <plug>NERDCommenterInvert

line 27:         endif

line 28:     endfor

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 19: xnoremap <silent> <plug>NERDCommenterInvert :call NERDComment("x", "Invert")<cr>

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 21: xmap <leader>ci <plug>NERDCommenterInvert

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 26: xmenu <silent> &Plugin.&comment.Invert<Tab>\\ci <plug>NERDCommenterInvert

line 27:         endif

line 28:     endfor

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 27:         endif

line 28:     endfor

function <SNR>12_CreateMaps returning #0

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 3071: call s:CreateMaps('nx', 'Sexy',       'Sexy', 'cs')

calling function <SNR>12_CreateMaps('nx', 'Sexy', 'Sexy', 'cs')

line 1:     " Build up a map command like

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'

line 3:     let plug = '<plug>NERDCommenter' . a:target

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'

line 5:     let plug_end = '", "' . a:target . '")<cr>'

line 6:     " Build up a menu command like

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')

line 11:     if strlen(a:combo)

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo

line 14:     endif

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)

line 16:     " Execute the commands built above for each requested mode.

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 19: nnoremap <silent> <plug>NERDCommenterSexy :call NERDComment("n", "Sexy")<cr>

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 21: nmap <leader>cs <plug>NERDCommenterSexy

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 26: nmenu <silent> &Plugin.&comment.Sexy<Tab>\\cs <plug>NERDCommenterSexy

line 27:         endif

line 28:     endfor

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 19: xnoremap <silent> <plug>NERDCommenterSexy :call NERDComment("x", "Sexy")<cr>

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 21: xmap <leader>cs <plug>NERDCommenterSexy

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 26: xmenu <silent> &Plugin.&comment.Sexy<Tab>\\cs <plug>NERDCommenterSexy

line 27:         endif

line 28:     endfor

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 27:         endif

line 28:     endfor

function <SNR>12_CreateMaps returning #0

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 3072: call s:CreateMaps('nx', 'Yank',       'Yank then comment', 'cy')

calling function <SNR>12_CreateMaps('nx', 'Yank', 'Yank then comment', 'cy')

line 1:     " Build up a map command like

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'

line 3:     let plug = '<plug>NERDCommenter' . a:target

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'

line 5:     let plug_end = '", "' . a:target . '")<cr>'

line 6:     " Build up a menu command like

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')

line 11:     if strlen(a:combo)

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo

line 14:     endif

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)

line 16:     " Execute the commands built above for each requested mode.

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 19: nnoremap <silent> <plug>NERDCommenterYank :call NERDComment("n", "Yank")<cr>

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 21: nmap <leader>cy <plug>NERDCommenterYank

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 26: nmenu <silent> &Plugin.&comment.Yank\ then\ comment<Tab>\\cy <plug>NERDCommenterYank

line 27:         endif

line 28:     endfor

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 19: xnoremap <silent> <plug>NERDCommenterYank :call NERDComment("x", "Yank")<cr>

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 21: xmap <leader>cy <plug>NERDCommenterYank

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 26: xmenu <silent> &Plugin.&comment.Yank\ then\ comment<Tab>\\cy <plug>NERDCommenterYank

line 27:         endif

line 28:     endfor

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 27:         endif

line 28:     endfor

function <SNR>12_CreateMaps returning #0

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 3073: call s:CreateMaps('n',  'Append',     'Append', 'cA')

calling function <SNR>12_CreateMaps('n', 'Append', 'Append', 'cA')

line 1:     " Build up a map command like

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'

line 3:     let plug = '<plug>NERDCommenter' . a:target

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'

line 5:     let plug_end = '", "' . a:target . '")<cr>'

line 6:     " Build up a menu command like

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')

line 11:     if strlen(a:combo)

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo

line 14:     endif

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)

line 16:     " Execute the commands built above for each requested mode.

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 19: nnoremap <silent> <plug>NERDCommenterAppend :call NERDComment("n", "Append")<cr>

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 21: nmap <leader>cA <plug>NERDCommenterAppend

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 26: nmenu <silent> &Plugin.&comment.Append<Tab>\\cA <plug>NERDCommenterAppend

line 27:         endif

line 28:     endfor

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 27:         endif

line 28:     endfor

function <SNR>12_CreateMaps returning #0

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 3074: call s:CreateMaps('',   ':',          '-Sep-', '')

calling function <SNR>12_CreateMaps('', ':', '-Sep-', '')

line 1:     " Build up a map command like

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'

line 3:     let plug = '<plug>NERDCommenter' . a:target

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'

line 5:     let plug_end = '", "' . a:target . '")<cr>'

line 6:     " Build up a menu command like

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')

line 11:     if strlen(a:combo)

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo

line 14:     endif

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)

line 16:     " Execute the commands built above for each requested mode.

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 26: menu <silent> &Plugin.&comment.-Sep- :

line 27:         endif

line 28:     endfor

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 27:         endif

line 28:     endfor

function <SNR>12_CreateMaps returning #0

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 3075: call s:CreateMaps('nx', 'AlignLeft',  'Left aligned', 'cl')

calling function <SNR>12_CreateMaps('nx', 'AlignLeft', 'Left aligned', 'cl')

line 1:     " Build up a map command like

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'

line 3:     let plug = '<plug>NERDCommenter' . a:target

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'

line 5:     let plug_end = '", "' . a:target . '")<cr>'

line 6:     " Build up a menu command like

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')

line 11:     if strlen(a:combo)

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo

line 14:     endif

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)

line 16:     " Execute the commands built above for each requested mode.

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 19: nnoremap <silent> <plug>NERDCommenterAlignLeft :call NERDComment("n", "AlignLeft")<cr>

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 21: nmap <leader>cl <plug>NERDCommenterAlignLeft

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 26: nmenu <silent> &Plugin.&comment.Left\ aligned<Tab>\\cl <plug>NERDCommenterAlignLeft

line 27:         endif

line 28:     endfor

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 19: xnoremap <silent> <plug>NERDCommenterAlignLeft :call NERDComment("x", "AlignLeft")<cr>

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 21: xmap <leader>cl <plug>NERDCommenterAlignLeft

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 26: xmenu <silent> &Plugin.&comment.Left\ aligned<Tab>\\cl <plug>NERDCommenterAlignLeft

line 27:         endif

line 28:     endfor

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 27:         endif

line 28:     endfor

function <SNR>12_CreateMaps returning #0

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 3076: call s:CreateMaps('nx', 'AlignBoth',  'Left and right aligned', 'cb')

calling function <SNR>12_CreateMaps('nx', 'AlignBoth', 'Left and right aligned', 'cb')

line 1:     " Build up a map command like

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'

line 3:     let plug = '<plug>NERDCommenter' . a:target

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'

line 5:     let plug_end = '", "' . a:target . '")<cr>'

line 6:     " Build up a menu command like

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')

line 11:     if strlen(a:combo)

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo

line 14:     endif

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)

line 16:     " Execute the commands built above for each requested mode.

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 19: nnoremap <silent> <plug>NERDCommenterAlignBoth :call NERDComment("n", "AlignBoth")<cr>

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 21: nmap <leader>cb <plug>NERDCommenterAlignBoth

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 26: nmenu <silent> &Plugin.&comment.Left\ and\ right\ aligned<Tab>\\cb <plug>NERDCommenterAlignBoth

line 27:         endif

line 28:     endfor

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 19: xnoremap <silent> <plug>NERDCommenterAlignBoth :call NERDComment("x", "AlignBoth")<cr>

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 21: xmap <leader>cb <plug>NERDCommenterAlignBoth

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 26: xmenu <silent> &Plugin.&comment.Left\ and\ right\ aligned<Tab>\\cb <plug>NERDCommenterAlignBoth

line 27:         endif

line 28:     endfor

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 27:         endif

line 28:     endfor

function <SNR>12_CreateMaps returning #0

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 3077: call s:CreateMaps('',   ':',          '-Sep2-', '')

calling function <SNR>12_CreateMaps('', ':', '-Sep2-', '')

line 1:     " Build up a map command like

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'

line 3:     let plug = '<plug>NERDCommenter' . a:target

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'

line 5:     let plug_end = '", "' . a:target . '")<cr>'

line 6:     " Build up a menu command like

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')

line 11:     if strlen(a:combo)

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo

line 14:     endif

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)

line 16:     " Execute the commands built above for each requested mode.

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 26: menu <silent> &Plugin.&comment.-Sep2- :

line 27:         endif

line 28:     endfor

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 27:         endif

line 28:     endfor

function <SNR>12_CreateMaps returning #0

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 3078: call s:CreateMaps('nx', 'Uncomment',  'Uncomment', 'cu')

calling function <SNR>12_CreateMaps('nx', 'Uncomment', 'Uncomment', 'cu')

line 1:     " Build up a map command like

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'

line 3:     let plug = '<plug>NERDCommenter' . a:target

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'

line 5:     let plug_end = '", "' . a:target . '")<cr>'

line 6:     " Build up a menu command like

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')

line 11:     if strlen(a:combo)

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo

line 14:     endif

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)

line 16:     " Execute the commands built above for each requested mode.

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 19: nnoremap <silent> <plug>NERDCommenterUncomment :call NERDComment("n", "Uncomment")<cr>

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 21: nmap <leader>cu <plug>NERDCommenterUncomment

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 26: nmenu <silent> &Plugin.&comment.Uncomment<Tab>\\cu <plug>NERDCommenterUncomment

line 27:         endif

line 28:     endfor

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 19: xnoremap <silent> <plug>NERDCommenterUncomment :call NERDComment("x", "Uncomment")<cr>

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 21: xmap <leader>cu <plug>NERDCommenterUncomment

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 26: xmenu <silent> &Plugin.&comment.Uncomment<Tab>\\cu <plug>NERDCommenterUncomment

line 27:         endif

line 28:     endfor

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 27:         endif

line 28:     endfor

function <SNR>12_CreateMaps returning #0

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 3079: call s:CreateMaps('n',  'AltDelims',  'Switch Delimiters', 'ca')

calling function <SNR>12_CreateMaps('n', 'AltDelims', 'Switch Delimiters', 'ca')

line 1:     " Build up a map command like

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'

line 3:     let plug = '<plug>NERDCommenter' . a:target

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'

line 5:     let plug_end = '", "' . a:target . '")<cr>'

line 6:     " Build up a menu command like

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')

line 11:     if strlen(a:combo)

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo

line 14:     endif

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)

line 16:     " Execute the commands built above for each requested mode.

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 19: nnoremap <silent> <plug>NERDCommenterAltDelims :call NERDComment("n", "AltDelims")<cr>

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 21: nmap <leader>ca <plug>NERDCommenterAltDelims

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 26: nmenu <silent> &Plugin.&comment.Switch\ Delimiters<Tab>\\ca <plug>NERDCommenterAltDelims

line 27:         endif

line 28:     endfor

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 27:         endif

line 28:     endfor

function <SNR>12_CreateMaps returning #0

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 3080: call s:CreateMaps('i',  'Insert',     'Insert Comment Here', '')

calling function <SNR>12_CreateMaps('i', 'Insert', 'Insert Comment Here', '')

line 1:     " Build up a map command like

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'

line 3:     let plug = '<plug>NERDCommenter' . a:target

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'

line 5:     let plug_end = '", "' . a:target . '")<cr>'

line 6:     " Build up a menu command like

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')

line 11:     if strlen(a:combo)

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo

line 14:     endif

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)

line 16:     " Execute the commands built above for each requested mode.

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 26: imenu <silent> &Plugin.&comment.Insert\ Comment\ Here Insert

line 27:         endif

line 28:     endfor

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 27:         endif

line 28:     endfor

function <SNR>12_CreateMaps returning #0

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 3081: call s:CreateMaps('',   ':',          '-Sep3-', '')

calling function <SNR>12_CreateMaps('', ':', '-Sep3-', '')

line 1:     " Build up a map command like

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'

line 3:     let plug = '<plug>NERDCommenter' . a:target

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'

line 5:     let plug_end = '", "' . a:target . '")<cr>'

line 6:     " Build up a menu command like

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')

line 11:     if strlen(a:combo)

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo

line 14:     endif

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)

line 16:     " Execute the commands built above for each requested mode.

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 26: menu <silent> &Plugin.&comment.-Sep3- :

line 27:         endif

line 28:     endfor

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 27:         endif

line 28:     endfor

function <SNR>12_CreateMaps returning #0

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 3082: call s:CreateMaps('',   ':help NERDCommenterContents<CR>', 'Help', '')

calling function <SNR>12_CreateMaps('', ':help NERDCommenterContents<CR>', 'Help', '')

line 1:     " Build up a map command like

line 2:     " 'noremap <silent> <plug>NERDCommenterComment :call NERDComment("n", "Comment")'

line 3:     let plug = '<plug>NERDCommenter' . a:target

line 4:     let plug_start = 'noremap <silent> ' . plug . ' :call NERDComment("'

line 5:     let plug_end = '", "' . a:target . '")<cr>'

line 6:     " Build up a menu command like

line 7:     " 'menu <silent> comment.Comment<Tab>\\cc <plug>NERDCommenterComment'

line 8:     let menuRoot = get(['', 'comment', '&comment', '&Plugin.&comment'], g:NERDMenuMode, '')

line 10:     let menu_command = 'menu <silent> ' . menuRoot . '.' . escape(a:desc, ' ')

line 11:     if strlen(a:combo)

line 12:         let leader = exists('g:mapleader') ? g:mapleader : '\'

line 13:         let menu_command .= '<Tab>' . escape(leader, '\') . a:combo

line 14:     endif

line 15:     let menu_command .= ' ' . (strlen(a:combo) ? plug : a:target)

line 16:     " Execute the commands built above for each requested mode.

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 26: menu <silent> &Plugin.&comment.Help :help NERDCommenterContents<CR>

line 27:         endif

line 28:     endfor

line 17:     for mode in (a:modes == '') ? [''] : split(a:modes, '\zs')

line 18:         if strlen(a:combo)

line 19:             execute mode . plug_start . mode . plug_end

line 20:             if g:NERDCreateDefaultMappings && !hasmapto(plug, mode)

line 21:                 execute mode . 'map <leader>' . a:combo . ' ' . plug

line 22:             endif

line 23:         endif

line 24:         " Check if the user wants the menu to be displayed.

line 25:         if g:NERDMenuMode != 0

line 26:             execute mode . menu_command

line 27:         endif

line 28:     endfor

function <SNR>12_CreateMaps returning #0

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 3083: 

line 3084: inoremap <silent> <plug>NERDCommenterInsert <SPACE><BS><ESC>:call NERDComment('i', "insert")<CR>

line 3085: 

line 3086: " switch to/from alternative delimiters (does not use wrapper function)

line 3087: nnoremap <plug>NERDCommenterAltDelims :call <SID>SwitchToAlternativeDelimiters(1)<cr>

line 3088: 

line 3089: " This is a workaround to enable lazy-loading from supported plugin managers:

line 3090: " See https://github.com/scrooloose/nerdcommenter/issues/176

line 3091: call s:SetUpForNewFiletype(&filetype, 1)

calling function <SNR>12_SetUpForNewFiletype('', 1)

line 1:     let ft = a:filetype

line 2: 

line 3:     "for compound filetypes, if we don't know how to handle the full filetype

line 4:     "then break it down and use the first part that we know how to handle

line 5:     if ft =~ '\.' && !has_key(s:delimiterMap, ft)

line 6:         let filetypes = split(a:filetype, '\.')

line 7:         for i in filetypes

line 8:             if has_key(s:delimiterMap, i)

line 9:                 let ft = i

line 10:                 break

line 11:             endif

line 12:         endfor

line 13:     endif

line 14: 

line 15:     let b:NERDSexyComMarker = ''

line 16: 

line 17:     if has_key(s:delimiterMap, ft)

line 18:         let b:NERDCommenterDelims = s:delimiterMap[ft]

line 19:         for i in ['left', 'leftAlt', 'right', 'rightAlt']

line 20:             if !has_key(b:NERDCommenterDelims, i)

line 21:                 let b:NERDCommenterDelims[i] = ''

line 22:             endif

line 23:         endfor

line 24:         for i in ['nested', 'nestedAlt']

line 25:             if !has_key(b:NERDCommenterDelims, i)

line 26:                 let b:NERDCommenterDelims[i] = 0

line 27:             endif

line 28:         endfor

line 29:         " if g:NERD_<filetype>_alt_style is defined, use the alternate style

line 30:         let b:NERDCommenterFirstInit = getbufvar(1,"NERDCommenterFirstInit")

line 31:         if exists('g:NERDAltDelims_'.ft) && eval('g:NERDAltDelims_'.ft) && !b:NERDCommenterFirstInit

line 32:             call s:SwitchToAlternativeDelimiters(0)

line 33:             let b:NERDCommenterFirstInit = 1

line 34:         endif

line 35:     else

line 36:         let b:NERDCommenterDelims = s:CreateDelimMapFromCms()

calling function <SNR>12_SetUpForNewFiletype[36]..<SNR>12_CreateDelimMapFromCms()

line 1:     if &ft == '' && exists('g:NERDDefaultDelims')

line 2:         let delims = g:NERDDefaultDelims

line 3:         for i in ['left', 'leftAlt', 'right', 'rightAlt']

line 4:             if !has_key(delims, i)

line 5:                 let delims[i] = ''

line 6:             endif

line 7:         endfor

line 8:         return delims

line 9:     endif

line 10:     return { 'left': substitute(&commentstring, '\([^ \t]*\)\s*%s.*', '\1', ''), 'right': substitute(&commentstring, '.*%s\s*\(.*\)', '\1', 'g'), 'nested': 0, 'leftAlt': '', 'rightAlt': '', 'nestedAlt': 0}

function <SNR>12_SetUpForNewFiletype[36]..<SNR>12_CreateDelimMapFromCms returning {'nestedAlt': 0, 'right': '*/', 'neste...Alt': '', 'left': '/*', 'rightAlt': ''}

continuing in function <SNR>12_SetUpForNewFiletype

line 37:     endif

line 38: 

function <SNR>12_SetUpForNewFiletype returning #0

continuing in /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim

line 3092: 

line 3093: " vim: set foldmethod=marker :

finished sourcing /home/reggiemarr/.vim/plugged/nerdcommenter/plugin/NERD_commenter.vim
Searching for "/etc/xdg/xdg-i3/nvim/plugin/**/*.vim"
Searching for "/etc/xdg/nvim/plugin/**/*.vim"
Searching for "/home/reggiemarr/.local/share/nvim/site/plugin/**/*.vim"
Searching for "/usr/share/i3/nvim/site/plugin/**/*.vim"
Searching for "/usr/local/share/nvim/site/plugin/**/*.vim"
Searching for "/usr/share/nvim/site/plugin/**/*.vim"
Searching for "/var/lib/snapd/desktop/nvim/site/plugin/**/*.vim"
Searching for "/usr/share/nvim/runtime/plugin/**/*.vim"
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/usr/share/nvim/runtime/plugin)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
sourcing "/usr/share/nvim/runtime/plugin/gzip.vim"
line 1: " Vim plugin for editing compressed files.

line 2: " Maintainer: Bram Moolenaar <Bram@vim.org>

line 3: " Last Change: 2016 Oct 30

line 4: 

line 5: " Exit quickly when:

line 6: " - this plugin was already loaded

line 7: " - when 'compatible' is set

line 8: " - some autocommands are already taking care of compressed files

line 9: if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")

line 10:   finish

line 11: endif

line 12: let loaded_gzip = 1

line 13: 

line 14: augroup gzip

line 15:   " Remove all gzip autocommands

line 16:   au!

line 17: 

line 18:   " Enable editing of gzipped files.

line 19:   " The functions are defined in autoload/gzip.vim.

line 20:   "

line 21:   " Set binary mode before reading the file.

line 22:   " Use "gzip -d", gunzip isn't always available.

line 23:   autocmd BufReadPre,FileReadPre^I*.gz,*.bz2,*.Z,*.lzma,*.xz,*.lz,*.zst setlocal bin

line 24:   autocmd BufReadPost,FileReadPost^I*.gz  call gzip#read("gzip -dn")

line 25:   autocmd BufReadPost,FileReadPost^I*.bz2 call gzip#read("bzip2 -d")

line 26:   autocmd BufReadPost,FileReadPost^I*.Z   call gzip#read("uncompress")

line 27:   autocmd BufReadPost,FileReadPost^I*.lzma call gzip#read("lzma -d")

line 28:   autocmd BufReadPost,FileReadPost^I*.xz  call gzip#read("xz -d")

line 29:   autocmd BufReadPost,FileReadPost^I*.lz  call gzip#read("lzip -d")

line 30:   autocmd BufReadPost,FileReadPost^I*.zst call gzip#read("zstd -d --rm")

line 31:   autocmd BufWritePost,FileWritePost^I*.gz  call gzip#write("gzip")

line 32:   autocmd BufWritePost,FileWritePost^I*.bz2 call gzip#write("bzip2")

line 33:   autocmd BufWritePost,FileWritePost^I*.Z   call gzip#write("compress -f")

line 34:   autocmd BufWritePost,FileWritePost^I*.lzma call gzip#write("lzma -z")

line 35:   autocmd BufWritePost,FileWritePost^I*.xz  call gzip#write("xz -z")

line 36:   autocmd BufWritePost,FileWritePost^I*.lz  call gzip#write("lzip")

line 37:   autocmd BufWritePost,FileWritePost^I*.zst  call gzip#write("zstd --rm")

line 38:   autocmd FileAppendPre^I^I^I*.gz  call gzip#appre("gzip -dn")

line 39:   autocmd FileAppendPre^I^I^I*.bz2 call gzip#appre("bzip2 -d")

line 40:   autocmd FileAppendPre^I^I^I*.Z   call gzip#appre("uncompress")

line 41:   autocmd FileAppendPre^I^I^I*.lzma call gzip#appre("lzma -d")

line 42:   autocmd FileAppendPre^I^I^I*.xz   call gzip#appre("xz -d")

line 43:   autocmd FileAppendPre^I^I^I*.lz   call gzip#appre("lzip -d")

line 44:   autocmd FileAppendPre^I^I^I*.zst call gzip#appre("zstd -d --rm")

line 45:   autocmd FileAppendPost^I^I*.gz  call gzip#write("gzip")

line 46:   autocmd FileAppendPost^I^I*.bz2 call gzip#write("bzip2")

line 47:   autocmd FileAppendPost^I^I*.Z   call gzip#write("compress -f")

line 48:   autocmd FileAppendPost^I^I*.lzma call gzip#write("lzma -z")

line 49:   autocmd FileAppendPost^I^I*.xz call gzip#write("xz -z")

line 50:   autocmd FileAppendPost^I^I*.lz call gzip#write("lzip")

line 51:   autocmd FileAppendPost^I^I*.zst call gzip#write("zstd --rm")

line 52: augroup END

finished sourcing /usr/share/nvim/runtime/plugin/gzip.vim
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/usr/share/nvim/runtime/plugin)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
sourcing "/usr/share/nvim/runtime/plugin/health.vim"
line 1: autocmd CmdUndefined CheckHealth checkhealth

finished sourcing /usr/share/nvim/runtime/plugin/health.vim
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/usr/share/nvim/runtime/plugin)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
sourcing "/usr/share/nvim/runtime/plugin/man.vim"
line 1: " Maintainer: Anmol Sethi <anmol@aubble.com>

line 2: 

line 3: if exists('g:loaded_man')

line 4:   finish

line 5: endif

line 6: let g:loaded_man = 1

line 7: 

line 10: command! -bang -bar -range=0 -complete=customlist,man#complete -nargs=* Man if <bang>0 | set ft=man | else | call man#open_page(v:count, v:count1, <q-mods>, <f-args>) | endif

line 11: 

line 12: augroup man

line 13:   autocmd!

line 14:   autocmd BufReadCmd man://* call man#read_page(matchstr(expand('<amatch>'), 'man://\zs.*'))

line 15: augroup END

finished sourcing /usr/share/nvim/runtime/plugin/man.vim
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/usr/share/nvim/runtime/plugin)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
sourcing "/usr/share/nvim/runtime/plugin/matchit.vim"
line 1: "  matchit.vim: (global plugin) Extended "%" matching

line 2: "  Last Change: 2018 Jul 3 by Christian Brabandt

line 3: "  Maintainer:  Benji Fisher PhD   <benji@member.AMS.org>

line 4: "  Version:     1.13.3, for Vim 6.3+

line 5: "^I^IFix from Tommy Allen included.

line 6: "^I^IFix from Fernando Torres included.

line 7: "^I^IImprovement from Ken Takata included.

line 8: "  URL:^I^Ihttp://www.vim.org/script.php?script_id=39

line 9: 

line 10: " Documentation:

line 11: "  The documentation is in a separate file, matchit.txt .

line 12: 

line 13: " Credits:

line 14: "  Vim editor by Bram Moolenaar (Thanks, Bram!)

line 15: "  Original script and design by Raul Segura Acevedo

line 16: "  Support for comments by Douglas Potts

line 17: "  Support for back references and other improvements by Benji Fisher

line 18: "  Support for many languages by Johannes Zellner

line 19: "  Suggestions for improvement, bug reports, and support for additional

line 20: "  languages by Jordi-Albert Batalla, Neil Bird, Servatius Brandt, Mark

line 21: "  Collett, Stephen Wall, Dany St-Amant, Yuheng Xie, and Johannes Zellner.

line 22: 

line 23: " Debugging:

line 24: "  If you'd like to try the built-in debugging commands...

line 25: "   :MatchDebug      to activate debugging for the current buffer

line 26: "  This saves the values of several key script variables as buffer-local

line 27: "  variables.  See the MatchDebug() function, below, for details.

line 28: 

line 29: " TODO:  I should think about multi-line patterns for b:match_words.

line 30: "   This would require an option:  how many lines to scan (default 1).

line 31: "   This would be useful for Python, maybe also for *ML.

line 32: " TODO:  Maybe I should add a menu so that people will actually use some of

line 33: "   the features that I have implemented.

line 34: " TODO:  Eliminate the MultiMatch function.  Add yet another argument to

line 35: "   Match_wrapper() instead.

line 36: " TODO:  Allow :let b:match_words = '\(\(foo\)\(bar\)\):\3\2:end\1'

line 37: " TODO:  Make backrefs safer by using '\V' (very no-magic).

line 38: " TODO:  Add a level of indirection, so that custom % scripts can use my

line 39: "   work but extend it.

line 40: 

line 41: " allow user to prevent loading

line 42: " and prevent duplicate loading

line 43: if exists("loaded_matchit") || &cp

line 44:   finish

line 45: endif

line 46: let loaded_matchit = 1

line 47: let s:last_mps = ""

line 48: let s:last_words = ":"

line 49: let s:patBR = ""

line 50: 

line 51: let s:save_cpo = &cpo

line 52: set cpo&vim

line 53: 

line 54: nnoremap <silent> %  :<C-U>call <SID>Match_wrapper('',1,'n') <CR>

line 55: nnoremap <silent> g% :<C-U>call <SID>Match_wrapper('',0,'n') <CR>

line 56: vnoremap <silent> %  :<C-U>call <SID>Match_wrapper('',1,'v') <CR>m'gv``

line 57: vnoremap <silent> g% :<C-U>call <SID>Match_wrapper('',0,'v') <CR>m'gv``

line 58: onoremap <silent> %  v:<C-U>call <SID>Match_wrapper('',1,'o') <CR>

line 59: onoremap <silent> g% v:<C-U>call <SID>Match_wrapper('',0,'o') <CR>

line 60: 

line 61: " Analogues of [{ and ]} using matching patterns:

line 62: nnoremap <silent> [% :<C-U>call <SID>MultiMatch("bW", "n") <CR>

line 63: nnoremap <silent> ]% :<C-U>call <SID>MultiMatch("W",  "n") <CR>

line 64: vmap [% <Esc>[%m'gv``

line 65: vmap ]% <Esc>]%m'gv``

line 66: " vnoremap <silent> [% :<C-U>call <SID>MultiMatch("bW", "v") <CR>m'gv``

line 67: " vnoremap <silent> ]% :<C-U>call <SID>MultiMatch("W",  "v") <CR>m'gv``

line 68: onoremap <silent> [% v:<C-U>call <SID>MultiMatch("bW", "o") <CR>

line 69: onoremap <silent> ]% v:<C-U>call <SID>MultiMatch("W",  "o") <CR>

line 70: 

line 71: " text object:

line 72: vmap a% <Esc>[%v]%

line 73: 

line 74: " Auto-complete mappings:  (not yet "ready for prime time")

line 75: " TODO Read :help write-plugin for the "right" way to let the user

line 76: " specify a key binding.

line 77: "   let g:match_auto = '<C-]>'

line 78: "   let g:match_autoCR = '<C-CR>'

line 79: " if exists("g:match_auto")

line 80: "   execute "inoremap " . g:match_auto . ' x<Esc>"=<SID>Autocomplete()<CR>Pls'

line 81: " endif

line 82: " if exists("g:match_autoCR")

line 83: "   execute "inoremap " . g:match_autoCR . ' <CR><C-R>=<SID>Autocomplete()<CR>'

line 84: " endif

line 85: " if exists("g:match_gthhoh")

line 86: "   execute "inoremap " . g:match_gthhoh . ' <C-O>:call <SID>Gthhoh()<CR>'

line 87: " endif " gthhoh = "Get the heck out of here!"

line 88: 

line 89: let s:notslash = '\\\@<!\%(\\\\\)*'

line 90: 

line 91: function! s:Match_wrapper(word, forward, mode) range

line 285: 

line 286: " Restore options and do some special handling for Operator-pending mode.

line 287: " The optional argument is the tail of the matching group.

line 288: fun! s:CleanUp(options, mode, startline, startcol, ...)

line 316: 

line 317: " Example (simplified HTML patterns):  if

line 318: "   a:groupBR^I= '<\(\k\+\)>:</\1>'

line 319: "   a:prefix^I= '^.\{3}\('

line 320: "   a:group^I= '<\(\k\+\)>:</\(\k\+\)>'

line 321: "   a:suffix^I= '\).\{2}$'

line 322: "   a:matchline^I=  "123<tag>12" or "123</tag>12"

line 323: " then extract "tag" from a:matchline and return "<tag>:</tag>" .

line 324: fun! s:InsertRefs(groupBR, prefix, group, suffix, matchline)

line 379: 

line 380: " Input a comma-separated list of groups with backrefs, such as

line 381: "   a:groups = '\(foo\):end\1,\(bar\):end\1'

line 382: " and return a comma-separated list of groups with backrefs replaced:

line 383: "   return '\(foo\):end\(foo\),\(bar\):end\(bar\)'

line 384: fun! s:ParseWords(groups)

line 408: 

line 409: " TODO I think this can be simplified and/or made more efficient.

line 410: " TODO What should I do if a:start is out of range?

line 411: " Return a regexp that matches all of a:string, such that

line 412: " matchstr(a:string, regexp) represents the match for a:pat that starts

line 413: " as close to a:start as possible, before being preferred to after, and

line 414: " ends after a:start .

line 415: " Usage:

line 416: " let regexp = s:Wholematch(getline("."), 'foo\|bar', col(".")-1)

line 417: " let i      = match(getline("."), regexp)

line 418: " let j      = matchend(getline("."), regexp)

line 419: " let match  = matchstr(getline("."), regexp)

line 420: fun! s:Wholematch(string, pat, start)

line 430: 

line 431: " No extra arguments:  s:Ref(string, d) will

line 432: " find the d'th occurrence of '\(' and return it, along with everything up

line 433: " to and including the matching '\)'.

line 434: " One argument:  s:Ref(string, d, "start") returns the index of the start

line 435: " of the d'th '\(' and any other argument returns the length of the group.

line 436: " Two arguments:  s:Ref(string, d, "foo", "bar") returns a string to be

line 437: " executed, having the effect of

line 438: "   :let foo = s:Ref(string, d, "start")

line 439: "   :let bar = s:Ref(string, d, "len")

line 440: fun! s:Ref(string, d, ...)

line 481: 

line 482: " Count the number of disjoint copies of pattern in string.

line 483: " If the pattern is a literal string and contains no '0' or '1' characters

line 484: " then s:Count(string, pattern, '0', '1') should be faster than

line 485: " s:Count(string, pattern).

line 486: fun! s:Count(string, pattern, ...)

line 504: 

line 505: " s:Resolve('\(a\)\(b\)', '\(c\)\2\1\1\2') should return table.word, where

line 506: " word = '\(c\)\(b\)\(a\)\3\2' and table = '-32-------'.  That is, the first

line 507: " '\1' in target is replaced by '\(a\)' in word, table[1] = 3, and this

line 508: " indicates that all other instances of '\1' in target are to be replaced

line 509: " by '\3'.  The hard part is dealing with nesting...

line 510: " Note that ":" is an illegal character for source and target,

line 511: " unless it is preceded by "\".

line 512: fun! s:Resolve(source, target, output)

line 559: 

line 560: " Assume a:comma = ",".  Then the format for a:patterns and a:1 is

line 561: "   a:patterns = "<pat1>,<pat2>,..."

line 562: "   a:1 = "<alt1>,<alt2>,..."

line 563: " If <patn> is the first pattern that matches a:string then return <patn>

line 564: " if no optional arguments are given; return <patn>,<altn> if a:1 is given.

line 565: fun! s:Choose(patterns, string, comma, branch, prefix, suffix, ...)

line 600: 

line 601: " Call this function to turn on debugging information.  Every time the main

line 602: " script is run, buffer variables will be saved.  These can be used directly

line 603: " or viewed using the menu items below.

line 604: if !exists(":MatchDebug")

line 605:   command! -nargs=0 MatchDebug call s:Match_debug()

line 606: endif

line 607: 

line 608: fun! s:Match_debug()

line 629: 

line 630: " Jump to the nearest unmatched "(" or "if" or "<tag>" if a:spflag == "bW"

line 631: " or the nearest unmatched "</tag>" or "endif" or ")" if a:spflag == "W".

line 632: " Return a "mark" for the original position, so that

line 633: "   let m = MultiMatch("bW", "n") ... execute m

line 634: " will return to the original position.  If there is a problem, do not

line 635: " move the cursor and return "", unless a count is given, in which case

line 636: " go up or down as many levels as possible and again return "".

line 637: " TODO This relies on the same patterns as % matching.  It might be a good

line 638: " idea to give it its own matching patterns.

line 639: fun! s:MultiMatch(spflag, mode)

line 736: 

line 737: " Search backwards for "if" or "while" or "<tag>" or ...

line 738: " and return "endif" or "endwhile" or "</tag>" or ... .

line 739: " For now, this uses b:match_words and the same script variables

line 740: " as s:Match_wrapper() .  Later, it may get its own patterns,

line 741: " either from a buffer variable or passed as arguments.

line 742: " fun! s:Autocomplete()

line 743: "   echo "autocomplete not yet implemented :-("

line 744: "   if !exists("b:match_words") || b:match_words == ""

line 745: "     return ""

line 746: "   end

line 747: "   let startpos = s:MultiMatch("bW")

line 748: "

line 749: "   if startpos == ""

line 750: "     return ""

line 751: "   endif

line 752: "   " - TODO:  figure out whether 'if' or '<tag>' matched, and construct

line 753: "   " - the appropriate closing.

line 754: "   let matchline = getline(".")

line 755: "   let curcol = col(".") - 1

line 756: "   " - TODO:  Change the s:all argument if there is a new set of match pats.

line 757: "   let regexp = s:Wholematch(matchline, s:all, curcol)

line 758: "   let suf = strlen(matchline) - matchend(matchline, regexp)

line 759: "   let prefix = (curcol ? '^.\{'  . curcol . '}\%(' : '^\%(')

line 760: "   let suffix = (suf ? '\).\{' . suf . '}$'  : '\)$')

line 761: "   " Reconstruct the version with unresolved backrefs.

line 762: "   let patBR = substitute(b:match_words.',', '[,:]*,[,:]*', ',', 'g')

line 763: "   let patBR = substitute(patBR, ':\{2,}', ':', "g")

line 764: "   " Now, set group and groupBR to the matching group: 'if:endif' or

line 765: "   " 'while:endwhile' or whatever.

line 766: "   let group = s:Choose(s:pat, matchline, ",", ":", prefix, suffix, patBR)

line 767: "   let i = matchend(group, s:notslash . ",")

line 768: "   let groupBR = strpart(group, i)

line 769: "   let group = strpart(group, 0, i-1)

line 770: "   " Now, matchline =~ prefix . substitute(group,':','\|','g') . suffix

line 771: "   if s:do_BR

line 772: "     let group = s:InsertRefs(groupBR, prefix, group, suffix, matchline)

line 773: "   endif

line 774: " " let g:group = group

line 775: "

line 776: "   " - TODO:  Construct the closing from group.

line 777: "   let fake = "end" . expand("<cword>")

line 778: "   execute startpos

line 779: "   return fake

line 780: " endfun

line 781: 

line 782: " Close all open structures.  "Get the heck out of here!"

line 783: " fun! s:Gthhoh()

line 784: "   let close = s:Autocomplete()

line 785: "   while strlen(close)

line 786: "     put=close

line 787: "     let close = s:Autocomplete()

line 788: "   endwhile

line 789: " endfun

line 790: 

line 791: " Parse special strings as typical skip arguments for searchpair():

line 792: "   s:foo becomes (current syntax item) =~ foo

line 793: "   S:foo becomes (current syntax item) !~ foo

line 794: "   r:foo becomes (line before cursor) =~ foo

line 795: "   R:foo becomes (line before cursor) !~ foo

line 796: fun! s:ParseSkip(str)

line 813: 

line 814: let &cpo = s:save_cpo

line 815: unlet s:save_cpo

line 816: 

line 817: " vim:sts=2:sw=2:

finished sourcing /usr/share/nvim/runtime/plugin/matchit.vim
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/usr/share/nvim/runtime/plugin)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
sourcing "/usr/share/nvim/runtime/plugin/matchparen.vim"
line 1: " Vim plugin for showing matching parens

line 2: " Maintainer:  Bram Moolenaar <Bram@vim.org>

line 3: " Last Change: 2018 Jul 3

line 4: 

line 5: " Exit quickly when:

line 6: " - this plugin was already loaded (or disabled)

line 7: " - when 'compatible' is set

line 8: " - the "CursorMoved" autocmd event is not available.

line 9: if exists("g:loaded_matchparen") || &cp || !exists("##CursorMoved")

line 10:   finish

line 11: endif

line 12: let g:loaded_matchparen = 1

line 13: 

line 14: if !exists("g:matchparen_timeout")

line 15:   let g:matchparen_timeout = 300

line 16: endif

line 17: if !exists("g:matchparen_insert_timeout")

line 18:   let g:matchparen_insert_timeout = 60

line 19: endif

line 20: 

line 21: augroup matchparen

line 22:   " Replace all matchparen autocommands

line 23:   autocmd! CursorMoved,CursorMovedI,WinEnter * call s:Highlight_Matching_Pair()

line 24:   if exists('##TextChanged')

line 25:     autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()

line 26:   endif

line 27: augroup END

line 28: 

line 29: " Skip the rest if it was already done.

line 30: if exists("*s:Highlight_Matching_Pair")

line 31:   finish

line 32: endif

line 33: 

line 34: let s:cpo_save = &cpo

line 35: set cpo-=C

line 36: 

line 37: " The function that is invoked (very often) to define a ":match" highlighting

line 38: " for any matching paren.

line 39: function! s:Highlight_Matching_Pair()

line 197: 

line 198: " Define commands that will disable and enable the plugin.

line 199: command! DoMatchParen call s:DoMatchParen()

line 200: command! NoMatchParen call s:NoMatchParen()

line 201: 

line 202: func! s:NoMatchParen()

line 209: 

line 210: func! s:DoMatchParen()

line 216: 

line 217: let &cpo = s:cpo_save

line 218: unlet s:cpo_save

finished sourcing /usr/share/nvim/runtime/plugin/matchparen.vim
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/usr/share/nvim/runtime/plugin)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
sourcing "/usr/share/nvim/runtime/plugin/netrwPlugin.vim"
line 1: " netrwPlugin.vim: Handles file transfer and remote directory listing across a network

line 2: "            PLUGIN SECTION

line 3: " Date:^I^IFeb 08, 2016

line 4: " Maintainer:^ICharles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>

line 5: " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim

line 6: " Copyright:    Copyright (C) 1999-2013 Charles E. Campbell {{{1

line 7: "               Permission is hereby granted to use and distribute this code,

line 8: "               with or without modifications, provided that this copyright

line 9: "               notice is copied with it. Like anything else that's free,

line 10: "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided

line 11: "               *as is* and comes with no warranty of any kind, either

line 12: "               expressed or implied. By using this plugin, you agree that

line 13: "               in no event will the copyright holder be liable for any damages

line 14: "               resulting from the use of this software.

line 15: "

line 16: "  But be doers of the Word, and not only hearers, deluding your own selves {{{1

line 17: "  (James 1:22 RSV)

line 18: " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

line 19: " Load Once: {{{1

line 20: if &cp || exists("g:loaded_netrwPlugin")

line 21:  finish

line 22: endif

line 23: let g:loaded_netrwPlugin = "v156"

line 24: let s:keepcpo = &cpo

line 25: set cpo&vim

line 26: "DechoRemOn

line 27: 

line 28: " ---------------------------------------------------------------------

line 29: " Public Interface: {{{1

line 30: 

line 31: " Local Browsing Autocmds: {{{2

line 32: augroup FileExplorer

line 33:  au!

line 34:  au BufLeave *  if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif

line 35:  au BufEnter *^Isil call s:LocalBrowse(expand("<amatch>"))

line 36:  au VimEnter *^Isil call s:VimEnter(expand("<amatch>"))

line 37:  if has("win32") || has("win95") || has("win64") || has("win16")

line 38:   au BufEnter .* sil call s:LocalBrowse(expand("<amatch>"))

line 39:  endif

line 40: augroup END

line 41: 

line 42: " Network Browsing Reading Writing: {{{2

line 43: augroup Network

line 44:  au!

line 45:  au BufReadCmd   file://*^I^I^I^I^I^I^I^I^I^I^Icall netrw#FileUrlRead(expand("<amatch>"))

line 46:  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))

line 47:  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))

line 48:  au BufWriteCmd  ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))

line 49:  au FileWriteCmd ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))

line 50:  try                                                       

line 51:   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))

line 52:  catch /^Vim\%((\a\+)\)\=:E216/                            

line 53:   au SourcePre   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))

line 54:  endtry

line 55: augroup END

line 56: 

line 57: " Commands: :Nread, :Nwrite, :NetUserPass {{{2

line 58: com! -count=1 -nargs=*^INread^I^Ilet s:svpos= winsaveview()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call winrestview(s:svpos)

line 59: com! -range=% -nargs=*^INwrite^I^Ilet s:svpos= winsaveview()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call winrestview(s:svpos)

line 60: com! -nargs=*^I^INetUserPass^Icall NetUserPass(<f-args>)

line 61: com! -nargs=*^I        Nsource^I^Ilet s:svpos= winsaveview()<bar>call netrw#NetSource(<f-args>)<bar>call winrestview(s:svpos)

line 62: com! -nargs=?^I^INtree^I^Icall netrw#SetTreetop(<q-args>)

line 63: 

line 64: " Commands: :Explore, :Sexplore, Hexplore, Vexplore, Lexplore {{{2

line 65: com! -nargs=* -bar -bang -count=0 -complete=dir^IExplore^I^Icall netrw#Explore(<count>,0,0+<bang>0,<q-args>)

line 66: com! -nargs=* -bar -bang -count=0 -complete=dir^ISexplore^Icall netrw#Explore(<count>,1,0+<bang>0,<q-args>)

line 67: com! -nargs=* -bar -bang -count=0 -complete=dir^IHexplore^Icall netrw#Explore(<count>,1,2+<bang>0,<q-args>)

line 68: com! -nargs=* -bar -bang -count=0 -complete=dir^IVexplore^Icall netrw#Explore(<count>,1,4+<bang>0,<q-args>)

line 69: com! -nargs=* -bar       -count=0 -complete=dir^ITexplore^Icall netrw#Explore(<count>,0,6        ,<q-args>)

line 70: com! -nargs=* -bar -bang^I^I^INexplore^Icall netrw#Explore(-1,0,0,<q-args>)

line 71: com! -nargs=* -bar -bang^I^I^IPexplore^Icall netrw#Explore(-2,0,0,<q-args>)

line 72: com! -nargs=* -bar -bang -count=0 -complete=dir Lexplore^Icall netrw#Lexplore(<count>,<bang>0,<q-args>)

line 73: 

line 74: " Commands: NetrwSettings {{{2

line 75: com! -nargs=0^INetrwSettings^Icall netrwSettings#NetrwSettings()

line 76: com! -bang^INetrwClean^Icall netrw#Clean(<bang>0)

line 77: 

line 78: " Maps:

line 79: if !exists("g:netrw_nogx")

line 80:  if maparg('gx','n') == ""

line 81:   if !hasmapto('<Plug>NetrwBrowseX')

line 82:    nmap <unique> gx <Plug>NetrwBrowseX

line 83:   endif

line 84:   nno <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(expand((exists("g:netrw_gx")? g:netrw_gx : '<cfile>')),netrw#CheckIfRemote())<cr>

line 85:  endif

line 86:  if maparg('gx','v') == ""

line 87:   if !hasmapto('<Plug>NetrwBrowseXVis')

line 88:    vmap <unique> gx <Plug>NetrwBrowseXVis

line 89:   endif

line 90:   vno <silent> <Plug>NetrwBrowseXVis :<c-u>call netrw#BrowseXVis()<cr>

line 91:  endif

line 92: endif

line 93: if exists("g:netrw_usetab") && g:netrw_usetab

line 94:  if maparg('<c-tab>','n') == ""

line 95:   nmap <unique> <c-tab> <Plug>NetrwShrink

line 96:  endif

line 97:  nno <silent> <Plug>NetrwShrink :call netrw#Shrink()<cr>

line 98: endif

line 99: 

line 100: " ---------------------------------------------------------------------

line 101: " LocalBrowse: invokes netrw#LocalBrowseCheck() on directory buffers {{{2

line 102: fun! s:LocalBrowse(dirname)

line 148: 

line 149: " ---------------------------------------------------------------------

line 150: " s:VimEnter: after all vim startup stuff is done, this function is called. {{{2

line 151: "             Its purpose: to look over all windows and run s:LocalBrowse() on

line 152: "             them, which checks if they're directories and will create a directory

line 153: "             listing when appropriate.

line 154: "             It also sets s:vimentered, letting s:LocalBrowse() know that s:VimEnter()

line 155: "             has already been called.

line 156: fun! s:VimEnter(dirname)

line 164: 

line 165: " ---------------------------------------------------------------------

line 166: " NetrwStatusLine: {{{1

line 167: fun! NetrwStatusLine()

line 178: 

line 179: " ------------------------------------------------------------------------

line 180: " NetUserPass: set username and password for subsequent ftp transfer {{{1

line 181: "   Usage:  :call NetUserPass()^I^I^I-- will prompt for userid and password

line 182: "^I    :call NetUserPass("uid")^I^I-- will prompt for password

line 183: "^I    :call NetUserPass("uid","password") -- sets global userid and password

line 184: fun! NetUserPass(...)

line 208: 

line 209: " ------------------------------------------------------------------------

line 210: " Modelines And Restoration: {{{1

line 211: let &cpo= s:keepcpo

line 212: unlet s:keepcpo

line 213: " vim:ts=8 fdm=marker

finished sourcing /usr/share/nvim/runtime/plugin/netrwPlugin.vim
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/usr/share/nvim/runtime/plugin)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
sourcing "/usr/share/nvim/runtime/plugin/rplugin.vim"
line 1: if exists('g:loaded_remote_plugins')

line 2:   finish

line 3: endif

line 4: let g:loaded_remote_plugins = '/path/to/manifest'

line 5: 

line 6: " Get the path to the rplugin manifest file.

line 7: function! s:GetManifestPath() abort

line 24: 

line 25: " Old manifest file based on known script locations.

line 26: function! s:GetOldManifestPaths() abort

line 41: 

line 42: function! s:GetManifest() abort

line 55: 

line 56: function! s:LoadRemotePlugins() abort

line 62: 

line 63: command! -bar UpdateRemotePlugins call remote#host#UpdateRemotePlugins()

line 64: 

line 65: call s:LoadRemotePlugins()

calling function <SNR>19_LoadRemotePlugins()

line 1:   let g:loaded_remote_plugins = s:GetManifest()

calling function <SNR>19_LoadRemotePlugins[1]..<SNR>19_GetManifest()

line 1:   let manifest = s:GetManifestPath()

calling function <SNR>19_LoadRemotePlugins[1]..<SNR>19_GetManifest[1]..<SNR>19_GetManifestPath()

line 1:   let manifest_base = ''

line 2: 

line 3:   if exists('$NVIM_RPLUGIN_MANIFEST')

line 4:     return fnamemodify($NVIM_RPLUGIN_MANIFEST, ':p')

line 5:   endif

line 6: 

line 7:   let dest = stdpath('data')

line 8:   if !empty(dest)

line 9:     if !isdirectory(dest)

line 10:       call mkdir(dest, 'p', 0700)

line 11:     endif

line 12:     let manifest_base = dest

line 13:   endif

line 14: 

line 15:   return manifest_base.'/rplugin.vim'

function <SNR>19_LoadRemotePlugins[1]..<SNR>19_GetManifest[1]..<SNR>19_GetManifestPath returning '/home/reggiemarr/.local/share/nvim/rplugin.vim'

continuing in function <SNR>19_LoadRemotePlugins[1]..<SNR>19_GetManifest

line 2:   if !filereadable(manifest)

line 3:     " Check if an old manifest file exists and move it to the new location.

line 4:     for old_manifest in s:GetOldManifestPaths()

line 5:       if filereadable(old_manifest)

line 6:         call rename(old_manifest, manifest)

line 7:         break

line 8:       endif

line 9:     endfor

line 10:   endif

line 11:   return manifest

function <SNR>19_LoadRemotePlugins[1]..<SNR>19_GetManifest returning '/home/reggiemarr/.local/share/nvim/rplugin.vim'

continuing in function <SNR>19_LoadRemotePlugins

line 2:   if filereadable(g:loaded_remote_plugins)

line 3:     execute 'source' fnameescape(g:loaded_remote_plugins)

line 3: source /home/reggiemarr/.local/share/nvim/rplugin.vim

chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/home/reggiemarr/.local/share/nvim)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
line 3: sourcing "/home/reggiemarr/.local/share/nvim/rplugin.vim"
line 1: " node plugins

line 2: 

line 3: 

line 4: " python3 plugins

line 7: call remote#host#RegisterPlugin('python3', '/home/reggiemarr/.vim/plugged/deoplete.nvim/rplugin/python3/deoplete', [ {'sync': v:false, 'name': '_deoplete_init', 'type': 'function', 'opts': {}}, ])

Searching for "autoload/remote/host.vim" in "/home/reggiemarr/.config/nvim,/home/reggiemarr/.vim/plugged/LanguageClient-neovim,/home/reggiemarr/.vim/plugged/ncm2,/home/reggiemarr/.vim/plugged/nvim-yarp,/home/reggiemarr/.vim/plugged/ncm2-bufword,/home/reggiemarr/.vim/plugged/ncm2-path,/home/reggiemarr/.vim/plugged/fzf,/home/reggiemarr/.vim/plugged/nerdcommenter,/etc/xdg/xdg-i3/nvim,/etc/xdg/nvim,/home/reggiemarr/.local/share/nvim/site,/usr/share/i3/nvim/site,/usr/local/share/nvim/site,/usr/share/nvim/site,/var/lib/snapd/desktop/nvim/site,/usr/share/nvim/runtime,/var/lib/snapd/desktop/nvim/site/after,/usr/share/nvim/site/after,/usr/local/share/nvim/site/after,/usr/share/i3/nvim/site/after,/home/reggiemarr/.local/share/nvim/site/after,/etc/xdg/nvim/after,/etc/xdg/xdg-i3/nvim/after,/home/reggiemarr/.config/nvim/after"
Searching for "/home/reggiemarr/.config/nvim/autoload/remote/host.vim"
Searching for "/home/reggiemarr/.vim/plugged/LanguageClient-neovim/autoload/remote/host.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2/autoload/remote/host.vim"
Searching for "/home/reggiemarr/.vim/plugged/nvim-yarp/autoload/remote/host.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2-bufword/autoload/remote/host.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2-path/autoload/remote/host.vim"
Searching for "/home/reggiemarr/.vim/plugged/fzf/autoload/remote/host.vim"
Searching for "/home/reggiemarr/.vim/plugged/nerdcommenter/autoload/remote/host.vim"
Searching for "/etc/xdg/xdg-i3/nvim/autoload/remote/host.vim"
Searching for "/etc/xdg/nvim/autoload/remote/host.vim"
Searching for "/home/reggiemarr/.local/share/nvim/site/autoload/remote/host.vim"
Searching for "/usr/share/i3/nvim/site/autoload/remote/host.vim"
Searching for "/usr/local/share/nvim/site/autoload/remote/host.vim"
Searching for "/usr/share/nvim/site/autoload/remote/host.vim"
Searching for "/var/lib/snapd/desktop/nvim/site/autoload/remote/host.vim"
Searching for "/usr/share/nvim/runtime/autoload/remote/host.vim"
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/usr/share/nvim/runtime/autoload/remote)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
line 7: sourcing "/usr/share/nvim/runtime/autoload/remote/host.vim"
line 1: let s:hosts = {}

line 2: let s:plugin_patterns = {}

line 3: let s:plugins_for_host = {}

line 4: 

line 5: " Register a host by associating it with a factory(funcref)

line 6: function! remote#host#Register(name, pattern, factory) abort

line 14: 

line 15: " Register a clone to an existing host. The new host will use the same factory

line 16: " as `source`, but it will run as a different process. This can be used by

line 17: " plugins that should run isolated from other plugins created for the same host

line 18: " type

line 19: function! remote#host#RegisterClone(name, orig_name) abort

line 31: 

line 32: " Get a host channel, bootstrapping it if necessary

line 33: function! remote#host#Require(name) abort

line 48: 

line 49: function! remote#host#IsRunning(name) abort

line 55: 

line 56: " Example of registering a Python plugin with two commands (one async), one

line 57: " autocmd (async) and one function (sync):

line 58: "

line 59: " let s:plugin_path = expand('<sfile>:p:h').'/nvim_plugin.py'

line 60: " call remote#host#RegisterPlugin('python', s:plugin_path, [

line 61: "   \ {'type': 'command', 'name': 'PyCmd', 'sync': 1, 'opts': {}},

line 62: "   \ {'type': 'command', 'name': 'PyAsyncCmd', 'sync': 0, 'opts': {'eval': 'cursor()'}},

line 63: "   \ {'type': 'autocmd', 'name': 'BufEnter', 'sync': 0, 'opts': {'eval': 'expand("<afile>")'}},

line 64: "   \ {'type': 'function', 'name': 'PyFunc', 'sync': 1, 'opts': {}}

line 65: "   \ ])

line 66: "

line 67: " The third item in a declaration is a boolean: non zero means the command,

line 68: " autocommand or function will be executed synchronously with rpcrequest.

line 69: function! remote#host#RegisterPlugin(host, path, specs) abort

line 111: 

line 112: function! s:RegistrationCommands(host) abort

line 155: 

line 156: function! remote#host#UpdateRemotePlugins() abort

line 176: 

line 177: function! remote#host#PluginsForHost(host) abort

line 183: 

line 184: function! remote#host#LoadErrorForHost(host, log) abort

line 190: 

line 191: " Registration of standard hosts

line 192: 

line 193: " Python/Python3

line 195: call remote#host#Register('python', '*', function('provider#pythonx#Require'))

calling function remote#host#Register('python', '*', function('provider#pythonx#Require'))

line 1:   let s:hosts[a:name] = {'factory': a:factory, 'channel': 0, 'initialized': 0}

line 2:   let s:plugin_patterns[a:name] = a:pattern

line 3:   if type(a:factory) == type(1) && a:factory

line 4:     " Passed a channel directly

line 5:     let s:hosts[a:name].channel = a:factory

line 6:   endif

function remote#host#Register returning #0

continuing in /usr/share/nvim/runtime/autoload/remote/host.vim

line 197: call remote#host#Register('python3', '*', function('provider#pythonx#Require'))

calling function remote#host#Register('python3', '*', function('provider#pythonx#Require'))

line 1:   let s:hosts[a:name] = {'factory': a:factory, 'channel': 0, 'initialized': 0}

line 2:   let s:plugin_patterns[a:name] = a:pattern

line 3:   if type(a:factory) == type(1) && a:factory

line 4:     " Passed a channel directly

line 5:     let s:hosts[a:name].channel = a:factory

line 6:   endif

function remote#host#Register returning #0

continuing in /usr/share/nvim/runtime/autoload/remote/host.vim

line 198: 

line 199: " Ruby

line 201: call remote#host#Register('ruby', '*.rb', function('provider#ruby#Require'))

calling function remote#host#Register('ruby', '*.rb', function('provider#ruby#Require'))

line 1:   let s:hosts[a:name] = {'factory': a:factory, 'channel': 0, 'initialized': 0}

line 2:   let s:plugin_patterns[a:name] = a:pattern

line 3:   if type(a:factory) == type(1) && a:factory

line 4:     " Passed a channel directly

line 5:     let s:hosts[a:name].channel = a:factory

line 6:   endif

function remote#host#Register returning #0

continuing in /usr/share/nvim/runtime/autoload/remote/host.vim

line 202: 

line 203: " nodejs

line 205: call remote#host#Register('node', '*', function('provider#node#Require'))

calling function remote#host#Register('node', '*', function('provider#node#Require'))

line 1:   let s:hosts[a:name] = {'factory': a:factory, 'channel': 0, 'initialized': 0}

line 2:   let s:plugin_patterns[a:name] = a:pattern

line 3:   if type(a:factory) == type(1) && a:factory

line 4:     " Passed a channel directly

line 5:     let s:hosts[a:name].channel = a:factory

line 6:   endif

function remote#host#Register returning #0

continuing in /usr/share/nvim/runtime/autoload/remote/host.vim

finished sourcing /usr/share/nvim/runtime/autoload/remote/host.vim
continuing in /home/reggiemarr/.local/share/nvim/rplugin.vim
calling function remote#host#RegisterPlugin('python3', '/home/reggiemarr/.vim/plugged/deoplete.nvim/rplugin/python3/deoplete', [{'sync': v:false, 'name': '_deoplete_init', 'type': 'function', 'opts': {}}])

line 1:   let plugins = remote#host#PluginsForHost(a:host)

calling function remote#host#RegisterPlugin[1]..remote#host#PluginsForHost('python3')

line 1:   if !has_key(s:plugins_for_host, a:host)

line 2:     let s:plugins_for_host[a:host] = []

line 3:   end

line 4:   return s:plugins_for_host[a:host]

function remote#host#RegisterPlugin[1]..remote#host#PluginsForHost returning []

continuing in function remote#host#RegisterPlugin

line 2: 

line 3:   for plugin in plugins

line 4:     if plugin.path == a:path

line 5:       throw 'Plugin "'.a:path.'" is already registered'

line 6:     endif

line 7:   endfor

line 8: 

line 9:   if has_key(s:hosts, a:host) && remote#host#IsRunning(a:host)

calling function remote#host#RegisterPlugin[9]..remote#host#IsRunning('python3')

line 1:   if !has_key(s:hosts, a:name)

line 2:     throw 'No host named "'.a:name.'" is registered'

line 3:   endif

line 4:   return s:hosts[a:name].channel != 0

function remote#host#RegisterPlugin[9]..remote#host#IsRunning returning #0

continuing in function remote#host#RegisterPlugin

line 10:     " For now we won't allow registration of plugins when the host is already

line 11:     " running.

line 12:     throw 'Host "'.a:host.'" is already running'

line 13:   endif

line 14: 

line 15:   for spec in a:specs

line 16:     let type = spec.type

line 17:     let name = spec.name

line 18:     let sync = spec.sync

line 19:     let opts = spec.opts

line 20:     let rpc_method = a:path

line 21:     if type == 'command'

line 22:       let rpc_method .= ':command:'.name

line 23:       call remote#define#CommandOnHost(a:host, rpc_method, sync, name, opts)

line 24:     elseif type == 'autocmd'

line 25:       " Since multiple handlers can be attached to the same autocmd event by a

line 26:       " single plugin, we need a way to uniquely identify the rpc method to

line 27:       " call.  The solution is to append the autocmd pattern to the method

line 28:       " name(This still has a limit: one handler per event/pattern combo, but

line 29:       " there's no need to allow plugins define multiple handlers in that case)

line 30:       let rpc_method .= ':autocmd:'.name.':'.get(opts, 'pattern', '*')

line 31:       call remote#define#AutocmdOnHost(a:host, rpc_method, sync, name, opts)

line 32:     elseif type == 'function'

line 33:       let rpc_method .= ':function:'.name

line 34:       call remote#define#FunctionOnHost(a:host, rpc_method, sync, name, opts)

Searching for "autoload/remote/define.vim" in "/home/reggiemarr/.config/nvim,/home/reggiemarr/.vim/plugged/LanguageClient-neovim,/home/reggiemarr/.vim/plugged/ncm2,/home/reggiemarr/.vim/plugged/nvim-yarp,/home/reggiemarr/.vim/plugged/ncm2-bufword,/home/reggiemarr/.vim/plugged/ncm2-path,/home/reggiemarr/.vim/plugged/fzf,/home/reggiemarr/.vim/plugged/nerdcommenter,/etc/xdg/xdg-i3/nvim,/etc/xdg/nvim,/home/reggiemarr/.local/share/nvim/site,/usr/share/i3/nvim/site,/usr/local/share/nvim/site,/usr/share/nvim/site,/var/lib/snapd/desktop/nvim/site,/usr/share/nvim/runtime,/var/lib/snapd/desktop/nvim/site/after,/usr/share/nvim/site/after,/usr/local/share/nvim/site/after,/usr/share/i3/nvim/site/after,/home/reggiemarr/.local/share/nvim/site/after,/etc/xdg/nvim/after,/etc/xdg/xdg-i3/nvim/after,/home/reggiemarr/.config/nvim/after"
Searching for "/home/reggiemarr/.config/nvim/autoload/remote/define.vim"
Searching for "/home/reggiemarr/.vim/plugged/LanguageClient-neovim/autoload/remote/define.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2/autoload/remote/define.vim"
Searching for "/home/reggiemarr/.vim/plugged/nvim-yarp/autoload/remote/define.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2-bufword/autoload/remote/define.vim"
Searching for "/home/reggiemarr/.vim/plugged/ncm2-path/autoload/remote/define.vim"
Searching for "/home/reggiemarr/.vim/plugged/fzf/autoload/remote/define.vim"
Searching for "/home/reggiemarr/.vim/plugged/nerdcommenter/autoload/remote/define.vim"
Searching for "/etc/xdg/xdg-i3/nvim/autoload/remote/define.vim"
Searching for "/etc/xdg/nvim/autoload/remote/define.vim"
Searching for "/home/reggiemarr/.local/share/nvim/site/autoload/remote/define.vim"
Searching for "/usr/share/i3/nvim/site/autoload/remote/define.vim"
Searching for "/usr/local/share/nvim/site/autoload/remote/define.vim"
Searching for "/usr/share/nvim/site/autoload/remote/define.vim"
Searching for "/var/lib/snapd/desktop/nvim/site/autoload/remote/define.vim"
Searching for "/usr/share/nvim/runtime/autoload/remote/define.vim"
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/usr/share/nvim/runtime/autoload/remote)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
line 34: sourcing "/usr/share/nvim/runtime/autoload/remote/define.vim"
line 1: function! remote#define#CommandOnHost(host, method, sync, name, opts)

line 39: 

line 40: 

line 41: function! remote#define#CommandBootstrap(host, method, sync, name, opts, forward)

line 52: 

line 53: 

line 54: function! remote#define#CommandOnChannel(channel, method, sync, name, opts)

line 88: 

line 89: 

line 90: function! remote#define#AutocmdOnHost(host, method, sync, name, opts)

line 105: 

line 106: 

line 107: function! remote#define#AutocmdBootstrap(host, method, sync, name, opts, forward)

line 120: 

line 121: 

line 122: function! remote#define#AutocmdOnChannel(channel, method, sync, name, opts)

line 130: 

line 131: 

line 132: function! remote#define#FunctionOnHost(host, method, sync, name, opts)

line 143: 

line 144: 

line 145: function! remote#define#FunctionBootstrap(host, method, sync, name, opts, group)

line 157: 

line 158: 

line 159: function! remote#define#FunctionOnChannel(channel, method, sync, name, opts)

line 171: 

line 172: let s:busy = {}

line 173: let s:pending_notifications = {}

line 174: 

line 175: function! s:GetRpcFunction(sync)

line 183: 

line 184: function! remote#define#notify(chan, ...)

line 193: 

line 194: function! remote#define#request(chan, ...)

line 206: 

line 207: function! s:GetCommandPrefix(name, opts)

line 211: 

line 212: 

line 213: " Each msgpack-rpc autocommand has it's own unique group, which is derived

line 214: " from an autoincrementing gid(group id). This is required for replacing the

line 215: " autocmd implementation with the lazy-load mechanism

line 216: let s:next_gid = 1

line 217: function! s:GetNextAutocmdGroup()

line 226: 

line 227: 

line 228: function! s:GetAutocmdPrefix(name, opts)

line 248: 

line 249: 

line 250: function! s:GetFunctionPrefix(name, opts)

line 257: 

line 258: 

line 259: function! s:StringifyOpts(opts, keys)

line 272: 

line 273: 

line 274: function! s:AddEval(rpcargs, opts)

finished sourcing /usr/share/nvim/runtime/autoload/remote/define.vim
continuing in function remote#host#RegisterPlugin
calling function remote#host#RegisterPlugin[34]..remote#define#FunctionOnHost('python3', '/home/reggiemarr/.vim/plugged/deoplet...thon3/deoplete:function:_deoplete_init', v:false, '_deoplete_init', {})

line 1:   let group = s:GetNextAutocmdGroup()

calling function remote#host#RegisterPlugin[34]..remote#define#FunctionOnHost[1]..<SNR>22_GetNextAutocmdGroup()

line 1:   let gid = s:next_gid

line 2:   let s:next_gid += 1

line 3: 

line 4:   let group_name = 'RPC_DEFINE_AUTOCMD_GROUP_'.gid

line 5:   " Ensure the group is defined

line 6:   exe 'augroup '.group_name.' | augroup END'

line 6: augroup RPC_DEFINE_AUTOCMD_GROUP_1 | augroup END

line 6:  augroup END

line 7:   return group_name

function remote#host#RegisterPlugin[34]..remote#define#FunctionOnHost[1]..<SNR>22_GetNextAutocmdGroup returning 'RPC_DEFINE_AUTOCMD_GROUP_1'

continuing in function remote#host#RegisterPlugin[34]..remote#define#FunctionOnHost

line 2:   exe 'autocmd! '.group.' FuncUndefined '.a:name .' call remote#define#FunctionBootstrap("'.a:host.'"' .                                 ', "'.a:method.'"' .                                 ', '.string(a:sync) .                                 ', "'.a:name.'"' .                                 ', '.string(a:opts) .                                 ', "'.group.'"' .                                 ')'

line 2: autocmd! RPC_DEFINE_AUTOCMD_GROUP_1 FuncUndefined _deoplete_init call remote#define#FunctionBootstrap("python3", "/home/reggiemarr/.vim/plugged/deoplete.nvim/rplugin/python3/deoplete:function:_deoplete_init", v:false, "_deoplete_init", {}, "RPC_DEFINE_AUTOCMD_GROUP_1")

function remote#host#RegisterPlugin[34]..remote#define#FunctionOnHost returning #0

continuing in function remote#host#RegisterPlugin

line 35:     else

line 36:       echoerr 'Invalid declaration type: '.type

line 37:     endif

line 38:   endfor

line 15:   for spec in a:specs

line 16:     let type = spec.type

line 17:     let name = spec.name

line 18:     let sync = spec.sync

line 19:     let opts = spec.opts

line 20:     let rpc_method = a:path

line 21:     if type == 'command'

line 22:       let rpc_method .= ':command:'.name

line 23:       call remote#define#CommandOnHost(a:host, rpc_method, sync, name, opts)

line 24:     elseif type == 'autocmd'

line 25:       " Since multiple handlers can be attached to the same autocmd event by a

line 26:       " single plugin, we need a way to uniquely identify the rpc method to

line 27:       " call.  The solution is to append the autocmd pattern to the method

line 28:       " name(This still has a limit: one handler per event/pattern combo, but

line 29:       " there's no need to allow plugins define multiple handlers in that case)

line 30:       let rpc_method .= ':autocmd:'.name.':'.get(opts, 'pattern', '*')

line 31:       call remote#define#AutocmdOnHost(a:host, rpc_method, sync, name, opts)

line 32:     elseif type == 'function'

line 33:       let rpc_method .= ':function:'.name

line 34:       call remote#define#FunctionOnHost(a:host, rpc_method, sync, name, opts)

line 35:     else

line 36:       echoerr 'Invalid declaration type: '.type

line 37:     endif

line 38:   endfor

line 39: 

line 40:   call add(plugins, {'path': a:path, 'specs': a:specs})

function remote#host#RegisterPlugin returning #0

continuing in /home/reggiemarr/.local/share/nvim/rplugin.vim

line 8: 

line 9: 

line 10: " ruby plugins

line 11: 

line 12: 

line 13: " python plugins

line 14: 

line 15: 

finished sourcing /home/reggiemarr/.local/share/nvim/rplugin.vim
continuing in function <SNR>19_LoadRemotePlugins
line 4:   endif

function <SNR>19_LoadRemotePlugins returning #0

continuing in /usr/share/nvim/runtime/plugin/rplugin.vim

finished sourcing /usr/share/nvim/runtime/plugin/rplugin.vim
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/usr/share/nvim/runtime/plugin)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
sourcing "/usr/share/nvim/runtime/plugin/shada.vim"
line 1: if exists('g:loaded_shada_plugin')

line 2:   finish

line 3: endif

line 4: let g:loaded_shada_plugin = 1

line 5: 

line 6: augroup ShaDaCommands

line 7:   autocmd!

line 11:   autocmd BufReadCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |call setline('.', shada#get_strings(readfile(expand('<afile>'),'b'))) |setlocal filetype=shada

line 14:   autocmd FileReadCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |call append("'[", shada#get_strings(readfile(expand('<afile>'), 'b')))

line 22:   autocmd BufWriteCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |if writefile(shada#get_binstrings(getline(1, '$')),expand('<afile>'), 'b') == 0 |  let &l:modified = (expand('<afile>') is# bufname(+expand('<abuf>'))? 0: stridx(&cpoptions, '+') != -1) |endif

line 29:   autocmd FileWriteCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |call writefile(shada#get_binstrings(getline(min([line("'["), line("']")]),max([line("'["), line("']")]))),expand('<afile>'),'b')

line 36:   autocmd FileAppendCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |call writefile(shada#get_binstrings(getline(min([line("'["), line("']")]),max([line("'["), line("']")]))),expand('<afile>'),'ab')

line 38:   autocmd SourceCmd *.shada,*.shada.tmp.[a-z] :execute 'rshada' fnameescape(expand('<afile>'))

line 39: augroup END

finished sourcing /usr/share/nvim/runtime/plugin/shada.vim
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/usr/share/nvim/runtime/plugin)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
sourcing "/usr/share/nvim/runtime/plugin/spellfile.vim"
line 1: " Vim plugin for downloading spell files

line 2: 

line 3: if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")

line 4:   finish

line 5: endif

line 6: let loaded_spellfile_plugin = 1

line 7: 

line 8: autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))

finished sourcing /usr/share/nvim/runtime/plugin/spellfile.vim
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/usr/share/nvim/runtime/plugin)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
sourcing "/usr/share/nvim/runtime/plugin/tarPlugin.vim"
line 1: " tarPlugin.vim -- a Vim plugin for browsing tarfiles

line 2: " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>

line 3: " Modified by Charles E. Campbell

line 4: " Distributed under the GNU General Public License.

line 5: "

line 6: " Updates are available from <http://michael.toren.net/code/>.  If you

line 7: " find this script useful, or have suggestions for improvements, please

line 8: " let me know.

line 9: " Also look there for further comments and documentation.

line 10: "

line 11: " This part only sets the autocommands.  The functions are in autoload/tar.vim.

line 12: " ---------------------------------------------------------------------

line 13: "  Load Once: {{{1

line 14: if &cp || exists("g:loaded_tarPlugin")

line 15:  finish

line 16: endif

line 17: let g:loaded_tarPlugin = "v29"

line 18: let s:keepcpo          = &cpo

line 19: set cpo&vim

line 20: 

line 21: " ---------------------------------------------------------------------

line 22: "  Public Interface: {{{1

line 23: augroup tar

line 24:   au!

line 25:   au BufReadCmd   tarfile::*^Icall tar#Read(expand("<amatch>"), 1)

line 26:   au FileReadCmd  tarfile::*^Icall tar#Read(expand("<amatch>"), 0)

line 27:   au BufWriteCmd  tarfile::*^Icall tar#Write(expand("<amatch>"))

line 28:   au FileWriteCmd tarfile::*^Icall tar#Write(expand("<amatch>"))

line 29: 

line 30:   if has("unix")

line 31:    au BufReadCmd   tarfile::*/*^Icall tar#Read(expand("<amatch>"), 1)

line 32:    au FileReadCmd  tarfile::*/*^Icall tar#Read(expand("<amatch>"), 0)

line 33:    au BufWriteCmd  tarfile::*/*^Icall tar#Write(expand("<amatch>"))

line 34:    au FileWriteCmd tarfile::*/*^Icall tar#Write(expand("<amatch>"))

line 35:   endif

line 36: 

line 37:   au BufReadCmd   *.tar.gz^I^Icall tar#Browse(expand("<amatch>"))

line 38:   au BufReadCmd   *.tar^I^I^Icall tar#Browse(expand("<amatch>"))

line 39:   au BufReadCmd   *.lrp^I^I^Icall tar#Browse(expand("<amatch>"))

line 40:   au BufReadCmd   *.tar.bz2^I^Icall tar#Browse(expand("<amatch>"))

line 41:   au BufReadCmd   *.tar.Z^I^Icall tar#Browse(expand("<amatch>"))

line 42:   au BufReadCmd   *.tgz^I^I^Icall tar#Browse(expand("<amatch>"))

line 43:   au BufReadCmd   *.tbz^I^I^Icall tar#Browse(expand("<amatch>"))

line 44:   au BufReadCmd   *.tar.lzma^Icall tar#Browse(expand("<amatch>"))

line 45:   au BufReadCmd   *.tar.xz^I^Icall tar#Browse(expand("<amatch>"))

line 46:   au BufReadCmd   *.txz^I^I^Icall tar#Browse(expand("<amatch>"))

line 47: augroup END

line 48: com! -nargs=? -complete=file Vimuntar call tar#Vimuntar(<q-args>)

line 49: 

line 50: " ---------------------------------------------------------------------

line 51: " Restoration And Modelines: {{{1

line 52: " vim: fdm=marker

line 53: let &cpo= s:keepcpo

line 54: unlet s:keepcpo

finished sourcing /usr/share/nvim/runtime/plugin/tarPlugin.vim
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/usr/share/nvim/runtime/plugin)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
sourcing "/usr/share/nvim/runtime/plugin/tohtml.vim"
line 1: " Vim plugin for converting a syntax highlighted file to HTML.

line 2: " Maintainer: Ben Fritz <fritzophrenic@gmail.com>

line 3: " Last Change: 2015 Sep 08

line 4: "

line 5: " The core of the code is in $VIMRUNTIME/autoload/tohtml.vim and

line 6: " $VIMRUNTIME/syntax/2html.vim

line 7: "

line 8: " TODO: {{{

line 9: "   * Options for generating the CSS in external style sheets. New :TOcss

line 10: "     command to convert the current color scheme into a (mostly) generic CSS

line 11: "     stylesheet which can be re-used. Alternate stylesheet support? Good start

line 12: "     by Erik Falor

line 13: "     ( https://groups.google.com/d/topic/vim_use/7XTmC4D22dU/discussion ).

line 14: "   * Add optional argument to :TOhtml command to specify mode (gui, cterm,

line 15: "     term) to use for the styling. Suggestion by "nacitar".

line 16: "   * Add way to override or specify which RGB colors map to the color numbers

line 17: "     in cterm. Get better defaults than just guessing? Suggestion by "nacitar".

line 18: "   * Disable filetype detection until after all processing is done.

line 19: "   * Add option for not generating the hyperlink on stuff that looks like a

line 20: "     URL? Or just color the link to fit with the colorscheme (and only special

line 21: "     when hovering)?

line 22: "   * Bug: Opera does not allow printing more than one page if uncopyable

line 23: "     regions is turned on. Possible solution: Add normal text line numbers with

line 24: "     display:none, set to display:inline for print style sheets, and hide

line 25: "     <input> elements for print, to allow Opera printing multiple pages (and

line 26: "     other uncopyable areas?). May need to make the new text invisible to IE

line 27: "     with conditional comments to prevent copying it, IE for some reason likes

line 28: "     to copy hidden text. Other browsers too?

line 29: "   * Bug: still a 1px gap throughout the fold column when html_prevent_copy is

line 30: "     "fn" in some browsers. Specifically, in Chromium on Ubuntu (but not Chrome

line 31: "     on Windows). Perhaps it is font related?

line 32: "   * Bug: still some gaps in the fold column when html_prevent_copy contains

line 33: "     'd' and showing the whole diff (observed in multiple browsers). Only gaps

line 34: "     on diff lines though.

line 35: "   * Undercurl support via CSS3, with fallback to dotted or something:

line 36: "^Ihttps://groups.google.com/d/topic/vim_use/BzXA6He1pHg/discussion

line 37: "   * Redo updates for modified default foldtext (v11) when/if the patch is

line 38: "     accepted to modify it.

line 39: "   * Test case +diff_one_file-dynamic_folds+expand_tabs-hover_unfold

line 40: "^I^I+ignore_conceal-ignore_folding+no_foldcolumn+no_pre+no_progress

line 41: "^I^I+number_lines-pre_wrap-use_css+use_xhtml+whole_filler.xhtml

line 42: "     does not show the whole diff filler as it is supposed to?

line 43: "   * Bug: when 'isprint' is wrong for the current encoding, will generate

line 44: "     invalid content. Can/should anything be done about this? Maybe a separate

line 45: "     plugin to correct 'isprint' based on encoding?

line 46: "   * Check to see if the windows-125\d encodings actually work in Unix without

line 47: "     the 8bit- prefix. Add prefix to autoload dictionaries for Unix if not.

line 48: "   * Font auto-detection similar to

line 49: "     http://www.vim.org/scripts/script.php?script_id=2384 but for a variety of

line 50: "     platforms.

line 51: "   * Error thrown when sourcing 2html.vim directly when plugins are not loaded.

line 52: "   * Pull in code from http://www.vim.org/scripts/script.php?script_id=3113 :

line 53: "^I- listchars support

line 54: "^I- full-line background highlight

line 55: "^I- other?

line 56: "   * Make it so deleted lines in a diff don't create side-scrolling (get it

line 57: "     free with full-line background highlight above).

line 58: "   * Restore open/closed folds and cursor position after processing each file

line 59: "     with option not to restore for speed increase.

line 60: "   * Add extra meta info (generation time, etc.)?

line 61: "   * Tidy up so we can use strict doctype in even more situations

line 62: "   * Implementation detail: add threshold for writing the lines to the html

line 63: "     buffer before we're done (5000 or so lines should do it)

line 64: "   * TODO comments for code cleanup scattered throughout

line 65: "}}}

line 66: 

line 67: if exists('g:loaded_2html_plugin')

line 68:   finish

line 69: endif

line 70: let g:loaded_2html_plugin = 'vim7.4_v2'

line 71: 

line 72: "

line 73: " Changelog: {{{

line 74: "   7.4_v2  (this version): Fix error raised when converting a diff containing

line 75: "                           an empty buffer. Jan Stocker: allow g:html_font to

line 76: "                           take a list so it is easier to specfiy fallback

line 77: "                           fonts in the generated CSS.

line 78: "   7.4_v1  (Vim 7.4.0000): Fix modeline mangling for new "Vim:" format, and

line 79: "^I^I^I    also for version-specific modelines like "vim>703:".

line 80: "

line 81: "   7.3 updates: {{{

line 82: "   7.3_v14 (Vim 7.3.1246): Allow suppressing line number anchors using

line 83: "^I^I^I    g:html_line_ids=0. Allow customizing

line 84: "^I^I^I    important IDs (like line IDs and fold IDs) using

line 85: "^I^I^I    g:html_id_expr evalutated when the buffer conversion

line 86: "^I^I^I    is started.

line 87: "   7.3_v13 (Vim 7.3.1088): Keep foldmethod at manual in the generated file and

line 88: "^I^I^I    insert modeline to set it to manual.

line 89: "^I^I^I    Fix bug: diff mode with 2 unsaved buffers creates a

line 90: "^I^I^I    duplicate of one buffer instead of including both.

line 91: "^I^I^I    Add anchors to each line so you can put '#L123'

line 92: "^I^I^I    or '#123' at the end of the URL to jump to line 123

line 93: "^I^I^I    (idea by Andy Spencer). Add javascript to open folds

line 94: "^I^I^I    to show the anchor being jumped to if it is hidden.

line 95: "^I^I^I    Fix XML validation error: &nsbp; not part of XML.

line 96: "^I^I^I    Allow TOhtml to chain together with other commands

line 97: "^I^I^I    using |.

line 98: "   7.3_v12 (Vim 7.3.0616): Fix modeline mangling to also work for when multiple

line 99: "^I^I^I    highlight groups make up the start-of-modeline text.

line 100: "^I^I^I    Improve render time of page with uncopyable regions

line 101: "^I^I^I    by not using one-input-per-char. Change name of

line 102: "^I^I^I    uncopyable option from html_unselectable to

line 103: "^I^I^I    html_prevent_copy. Added html_no_invalid option and

line 104: "^I^I^I    default to inserting invalid markup for uncopyable

line 105: "^I^I^I    regions to prevent MS Word from pasting undeletable

line 106: "^I^I^I    <input> elements. Fix 'cpo' handling (Thilo Six).

line 107: "^I^I 7.3_v12b1: Add html_unselectable option. Rework logic to

line 108: "^I^I^I    eliminate post-processing substitute commands in

line 109: "^I^I^I    favor of doing the work up front. Remove unnecessary

line 110: "^I^I^I    special treatment of 'LineNr' highlight group. Minor

line 111: "^I^I^I    speed improvements. Fix modeline mangling in

line 112: "^I^I^I    generated output so it works for text in the first

line 113: "^I^I^I    column. Fix missing line number and fold column in

line 114: "^I^I^I    diff filler lines. Fix that some fonts have a 1px

line 115: "^I^I^I    gap (using a dirty hack, improvements welcome). Add

line 116: "^I^I^I    "colorscheme" meta tag. Does NOT include support for

line 117: "^I^I^I    the new default foldtext added in v11, as the patch

line 118: "^I^I^I    adding it has not yet been included in Vim.

line 119: "   7.3_v11 ( unreleased ): Support new default foldtext from patch by Christian

line 120: "^I^I^I    Brabandt in

line 121: "^I^I^I    http://groups.google.com/d/topic/vim_dev/B6FSGfq9VoI/discussion.

line 122: "^I^I^I    This patch has not yet been included in Vim, thus

line 123: "^I^I^I    these changes are removed in the next version.

line 124: "   7.3_v10 (Vim 7.3.0227): Fix error E684 when converting a range wholly inside

line 125: "^I^I^I    multiple nested folds with dynamic folding on.

line 126: "^I^I^I    Also fix problem with foldtext in this situation.

line 127: "   7.3_v9  (Vim 7.3.0170): Add html_pre_wrap option active with html_use_css

line 128: "^I^I^I    and without html_no_pre, default value same as

line 129: "^I^I^I    'wrap' option, (Andy Spencer). Don't use

line 130: "^I^I^I    'fileencoding' for converted document encoding if

line 131: "^I^I^I    'buftype' indicates a special buffer which isn't

line 132: "^I^I^I    written.

line 133: "   7.3_v8  (Vim 7.3.0100): Add html_expand_tabs option to allow leaving tab

line 134: "^I^I^I    characters in generated output (Andy Spencer).

line 135: "^I^I^I    Escape text that looks like a modeline so Vim

line 136: "^I^I^I    doesn't use anything in the converted HTML as a

line 137: "^I^I^I    modeline. Bugfixes: Fix folding when a fold starts

line 138: "^I^I^I    before the conversion range. Remove fold column when

line 139: "^I^I^I    there are no folds.

line 140: "   7.3_v7  (Vim 7-3-0063): see betas released on vim_dev below:

line 141: "^I^I  7.3_v7b3: Fixed bug, convert Unicode to UTF-8 all the way.

line 142: "^I^I  7.3_v7b2: Remove automatic detection of encodings that are not

line 143: "^I^I^I    supported by all major browsers according to

line 144: "^I^I^I    http://wiki.whatwg.org/wiki/Web_Encodings and

line 145: "^I^I^I    convert to UTF-8 for all Unicode encodings. Make

line 146: "^I^I^I    HTML encoding to Vim encoding detection be

line 147: "^I^I^I    case-insensitive for built-in pairs.

line 148: "^I^I  7.3_v7b1: Remove use of setwinvar() function which cannot be

line 149: "^I^I^I    called in restricted mode (Andy Spencer). Use

line 150: "^I^I^I    'fencoding' instead of 'encoding' to determine by

line 151: "^I^I^I    charset, and make sure the 'fenc' of the generated

line 152: "^I^I^I    file matches its indicated charset. Add charsets for

line 153: "^I^I^I    all of Vim's natively supported encodings.

line 154: "   7.3_v6  (Vim 7.3.0000): Really fix bug with 'nowrapscan', 'magic' and other

line 155: "^I^I^I    user settings interfering with diff mode generation,

line 156: "^I^I^I    trailing whitespace (e.g. line number column) when

line 157: "^I^I^I    using html_no_pre, and bugs when using

line 158: "^I^I^I    html_hover_unfold.

line 159: "   7.3_v5  ( unreleased ): Fix bug with 'nowrapscan' and also with out-of-sync

line 160: "^I^I^I    folds in diff mode when first line was folded.

line 161: "   7.3_v4  (Vim 7.3.0000): Bugfixes, especially for xhtml markup, and diff mode

line 162: "   7.3_v3  (Vim 7.3.0000): Refactor option handling and make html_use_css

line 163: "^I^I^I    default to true when not set to anything. Use strict

line 164: "^I^I^I    doctypes where possible. Rename use_xhtml option to

line 165: "^I^I^I    html_use_xhtml for consistency. Use .xhtml extension

line 166: "^I^I^I    when using this option. Add meta tag for settings.

line 167: "   7.3_v2  (Vim 7.3.0000): Fix syntax highlighting in diff mode to use both the

line 168: "^I^I^I    diff colors and the normal syntax colors

line 169: "   7.3_v1  (Vim 7.3.0000): Add conceal support and meta tags in output

line 170: "}}}

line 171: "}}}

line 172: 

line 173: " Define the :TOhtml command when:

line 174: " - 'compatible' is not set

line 175: " - this plugin was not already loaded

line 176: " - user commands are available. {{{

line 177: if !&cp && !exists(":TOhtml") && has("user_commands")

line 178:   command -range=% -bar TOhtml :call tohtml#Convert2HTML(<line1>, <line2>)

line 179: endif "}}}

line 180: 

line 181: " Make sure any patches will probably use consistent indent

line 182: "   vim: ts=8 sw=2 sts=2 noet fdm=marker

finished sourcing /usr/share/nvim/runtime/plugin/tohtml.vim
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/usr/share/nvim/runtime/plugin)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
sourcing "/usr/share/nvim/runtime/plugin/tutor.vim"
line 1: if exists('g:loaded_tutor_mode_plugin') || &compatible

line 2:     finish

line 3: endif

line 4: let g:loaded_tutor_mode_plugin = 1

line 5: 

line 6: command! -nargs=? -complete=custom,tutor#TutorCmdComplete Tutor call tutor#TutorCmd(<q-args>)

finished sourcing /usr/share/nvim/runtime/plugin/tutor.vim
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
chdir(/usr/share/nvim/runtime/plugin)
chdir(/home/reggiemarr/Projects/rust_projects/audio-oxide/src)
sourcing "/usr/share/nvim/runtime/plugin/zipPlugin.vim"
line 1: " zipPlugin.vim: Handles browsing zipfiles

line 2: "            PLUGIN PORTION

line 3: " Date:^I^I^ISep 13, 2016

line 4: " Maintainer:^ICharles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>

line 5: " License:^I^IVim License  (see vim's :help license)

line 6: " Copyright:    Copyright (C) 2005-2016 Charles E. Campbell {{{1

line 7: "               Permission is hereby granted to use and distribute this code,

line 8: "               with or without modifications, provided that this copyright

line 9: "               notice is copied with it. Like anything else that's free,

line 10: "               zipPlugin.vim is provided *as is* and comes with no warranty

line 11: "               of any kind, either expressed or implied. By using this

line 12: "               plugin, you agree that in no event will the copyright

line 13: "               holder be liable for any damages resulting from the use

line 14: "               of this software.

line 15: "

line 16: " (James 4:8 WEB) Draw near to God, and he will draw near to you.

line 17: " Cleanse your hands, you sinners; and purify your hearts, you double-minded.

line 18: " ---------------------------------------------------------------------

line 19: " Load Once: {{{1

line 20: if &cp || exists("g:loaded_zipPlugin")

line 21:  finish

line 22: endif

line 23: let g:loaded_zipPlugin = "v28"

line 24: let s:keepcpo          = &cpo

line 25: set cpo&vim

line 26: 

line 27: " ---------------------------------------------------------------------

line 28: " Options: {{{1

line 29: if !exists("g:zipPlugin_ext")

line 30:  let g:zipPlugin_ext='*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip'

line 31: endif

line 32: 

line 33: " ---------------------------------------------------------------------

line 34: " Public Interface: {{{1

line 35: augroup zip

line 36:  au!

line 37:  au BufReadCmd   zipfile:*^Icall zip#Read(expand("<amatch>"), 1)

line 38:  au FileReadCmd  zipfile:*^Icall zip#Read(expand("<amatch>"), 0)

line 39:  au BufWriteCmd  zipfile:*^Icall zip#Write(expand("<amatch>"))

line 40:  au FileWriteCmd zipfile:*^Icall zip#Write(expand("<amatch>"))

line 41: 

line 42:  if has("unix")

line 43:   au BufReadCmd   zipfile:*/*^Icall zip#Read(expand("<amatch>"), 1)

line 44:   au FileReadCmd  zipfile:*/*^Icall zip#Read(expand("<amatch>"), 0)

line 45:   au BufWriteCmd  zipfile:*/*^Icall zip#Write(expand("<amatch>"))

line 46:   au FileWriteCmd zipfile:*/*^Icall zip#Write(expand("<amatch>"))

line 47:  endif

line 48: 

line 49:  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'

line 49: au BufReadCmd *.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip call zip#Browse(expand("<amatch>"))

line 50: augroup END

line 51: 

line 52: " ---------------------------------------------------------------------

line 53: "  Restoration And Modelines: {{{1

line 54: "  vim: fdm=marker

line 55: let &cpo= s:keepcpo

line 56: unlet s:keepcpo

finished sourcing /usr/share/nvim/runtime/plugin/zipPlugin.vim
Searching for "pack/*/start/*" in "/home/reggiemarr/.config/nvim,/etc/xdg/xdg-i3/nvim,/etc/xdg/nvim,/home/reggiemarr/.local/share/nvim/site,/usr/share/i3/nvim/site,/usr/local/share/nvim/site,/usr/share/nvim/site,/var/lib/snapd/desktop/nvim/site,/usr/share/nvim/runtime,/var/lib/snapd/desktop/nvim/site/after,/usr/share/nvim/site/after,/usr/local/share/nvim/site/after,/usr/share/i3/nvim/site/after,/home/reggiemarr/.local/share/nvim/site/after,/etc/xdg/nvim/after,/etc/xdg/xdg-i3/nvim/after,/home/reggiemarr/.config/nvim/after"
Searching for "/home/reggiemarr/.config/nvim/pack/*/start/*"
Searching for "/etc/xdg/xdg-i3/nvim/pack/*/start/*"
Searching for "/etc/xdg/nvim/pack/*/start/*"
Searching for "/home/reggiemarr/.local/share/nvim/site/pack/*/start/*"
Searching for "/usr/share/i3/nvim/site/pack/*/start/*"
Searching for "/usr/local/share/nvim/site/pack/*/start/*"
Searching for "/usr/share/nvim/site/pack/*/start/*"
Searching for "/var/lib/snapd/desktop/nvim/site/pack/*/start/*"
Searching for "/usr/share/nvim/runtime/pack/*/start/*"
Searching for "/var/lib/snapd/desktop/nvim/site/after/pack/*/start/*"
Searching for "/usr/share/nvim/site/after/pack/*/start/*"
Searching for "/usr/local/share/nvim/site/after/pack/*/start/*"
Searching for "/usr/share/i3/nvim/site/after/pack/*/start/*"
Searching for "/home/reggiemarr/.local/share/nvim/site/after/pack/*/start/*"
Searching for "/etc/xdg/nvim/after/pack/*/start/*"
Searching for "/etc/xdg/xdg-i3/nvim/after/pack/*/start/*"
Searching for "/home/reggiemarr/.config/nvim/after/pack/*/start/*"
not found in 'packpath': "pack/*/start/*"
Searching for "plugin/**/*.vim" in "/home/reggiemarr/.config/nvim,/home/reggiemarr/.vim/plugged/LanguageClient-neovim,/home/reggiemarr/.vim/plugged/ncm2,/home/reggiemarr/.vim/plugged/nvim-yarp,/home/reggiemarr/.vim/plugged/ncm2-bufword,/home/reggiemarr/.vim/plugged/ncm2-path,/home/reggiemarr/.vim/plugged/fzf,/home/reggiemarr/.vim/plugged/nerdcommenter,/etc/xdg/xdg-i3/nvim,/etc/xdg/nvim,/home/reggiemarr/.local/share/nvim/site,/usr/share/i3/nvim/site,/usr/local/share/nvim/site,/usr/share/nvim/site,/var/lib/snapd/desktop/nvim/site,/usr/share/nvim/runtime,/var/lib/snapd/desktop/nvim/site/after,/usr/share/nvim/site/after,/usr/local/share/nvim/site/after,/usr/share/i3/nvim/site/after,/home/reggiemarr/.local/share/nvim/site/after,/etc/xdg/nvim/after,/etc/xdg/xdg-i3/nvim/after,/home/reggiemarr/.config/nvim/after"
Searching for "/var/lib/snapd/desktop/nvim/site/after/plugin/**/*.vim"
Searching for "/usr/share/nvim/site/after/plugin/**/*.vim"
Searching for "/usr/local/share/nvim/site/after/plugin/**/*.vim"
Searching for "/usr/share/i3/nvim/site/after/plugin/**/*.vim"
Searching for "/home/reggiemarr/.local/share/nvim/site/after/plugin/**/*.vim"
Searching for "/etc/xdg/nvim/after/plugin/**/*.vim"
Searching for "/etc/xdg/xdg-i3/nvim/after/plugin/**/*.vim"
Searching for "/home/reggiemarr/.config/nvim/after/plugin/**/*.vim"
not found in 'runtimepath': "plugin/**/*.vim"
Reading ShaDa file "/home/reggiemarr/.local/share/nvim/shada/main.shada" info marks oldfiles
Press ENTER or type command to continue